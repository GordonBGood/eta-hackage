From 9ea27674153ae7e53dc14566854afe958af87c14 Mon Sep 17 00:00:00 2001
From: Rahul Muttineni <rahulmutt@gmail.com>
Date: Sat, 28 Jul 2018 06:27:28 +0530
Subject: [PATCH] Patched

---
 data/GLR_Base                          | 273 ++++++++++++++
 data/GLR_Lib                           | 627 ++++++++++++++++++++++++++++++
 data/GLR_Lib-ghc                       | 639 +++++++++++++++++++++++++++++++
 data/GLR_Lib-ghc-debug                 | 672 +++++++++++++++++++++++++++++++++
 data/HappyTemplate                     | 449 ++++++++++++++++++++++
 data/HappyTemplate-arrays              | 468 +++++++++++++++++++++++
 data/HappyTemplate-arrays-coerce       | 489 ++++++++++++++++++++++++
 data/HappyTemplate-arrays-coerce-debug | 504 +++++++++++++++++++++++++
 data/HappyTemplate-arrays-debug        | 483 ++++++++++++++++++++++++
 data/HappyTemplate-arrays-ghc          | 489 ++++++++++++++++++++++++
 data/HappyTemplate-arrays-ghc-debug    | 504 +++++++++++++++++++++++++
 data/HappyTemplate-coerce              | 470 +++++++++++++++++++++++
 data/HappyTemplate-ghc                 | 470 +++++++++++++++++++++++
 happy.cabal                            |  10 +-
 src/Main.lhs                           |  25 +-
 src/ParseMonad.hs                      |   4 +
 src/Parser.hs                          |   2 +-
 src/ProduceGLRCode.lhs                 |  46 ++-
 18 files changed, 6591 insertions(+), 33 deletions(-)
 create mode 100644 data/GLR_Base
 create mode 100644 data/GLR_Lib
 create mode 100644 data/GLR_Lib-ghc
 create mode 100644 data/GLR_Lib-ghc-debug
 create mode 100644 data/HappyTemplate
 create mode 100644 data/HappyTemplate-arrays
 create mode 100644 data/HappyTemplate-arrays-coerce
 create mode 100644 data/HappyTemplate-arrays-coerce-debug
 create mode 100644 data/HappyTemplate-arrays-debug
 create mode 100644 data/HappyTemplate-arrays-ghc
 create mode 100644 data/HappyTemplate-arrays-ghc-debug
 create mode 100644 data/HappyTemplate-coerce
 create mode 100644 data/HappyTemplate-ghc

diff --git a/data/GLR_Base b/data/GLR_Base
new file mode 100644
index 0000000..48967bb
--- /dev/null
+++ b/data/GLR_Base
@@ -0,0 +1,273 @@
+{-# LINE 1 "templates/GLR_Base.hs" #-}
+{-# LINE 1 "templates/GLR_Base.hs" #-}
+{-# LINE 1 "<built-in>" #-}
+{-# LINE 15 "<built-in>" #-}
+{-# LINE 1 "/Users/jyothsnasrinivas/.stack/programs/x86_64-osx/ghc-8.2.2/lib/ghc-8.2.2/include/ghcversion.h" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{-# LINE 16 "<built-in>" #-}
+{-# LINE 1 "/var/folders/m6/wm286css74x1_rxyssdx0b1m0000gn/T/ghc9250_0/ghc_2.h" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{-# LINE 17 "<built-in>" #-}
+{-# LINE 1 "templates/GLR_Base.hs" #-}
+{- GLR_Base.lhs
+   Id: GLR_Base.lhs,v 1.4 2004/12/04 15:01:37 paulcc Exp 
+-}
+
+-- Basic defs required for compiling the data portion of the parser
+
+-- We're creating Int-indexed graphs
+
+type ForestId  = (Int,Int,GSymbol)
+
+
+-- Actions for the GLR machine
+
+data GLRAction = Shift Int [Reduction]
+               | Reduce [Reduction]
+               | Accept
+               | Error
+
+---
+-- A Reduction (s,n,f) removes the top n node-ids, creates a new branch from these
+-- and labels the branch with the given symbol s. Additionally, the branch may
+-- hold some semantic value.
+
+type Reduction = (GSymbol,Int, [ForestId] -> Branch)
+
+
+---
+-- A Branch holds the semantic result plus node ids of children
+
+data Branch
+ = Branch {b_sem :: GSem, b_nodes :: [ForestId]}
+   deriving Show
+
+instance Eq Branch where
+        b1 == b2 = b_nodes b1 == b_nodes b2
+
+
+
+-------------------------------------------------------------------------------
+-- Utilities for decoding
+
+---
+-- Tree decode unpacks the forest into a list of results
+--  - this is ok for small examples, but inefficient for very large examples
+--  - the data file contains further instances
+--  - see documentation for further information
+--  - "Decode_Result" is a synonym used to insert the monad type constr (or not)
+
+class TreeDecode a where
+        decode_b :: (ForestId -> [Branch]) -> Branch -> [Decode_Result a]
+
+decode :: TreeDecode a => (ForestId -> [Branch]) -> ForestId -> [Decode_Result a]
+decode f i@(_,_,HappyTok t)
+  = decode_b f (Branch (SemTok t) [])
+decode f i
+  = [ d | b <- f i, d <- decode_b f b ]
+
+---- generated by Happy, since it means expansion of synonym (not ok in H-98)
+--instance TreeDecode UserDefTok where
+--      decode_b f (Branch (SemTok t) []) = [happy_return t]
+
+---
+-- this is used to multiply the ambiguous possibilities from children
+
+--cross_fn :: [a -> b] -> [a] -> [b]
+--actual type will depend on monad in use.
+--happy_ap defined by parser generator
+cross_fn fs as = [ f `happy_ap` a | f <- fs, a <- as]
+
+---
+-- Label decoding unpacks from the Semantic wrapper type
+--  - this allows arbitrary values (within the limits of the compiler settings)
+--    to be recovered from nodes in the tree.
+--  - again, more instances are written in the data file
+--  - see documentation for further information
+
+class LabelDecode a where
+        unpack :: GSem -> a
+
+---- generated by Happy, since it means expansion of synonym (not ok in H-98)
+--instance LabelDecode UserDefTok where
+--      unpack (SemTok t) = t
+
+
+
diff --git a/data/GLR_Lib b/data/GLR_Lib
new file mode 100644
index 0000000..e9906cb
--- /dev/null
+++ b/data/GLR_Lib
@@ -0,0 +1,627 @@
+{-# LINE 1 "templates/GLR_Lib.hs" #-}
+{-# LINE 1 "templates/GLR_Lib.hs" #-}
+{-# LINE 1 "<built-in>" #-}
+{-# LINE 15 "<built-in>" #-}
+{-# LINE 1 "/Users/jyothsnasrinivas/.stack/programs/x86_64-osx/ghc-8.2.2/lib/ghc-8.2.2/include/ghcversion.h" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{-# LINE 16 "<built-in>" #-}
+{-# LINE 1 "/var/folders/m6/wm286css74x1_rxyssdx0b1m0000gn/T/ghc9253_0/ghc_2.h" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{-# LINE 17 "<built-in>" #-}
+{-# LINE 1 "templates/GLR_Lib.hs" #-}
+{-# LINE 1 "GLR_Lib.hs" #-}
+
+{-
+   GLR_Lib.lhs
+   Id: GLR_Lib.lhs,v 1.5 2005/08/03 13:42:23 paulcc Exp 
+-}
+
+ {-
+ Parser driver for the GLR parser.
+
+ (c) University of Durham, Ben Medlock 2001
+         -- initial code, for structure parsing
+ (c) University of Durham, Paul Callaghan 2004-05
+         -- extension to semantic rules
+         -- shifting to chart data structure
+         -- supporting hidden left recursion
+         -- many optimisations
+ -}
+
+{- supplied by Happy
+<> module XYZ (
+<>              lexer   -- conditional
+-}
+
+        -- probable, but might want to parametrise
+           , doParse
+           , TreeDecode(..), decode     -- only for tree decode
+           , LabelDecode(..)            -- only for label decode
+
+        -- standard exports
+           , Tokens
+           , GLRResult(..)
+           , NodeMap
+           , RootNode
+           , ForestId
+           , GSymbol(..)
+           , Branch(..)
+           , GSem(..)
+           )
+  where
+
+import Data.Char
+import qualified Data.Map as Map
+
+import Control.Applicative (Applicative(..))
+import Control.Monad (foldM, ap)
+import Data.Maybe (fromJust)
+import Data.List (insertBy, nub, maximumBy, partition, find, groupBy, delete)
+
+
+
+
+
+
+
+
+
+
+
+{- these inserted by Happy -}
+
+fakeimport DATA
+
+{- borrowed from GenericTemplate.hs -}
+
+
+{-# LINE 89 "templates/GLR_Lib.hs" #-}
+
+
+{-# LINE 103 "templates/GLR_Lib.hs" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+doParse = glr_parse
+
+
+----------------------------------------------------------------------------
+-- Main data types
+
+-- A forest is a map of `spans' to branches, where a span is a start position,
+-- and end position, and a grammatical category for that interval. Branches
+-- are lists of conjunctions of symbols which can be matched in that span.
+-- Note that tokens are stored as part of the spans.
+
+type Forest       = Map.Map ForestId [Branch]
+
+---
+-- End result of parsing:
+--  - successful parse with rooted forest
+--  - else syntax error or premature eof
+
+type NodeMap = [(ForestId, [Branch])]
+type RootNode = ForestId
+type Tokens = [[(Int, GSymbol)]]        -- list of ambiguous lexemes
+
+data GLRResult
+ = ParseOK     RootNode Forest    -- forest with root
+ | ParseError  Tokens   Forest    -- partial forest with bad input
+ | ParseEOF             Forest    -- partial forest (missing input)
+
+-----------------------
+-- Forest to simplified output
+
+forestResult :: Int -> Forest -> GLRResult
+forestResult length f
+ = case roots of
+        []       -> ParseEOF f
+        [r]      -> ParseOK r f
+        rs@(_:_) -> error $ "multiple roots in forest, = " ++ show rs
+                                                ++ unlines (map show ns_map)
+   where
+       ns_map = Map.toList f
+       roots  = [ r | (r@(0,sz,sym),_) <- ns_map
+                    , sz == length
+                    , sym == top_symbol ]
+
+
+----------------------------------------------------------------------------
+
+glr_parse :: [[UserDefTok]] -> GLRResult
+glr_parse toks
+ = case runST Map.empty [0..] (tp toks) of
+    (f,Left ts)   -> ParseError ts f
+                                                -- Error within sentence
+    (f,Right ss)  -> forestResult (length toks) f
+                                                -- Either good parse or EOF
+   where
+        tp tss = doActions [initTS 0]
+               $ zipWith (\i ts -> [(i, t) | t <- ts]) [0..]
+              $ [ [ HappyTok {-j-} t | (j,t) <- zip [0..] ts ] | ts <- tss ]
+                ++ [[HappyEOF]]
+
+---
+
+type PM a = ST Forest [Int] a
+type FStack = TStack ForestId
+
+
+---
+-- main function
+
+doActions :: [FStack] -> Tokens -> PM (Either Tokens [FStack])
+
+doActions ss []                 -- no more tokens (this is ok)
+ = return (Right ss)            -- return the stacks (may be empty)
+
+doActions stks (tok:toks)
+ = do
+        stkss <- sequence [ do
+                             stks' <- reduceAll [] tok_form stks
+                             shiftAll tok_form stks'
+                         | tok_form <- tok ]
+        let new_stks = merge $ concat stkss
+        {- nothing -}
+        
+        case new_stks of            -- did this token kill stacks?
+          [] -> case toks of
+                  []  -> return $ Right []         -- ok if no more tokens
+                  _:_ -> return $ Left (tok:toks)  -- not ok if some input left
+          _  -> doActions new_stks toks
+
+reduceAll
+ :: [GSymbol] -> (Int, GSymbol) -> [FStack] -> PM [(FStack, Int)]
+reduceAll _ tok [] = return []
+reduceAll cyclic_names itok@(i,tok) (stk:stks)
+ = do
+     case action this_state tok of
+       Accept      -> reduceAll [] itok stks
+       Error       -> reduceAll [] itok stks
+       Shift st rs -> do { ss <- redAll rs ; return $ (stk,st) : ss }
+       Reduce rs   -> redAll rs
+ where
+  this_state = top stk
+  redAll rs
+   = do
+        let reds = [ (bf fids,stk',m)
+                   | (m,n,bf) <- rs
+                   , not (n == 0 && m `elem` cyclic_names)  -- remove done ones
+                   , (fids,stk') <- pop n stk
+                   ]
+                   -- WARNING: incomplete if more than one Empty in a prod(!)
+                   -- WARNING: can avoid by splitting emps/non-emps
+        {- nothing -}
+        
+        stks' <- foldM (pack i) stks reds
+        let new_cyclic = [ m | (m,0,_) <- rs
+                             , (this_state ==  goto this_state m)
+                             , m `notElem` cyclic_names ]
+        reduceAll (cyclic_names ++ new_cyclic) itok $ merge stks'
+
+shiftAll :: (Int, GSymbol) -> [(FStack, Int)] -> PM [FStack]
+shiftAll tok [] = return []
+shiftAll (j,tok) stks
+ = do
+        let end = j + 1
+        let key = end `seq` (j,end,tok)
+        newNode key
+        let mss = [ (stk, st)
+                  | ss@((_,st):_) <- groupBy (\a b -> snd a == snd b) stks
+                  , stk <- merge $ map fst ss ]
+        stks' <- sequence [ do { nid <- getID ; return (push key st nid stk) }
+                          | (stk,(st)) <- mss ]
+        return stks'
+
+
+pack
+ :: Int -> [FStack] -> (Branch, FStack, GSymbol) -> PM [FStack]
+
+pack e_i stks (fids,stk,m)
+ | (st <  (0))
+    = return stks
+ | otherwise
+    = do
+       let s_i = endpoint stk
+       let key = (s_i,e_i,m)
+       {- nothing -}
+
+       
+
+
+       duplicate <- addBranch key fids
+
+       let stack_matches = [ s | s <- stks
+                                , (top s ==  st)
+                               , let (k,s') = case ts_tail s of x:_ -> x
+                                , stk == s'
+                                , k == key
+                                ]  -- look for first obvious packing site
+       let appears_in = not $ null stack_matches
+
+       {- nothing -}
+       
+
+       {- nothing -}
+
+       
+
+
+
+       if duplicate && appears_in
+        then return stks       -- because already there
+        else do
+              nid <- getID
+              case stack_matches of
+                []  -> return $ insertStack (push key st nid stk) stks
+                                -- No prior stacks
+
+                s:_ -> return $ insertStack (push key st nid stk) (delete s stks)
+                                -- pack into an existing stack
+    where
+       st = goto (top stk) m
+
+
+
+---
+-- record an entry
+--  - expected: "i" will contain a token
+
+newNode :: ForestId -> PM ()
+newNode i
+ = chgS $ \f -> ((), Map.insert i [] f)
+
+---
+-- add a new branch
+--  - due to packing, we check to see if a branch is already there
+--  - return True if the branch is already there
+
+addBranch :: ForestId -> Branch -> PM Bool
+addBranch i b
+ = do
+        f <- useS id
+        case Map.lookup i f of
+         Nothing               -> chgS $ \f -> (False, Map.insert i [b] f)
+         Just bs | b `elem` bs -> return True
+                 | otherwise   -> chgS $ \f -> (True,  Map.insert i (b:bs) f)
+
+---
+-- only for use with nodes that exist
+
+getBranches ::  ForestId -> PM [Branch]
+getBranches i
+ = useS $ \s -> Map.findWithDefault no_such_node i s
+   where
+        no_such_node = error $ "No such node in Forest: " ++ show i
+
+
+
+
+
+-----------------------------------------------------------------------------
+-- Auxiliary functions
+
+(<>) x y = (x,y)  -- syntactic sugar
+
+
+
+-- Tomita stack
+--  - basic idea taken from Peter Ljungloef's Licentiate thesis
+
+
+data TStack a
+ = TS { top      :: Int            -- state
+      , ts_id    :: Int            -- ID
+      , stoup    :: !(Maybe a)          -- temp holding place, for left rec.
+      , ts_tail  :: ![(a,TStack a)]     -- [(element on arc , child)]
+      }
+
+instance Show a => Show (TStack a) where
+  show ts
+   = "St" ++ show ((top ts))
+
+
+
+
+
+
+
+
+
+---
+-- id uniquely identifies a stack
+
+instance Eq (TStack a) where
+      s1 == s2 = (ts_id s1 ==  ts_id s2)
+
+--instance Ord (TStack a) where
+--      s1 `compare` s2 = (ts_id s1) `compare` (ts_id s2)
+
+---
+-- Nothing special done for insertion
+-- - NB merging done at strategic points
+
+insertStack :: TStack a -> [TStack a] -> [TStack a]
+insertStack = (:)
+
+---
+
+initTS :: Int -> TStack a
+initTS (id) = TS (0) id Nothing []
+
+---
+
+push :: ForestId -> Int -> Int -> TStack ForestId -> TStack ForestId
+push x@(s_i,e_i,m) st (id) stk
+ = TS st id stoup [(x,stk)]
+   where
+        -- only fill stoup for cyclic states that don't consume input
+       stoup | s_i == e_i && (st ==  goto st m) = Just x
+             | otherwise                        = Nothing
+
+---
+
+pop :: Int -> TStack a -> [([a],TStack a)]
+pop 0 ts = [([],ts)]
+pop 1 st@TS{stoup=Just x}
+ = pop 1 st{stoup=Nothing} ++ [ ([x],st) ]
+pop n ts = [ (xs ++ [x] , stk')
+            | (x,stk) <- ts_tail ts
+            , (xs,stk') <- pop (n-1) stk ]
+
+---
+
+popF :: TStack a -> TStack a
+popF ts = case ts_tail ts of (_,c):_ -> c
+
+---
+
+endpoint stk
+ = case ts_tail stk of
+     [] -> 0
+     ((_,e_i,_),_):_ -> e_i
+
+
+
+---
+
+merge :: (Eq a, Show a) => [TStack a] -> [TStack a]
+merge stks
+ = [ TS st id ss (nub ch)
+   | (st) <- nub (map (\s -> (top s)) stks)
+   , let ch  = concat  [ x | TS st2 _ _ x <- stks, (st == st2) ]
+         ss  = mkss    [ s | TS st2 _ s _ <- stks, (st == st2) ]
+         ( (id)) = head [ (i) | TS st2 i _ _ <- stks, (st == st2) ]
+          -- reuse of id is ok, since merge discards old stacks
+   ]
+   where
+        mkss s = case nub [ x | Just x <- s ] of
+                   []  -> Nothing
+                   [x] -> Just x
+                   xs  -> error $ unlines $ ("Stoup merge: " ++ show xs)
+                                           : map show stks
+
+
+
+----------------------------------------------------------------------------
+-- Monad
+-- TODO (pcc): combine the s/i, or use the modern libraries - might be faster?
+--             but some other things are much, much, much more expensive!
+
+data ST s i a = MkST (s -> i -> (a,s,i))
+
+instance Functor (ST s i) where
+ fmap f (MkST sf)
+  = MkST $ \s i -> case sf s i of (a,s',i') -> (f a,s',i')
+
+instance Applicative (ST s i) where
+ pure a = MkST $ \s i -> (a,s,i)
+ (<*>) = ap
+
+instance Monad (ST s i) where
+ return = pure
+ MkST sf >>= k
+  = MkST $ \s i ->
+        case sf s i of
+         (a,s',i') -> let (MkST sf') = k a in  sf' s' i'
+
+runST :: s -> i -> ST s i a -> (s,a)
+runST s i (MkST sf) = case sf s i of
+                           (a,s,_) -> (s,a)
+
+chgS :: (s -> (a,s)) -> ST s i a
+chgS sf = MkST $ \s i -> let (a,s') = sf s in (a,s',i)
+
+useS :: (s -> b) -> ST s i b
+useS fn = MkST $ \s i -> (fn s,s,i)
+
+getID :: ST s [Int] Int
+getID = MkST $ \s (i:is) -> (i,s,is)
+
+
diff --git a/data/GLR_Lib-ghc b/data/GLR_Lib-ghc
new file mode 100644
index 0000000..c2d891d
--- /dev/null
+++ b/data/GLR_Lib-ghc
@@ -0,0 +1,639 @@
+{-# LINE 1 "templates/GLR_Lib.hs" #-}
+{-# LINE 1 "templates/GLR_Lib.hs" #-}
+{-# LINE 1 "<built-in>" #-}
+{-# LINE 16 "<built-in>" #-}
+{-# LINE 1 "/Users/jyothsnasrinivas/.stack/programs/x86_64-osx/ghc-8.2.2/lib/ghc-8.2.2/include/ghcversion.h" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{-# LINE 17 "<built-in>" #-}
+{-# LINE 1 "/var/folders/m6/wm286css74x1_rxyssdx0b1m0000gn/T/ghc9256_0/ghc_2.h" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{-# LINE 18 "<built-in>" #-}
+{-# LINE 1 "templates/GLR_Lib.hs" #-}
+{-# LINE 1 "GLR_Lib.hs" #-}
+
+{-
+   GLR_Lib.lhs
+   Id: GLR_Lib.lhs,v 1.5 2005/08/03 13:42:23 paulcc Exp 
+-}
+
+ {-
+ Parser driver for the GLR parser.
+
+ (c) University of Durham, Ben Medlock 2001
+         -- initial code, for structure parsing
+ (c) University of Durham, Paul Callaghan 2004-05
+         -- extension to semantic rules
+         -- shifting to chart data structure
+         -- supporting hidden left recursion
+         -- many optimisations
+ -}
+
+{- supplied by Happy
+<> module XYZ (
+<>              lexer   -- conditional
+-}
+
+        -- probable, but might want to parametrise
+           , doParse
+           , TreeDecode(..), decode     -- only for tree decode
+           , LabelDecode(..)            -- only for label decode
+
+        -- standard exports
+           , Tokens
+           , GLRResult(..)
+           , NodeMap
+           , RootNode
+           , ForestId
+           , GSymbol(..)
+           , Branch(..)
+           , GSem(..)
+           )
+  where
+
+import Data.Char
+import qualified Data.Map as Map
+
+import Control.Applicative (Applicative(..))
+import Control.Monad (foldM, ap)
+import Data.Maybe (fromJust)
+import Data.List (insertBy, nub, maximumBy, partition, find, groupBy, delete)
+
+import GHC.Prim
+import GHC.Exts
+
+
+
+
+
+
+
+
+{- these inserted by Happy -}
+
+fakeimport DATA
+
+{- borrowed from GenericTemplate.hs -}
+
+
+
+
+
+
+
+
+{-# LINE 81 "templates/GLR_Lib.hs" #-}
+
+
+
+
+
+
+
+
+{-# LINE 103 "templates/GLR_Lib.hs" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+doParse = glr_parse
+
+
+----------------------------------------------------------------------------
+-- Main data types
+
+-- A forest is a map of `spans' to branches, where a span is a start position,
+-- and end position, and a grammatical category for that interval. Branches
+-- are lists of conjunctions of symbols which can be matched in that span.
+-- Note that tokens are stored as part of the spans.
+
+type Forest       = Map.Map ForestId [Branch]
+
+---
+-- End result of parsing:
+--  - successful parse with rooted forest
+--  - else syntax error or premature eof
+
+type NodeMap = [(ForestId, [Branch])]
+type RootNode = ForestId
+type Tokens = [[(Int, GSymbol)]]        -- list of ambiguous lexemes
+
+data GLRResult
+ = ParseOK     RootNode Forest    -- forest with root
+ | ParseError  Tokens   Forest    -- partial forest with bad input
+ | ParseEOF             Forest    -- partial forest (missing input)
+
+-----------------------
+-- Forest to simplified output
+
+forestResult :: Int -> Forest -> GLRResult
+forestResult length f
+ = case roots of
+        []       -> ParseEOF f
+        [r]      -> ParseOK r f
+        rs@(_:_) -> error $ "multiple roots in forest, = " ++ show rs
+                                                ++ unlines (map show ns_map)
+   where
+       ns_map = Map.toList f
+       roots  = [ r | (r@(0,sz,sym),_) <- ns_map
+                    , sz == length
+                    , sym == top_symbol ]
+
+
+----------------------------------------------------------------------------
+
+glr_parse :: [[UserDefTok]] -> GLRResult
+glr_parse toks
+ = case runST Map.empty [0..] (tp toks) of
+    (f,Left ts)   -> ParseError ts f
+                                                -- Error within sentence
+    (f,Right ss)  -> forestResult (length toks) f
+                                                -- Either good parse or EOF
+   where
+        tp tss = doActions [initTS 0]
+               $ zipWith (\i ts -> [(i, t) | t <- ts]) [0..]
+              $ [ [ HappyTok {-j-} t | (j,t) <- zip [0..] ts ] | ts <- tss ]
+                ++ [[HappyEOF]]
+
+---
+
+type PM a = ST Forest [Int] a
+type FStack = TStack ForestId
+
+
+---
+-- main function
+
+doActions :: [FStack] -> Tokens -> PM (Either Tokens [FStack])
+
+doActions ss []                 -- no more tokens (this is ok)
+ = return (Right ss)            -- return the stacks (may be empty)
+
+doActions stks (tok:toks)
+ = do
+        stkss <- sequence [ do
+                             stks' <- reduceAll [] tok_form stks
+                             shiftAll tok_form stks'
+                         | tok_form <- tok ]
+        let new_stks = merge $ concat stkss
+        {- nothing -}
+        
+        case new_stks of            -- did this token kill stacks?
+          [] -> case toks of
+                  []  -> return $ Right []         -- ok if no more tokens
+                  _:_ -> return $ Left (tok:toks)  -- not ok if some input left
+          _  -> doActions new_stks toks
+
+reduceAll
+ :: [GSymbol] -> (Int, GSymbol) -> [FStack] -> PM [(FStack, Int)]
+reduceAll _ tok [] = return []
+reduceAll cyclic_names itok@(i,tok) (stk:stks)
+ = do
+     case action this_state tok of
+       Accept      -> reduceAll [] itok stks
+       Error       -> reduceAll [] itok stks
+       Shift st rs -> do { ss <- redAll rs ; return $ (stk,st) : ss }
+       Reduce rs   -> redAll rs
+ where
+  this_state = top stk
+  redAll rs
+   = do
+        let reds = [ (bf fids,stk',m)
+                   | (m,n,bf) <- rs
+                   , not (n == 0 && m `elem` cyclic_names)  -- remove done ones
+                   , (fids,stk') <- pop n stk
+                   ]
+                   -- WARNING: incomplete if more than one Empty in a prod(!)
+                   -- WARNING: can avoid by splitting emps/non-emps
+        {- nothing -}
+        
+        stks' <- foldM (pack i) stks reds
+        let new_cyclic = [ m | (m,0,_) <- rs
+                             , (isTrue# (this_state ==#  goto this_state m))
+                             , m `notElem` cyclic_names ]
+        reduceAll (cyclic_names ++ new_cyclic) itok $ merge stks'
+
+shiftAll :: (Int, GSymbol) -> [(FStack, Int)] -> PM [FStack]
+shiftAll tok [] = return []
+shiftAll (j,tok) stks
+ = do
+        let end = j + 1
+        let key = end `seq` (j,end,tok)
+        newNode key
+        let mss = [ (stk, st)
+                  | ss@((_,st):_) <- groupBy (\a b -> snd a == snd b) stks
+                  , stk <- merge $ map fst ss ]
+        stks' <- sequence [ do { nid <- getID ; return (push key st nid stk) }
+                          | (stk,(I# (st))) <- mss ]
+        return stks'
+
+
+pack
+ :: Int -> [FStack] -> (Branch, FStack, GSymbol) -> PM [FStack]
+
+pack e_i stks (fids,stk,m)
+ | (isTrue# (st <#  0#))
+    = return stks
+ | otherwise
+    = do
+       let s_i = endpoint stk
+       let key = (s_i,e_i,m)
+       {- nothing -}
+
+       
+
+
+       duplicate <- addBranch key fids
+
+       let stack_matches = [ s | s <- stks
+                                , (isTrue# (top s ==#  st))
+                               , let (k,s') = case ts_tail s of x:_ -> x
+                                , stk == s'
+                                , k == key
+                                ]  -- look for first obvious packing site
+       let appears_in = not $ null stack_matches
+
+       {- nothing -}
+       
+
+       {- nothing -}
+
+       
+
+
+
+       if duplicate && appears_in
+        then return stks       -- because already there
+        else do
+              nid <- getID
+              case stack_matches of
+                []  -> return $ insertStack (push key st nid stk) stks
+                                -- No prior stacks
+
+                s:_ -> return $ insertStack (push key st nid stk) (delete s stks)
+                                -- pack into an existing stack
+    where
+       st = goto (top stk) m
+
+
+
+---
+-- record an entry
+--  - expected: "i" will contain a token
+
+newNode :: ForestId -> PM ()
+newNode i
+ = chgS $ \f -> ((), Map.insert i [] f)
+
+---
+-- add a new branch
+--  - due to packing, we check to see if a branch is already there
+--  - return True if the branch is already there
+
+addBranch :: ForestId -> Branch -> PM Bool
+addBranch i b
+ = do
+        f <- useS id
+        case Map.lookup i f of
+         Nothing               -> chgS $ \f -> (False, Map.insert i [b] f)
+         Just bs | b `elem` bs -> return True
+                 | otherwise   -> chgS $ \f -> (True,  Map.insert i (b:bs) f)
+
+---
+-- only for use with nodes that exist
+
+getBranches ::  ForestId -> PM [Branch]
+getBranches i
+ = useS $ \s -> Map.findWithDefault no_such_node i s
+   where
+        no_such_node = error $ "No such node in Forest: " ++ show i
+
+
+
+
+
+-----------------------------------------------------------------------------
+-- Auxiliary functions
+
+(<>) x y = (x,y)  -- syntactic sugar
+
+
+
+-- Tomita stack
+--  - basic idea taken from Peter Ljungloef's Licentiate thesis
+
+
+data TStack a
+ = TS { top      :: Int#            -- state
+      , ts_id    :: Int#            -- ID
+      , stoup    :: !(Maybe a)          -- temp holding place, for left rec.
+      , ts_tail  :: ![(a,TStack a)]     -- [(element on arc , child)]
+      }
+
+instance Show a => Show (TStack a) where
+  show ts
+   = "St" ++ show ((I# (top ts)))
+
+
+
+
+
+
+
+
+
+---
+-- id uniquely identifies a stack
+
+instance Eq (TStack a) where
+      s1 == s2 = (isTrue# (ts_id s1 ==#  ts_id s2))
+
+--instance Ord (TStack a) where
+--      s1 `compare` s2 = (I# (ts_id s1)) `compare` (I# (ts_id s2))
+
+---
+-- Nothing special done for insertion
+-- - NB merging done at strategic points
+
+insertStack :: TStack a -> [TStack a] -> [TStack a]
+insertStack = (:)
+
+---
+
+initTS :: Int -> TStack a
+initTS (I# (id)) = TS 0# id Nothing []
+
+---
+
+push :: ForestId -> Int# -> Int -> TStack ForestId -> TStack ForestId
+push x@(s_i,e_i,m) st (I# (id)) stk
+ = TS st id stoup [(x,stk)]
+   where
+        -- only fill stoup for cyclic states that don't consume input
+       stoup | s_i == e_i && (isTrue# (st ==#  goto st m)) = Just x
+             | otherwise                        = Nothing
+
+---
+
+pop :: Int -> TStack a -> [([a],TStack a)]
+pop 0 ts = [([],ts)]
+pop 1 st@TS{stoup=Just x}
+ = pop 1 st{stoup=Nothing} ++ [ ([x],st) ]
+pop n ts = [ (xs ++ [x] , stk')
+            | (x,stk) <- ts_tail ts
+            , (xs,stk') <- pop (n-1) stk ]
+
+---
+
+popF :: TStack a -> TStack a
+popF ts = case ts_tail ts of (_,c):_ -> c
+
+---
+
+endpoint stk
+ = case ts_tail stk of
+     [] -> 0
+     ((_,e_i,_),_):_ -> e_i
+
+
+
+---
+
+merge :: (Eq a, Show a) => [TStack a] -> [TStack a]
+merge stks
+ = [ TS st id ss (nub ch)
+   | (I# (st)) <- nub (map (\s -> (I# (top s))) stks)
+   , let ch  = concat  [ x | TS st2 _ _ x <- stks, (isTrue# (st ==# st2)) ]
+         ss  = mkss    [ s | TS st2 _ s _ <- stks, (isTrue# (st ==# st2)) ]
+         (! (I# (id))) = head [ (I# (i)) | TS st2 i _ _ <- stks, (isTrue# (st ==# st2)) ]
+          -- reuse of id is ok, since merge discards old stacks
+   ]
+   where
+        mkss s = case nub [ x | Just x <- s ] of
+                   []  -> Nothing
+                   [x] -> Just x
+                   xs  -> error $ unlines $ ("Stoup merge: " ++ show xs)
+                                           : map show stks
+
+
+
+----------------------------------------------------------------------------
+-- Monad
+-- TODO (pcc): combine the s/i, or use the modern libraries - might be faster?
+--             but some other things are much, much, much more expensive!
+
+data ST s i a = MkST (s -> i -> (a,s,i))
+
+instance Functor (ST s i) where
+ fmap f (MkST sf)
+  = MkST $ \s i -> case sf s i of (a,s',i') -> (f a,s',i')
+
+instance Applicative (ST s i) where
+ pure a = MkST $ \s i -> (a,s,i)
+ (<*>) = ap
+
+instance Monad (ST s i) where
+ return = pure
+ MkST sf >>= k
+  = MkST $ \s i ->
+        case sf s i of
+         (a,s',i') -> let (MkST sf') = k a in  sf' s' i'
+
+runST :: s -> i -> ST s i a -> (s,a)
+runST s i (MkST sf) = case sf s i of
+                           (a,s,_) -> (s,a)
+
+chgS :: (s -> (a,s)) -> ST s i a
+chgS sf = MkST $ \s i -> let (a,s') = sf s in (a,s',i)
+
+useS :: (s -> b) -> ST s i b
+useS fn = MkST $ \s i -> (fn s,s,i)
+
+getID :: ST s [Int] Int
+getID = MkST $ \s (i:is) -> (i,s,is)
+
+
diff --git a/data/GLR_Lib-ghc-debug b/data/GLR_Lib-ghc-debug
new file mode 100644
index 0000000..92d7e27
--- /dev/null
+++ b/data/GLR_Lib-ghc-debug
@@ -0,0 +1,672 @@
+{-# LINE 1 "templates/GLR_Lib.hs" #-}
+{-# LINE 1 "templates/GLR_Lib.hs" #-}
+{-# LINE 1 "<built-in>" #-}
+{-# LINE 17 "<built-in>" #-}
+{-# LINE 1 "/Users/jyothsnasrinivas/.stack/programs/x86_64-osx/ghc-8.2.2/lib/ghc-8.2.2/include/ghcversion.h" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{-# LINE 18 "<built-in>" #-}
+{-# LINE 1 "/var/folders/m6/wm286css74x1_rxyssdx0b1m0000gn/T/ghc9259_0/ghc_2.h" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{-# LINE 19 "<built-in>" #-}
+{-# LINE 1 "templates/GLR_Lib.hs" #-}
+{-# LINE 1 "GLR_Lib.hs" #-}
+
+{-
+   GLR_Lib.lhs
+   Id: GLR_Lib.lhs,v 1.5 2005/08/03 13:42:23 paulcc Exp 
+-}
+
+ {-
+ Parser driver for the GLR parser.
+
+ (c) University of Durham, Ben Medlock 2001
+         -- initial code, for structure parsing
+ (c) University of Durham, Paul Callaghan 2004-05
+         -- extension to semantic rules
+         -- shifting to chart data structure
+         -- supporting hidden left recursion
+         -- many optimisations
+ -}
+
+{- supplied by Happy
+<> module XYZ (
+<>              lexer   -- conditional
+-}
+
+        -- probable, but might want to parametrise
+           , doParse
+           , TreeDecode(..), decode     -- only for tree decode
+           , LabelDecode(..)            -- only for label decode
+
+        -- standard exports
+           , Tokens
+           , GLRResult(..)
+           , NodeMap
+           , RootNode
+           , ForestId
+           , GSymbol(..)
+           , Branch(..)
+           , GSem(..)
+           )
+  where
+
+import Data.Char
+import qualified Data.Map as Map
+
+import Control.Applicative (Applicative(..))
+import Control.Monad (foldM, ap)
+import Data.Maybe (fromJust)
+import Data.List (insertBy, nub, maximumBy, partition, find, groupBy, delete)
+
+import GHC.Prim
+import GHC.Exts
+
+
+
+import System.IO
+import System.IO.Unsafe
+import Text.PrettyPrint
+
+
+{- these inserted by Happy -}
+
+fakeimport DATA
+
+{- borrowed from GenericTemplate.hs -}
+
+
+
+
+
+
+
+
+{-# LINE 81 "templates/GLR_Lib.hs" #-}
+
+
+
+
+
+
+
+
+{-# LINE 103 "templates/GLR_Lib.hs" #-}
+
+
+
+happyTrace string expr = unsafePerformIO $ do
+    hPutStr stderr string
+    return expr
+
+
+
+
+
+
+doParse = glr_parse
+
+
+----------------------------------------------------------------------------
+-- Main data types
+
+-- A forest is a map of `spans' to branches, where a span is a start position,
+-- and end position, and a grammatical category for that interval. Branches
+-- are lists of conjunctions of symbols which can be matched in that span.
+-- Note that tokens are stored as part of the spans.
+
+type Forest       = Map.Map ForestId [Branch]
+
+---
+-- End result of parsing:
+--  - successful parse with rooted forest
+--  - else syntax error or premature eof
+
+type NodeMap = [(ForestId, [Branch])]
+type RootNode = ForestId
+type Tokens = [[(Int, GSymbol)]]        -- list of ambiguous lexemes
+
+data GLRResult
+ = ParseOK     RootNode Forest    -- forest with root
+ | ParseError  Tokens   Forest    -- partial forest with bad input
+ | ParseEOF             Forest    -- partial forest (missing input)
+
+-----------------------
+-- Forest to simplified output
+
+forestResult :: Int -> Forest -> GLRResult
+forestResult length f
+ = case roots of
+        []       -> ParseEOF f
+        [r]      -> ParseOK r f
+        rs@(_:_) -> error $ "multiple roots in forest, = " ++ show rs
+                                                ++ unlines (map show ns_map)
+   where
+       ns_map = Map.toList f
+       roots  = [ r | (r@(0,sz,sym),_) <- ns_map
+                    , sz == length
+                    , sym == top_symbol ]
+
+
+----------------------------------------------------------------------------
+
+glr_parse :: [[UserDefTok]] -> GLRResult
+glr_parse toks
+ = case runST Map.empty [0..] (tp toks) of
+    (f,Left ts)   -> ParseError ts f
+                                                -- Error within sentence
+    (f,Right ss)  -> forestResult (length toks) f
+                                                -- Either good parse or EOF
+   where
+        tp tss = doActions [initTS 0]
+               $ zipWith (\i ts -> [(i, t) | t <- ts]) [0..]
+              $ [ [ HappyTok {-j-} t | (j,t) <- zip [0..] ts ] | ts <- tss ]
+                ++ [[HappyEOF]]
+
+---
+
+type PM a = ST Forest [Int] a
+type FStack = TStack ForestId
+
+
+---
+-- main function
+
+doActions :: [FStack] -> Tokens -> PM (Either Tokens [FStack])
+
+doActions ss []                 -- no more tokens (this is ok)
+ = return (Right ss)            -- return the stacks (may be empty)
+
+doActions stks (tok:toks)
+ = do
+        stkss <- sequence [ do
+                             stks' <- reduceAll [] tok_form stks
+                             shiftAll tok_form stks'
+                         | tok_form <- tok ]
+        let new_stks = merge $ concat stkss
+        (happyTrace (unlines $ ("Stacks after R*/S pass" ++ show tok)
+                                
+{-# LINE 195 "templates/GLR_Lib.hs" #-}
+        : map show new_stks) $ return ())
+        
+        case new_stks of            -- did this token kill stacks?
+          [] -> case toks of
+                  []  -> return $ Right []         -- ok if no more tokens
+                  _:_ -> return $ Left (tok:toks)  -- not ok if some input left
+          _  -> doActions new_stks toks
+
+reduceAll
+ :: [GSymbol] -> (Int, GSymbol) -> [FStack] -> PM [(FStack, Int)]
+reduceAll _ tok [] = return []
+reduceAll cyclic_names itok@(i,tok) (stk:stks)
+ = do
+     case action this_state tok of
+       Accept      -> reduceAll [] itok stks
+       Error       -> reduceAll [] itok stks
+       Shift st rs -> do { ss <- redAll rs ; return $ (stk,st) : ss }
+       Reduce rs   -> redAll rs
+ where
+  this_state = top stk
+  redAll rs
+   = do
+        let reds = [ (bf fids,stk',m)
+                   | (m,n,bf) <- rs
+                   , not (n == 0 && m `elem` cyclic_names)  -- remove done ones
+                   , (fids,stk') <- pop n stk
+                   ]
+                   -- WARNING: incomplete if more than one Empty in a prod(!)
+                   -- WARNING: can avoid by splitting emps/non-emps
+        (happyTrace (unlines $ ("Packing reds = " ++ show (length reds))
+                            
+{-# LINE 224 "templates/GLR_Lib.hs" #-}
+        : map show reds) $ return ())
+        
+        stks' <- foldM (pack i) stks reds
+        let new_cyclic = [ m | (m,0,_) <- rs
+                             , (isTrue# (this_state ==#  goto this_state m))
+                             , m `notElem` cyclic_names ]
+        reduceAll (cyclic_names ++ new_cyclic) itok $ merge stks'
+
+shiftAll :: (Int, GSymbol) -> [(FStack, Int)] -> PM [FStack]
+shiftAll tok [] = return []
+shiftAll (j,tok) stks
+ = do
+        let end = j + 1
+        let key = end `seq` (j,end,tok)
+        newNode key
+        let mss = [ (stk, st)
+                  | ss@((_,st):_) <- groupBy (\a b -> snd a == snd b) stks
+                  , stk <- merge $ map fst ss ]
+        stks' <- sequence [ do { nid <- getID ; return (push key st nid stk) }
+                          | (stk,(I# (st))) <- mss ]
+        return stks'
+
+
+pack
+ :: Int -> [FStack] -> (Branch, FStack, GSymbol) -> PM [FStack]
+
+pack e_i stks (fids,stk,m)
+ | (isTrue# (st <#  0#))
+    = return stks
+ | otherwise
+    = do
+       let s_i = endpoint stk
+       let key = (s_i,e_i,m)
+       (happyTrace ( unlines
+                   
+{-# LINE 257 "templates/GLR_Lib.hs" #-}
+       $ ("Pack at " ++ show key ++ " " ++ show fids)
+                   
+{-# LINE 257 "templates/GLR_Lib.hs" #-}
+       : ("**" ++ show stk)
+                   
+{-# LINE 257 "templates/GLR_Lib.hs" #-}
+       : map show stks) $ return ())
+
+       
+
+
+       duplicate <- addBranch key fids
+
+       let stack_matches = [ s | s <- stks
+                                , (isTrue# (top s ==#  st))
+                               , let (k,s') = case ts_tail s of x:_ -> x
+                                , stk == s'
+                                , k == key
+                                ]  -- look for first obvious packing site
+       let appears_in = not $ null stack_matches
+
+       (happyTrace ( unlines
+                   
+{-# LINE 272 "templates/GLR_Lib.hs" #-}
+       $ ("Stack Matches: " ++ show (length stack_matches))
+                   
+{-# LINE 272 "templates/GLR_Lib.hs" #-}
+       : map show stack_matches) $ return ())
+       
+
+       (happyTrace ( if not (duplicate && appears_in) then "" else
+                     
+{-# LINE 275 "templates/GLR_Lib.hs" #-}
+       unlines
+                   
+{-# LINE 275 "templates/GLR_Lib.hs" #-}
+       $ ("DROP:" ++ show ((I# (st)),key) ++ " -- " ++ show stk)
+                   
+{-# LINE 275 "templates/GLR_Lib.hs" #-}
+       : "*****"
+                   
+{-# LINE 275 "templates/GLR_Lib.hs" #-}
+       : map show stks) $ return ())
+
+       
+
+
+
+       if duplicate && appears_in
+        then return stks       -- because already there
+        else do
+              nid <- getID
+              case stack_matches of
+                []  -> return $ insertStack (push key st nid stk) stks
+                                -- No prior stacks
+
+                s:_ -> return $ insertStack (push key st nid stk) (delete s stks)
+                                -- pack into an existing stack
+    where
+       st = goto (top stk) m
+
+
+
+---
+-- record an entry
+--  - expected: "i" will contain a token
+
+newNode :: ForestId -> PM ()
+newNode i
+ = chgS $ \f -> ((), Map.insert i [] f)
+
+---
+-- add a new branch
+--  - due to packing, we check to see if a branch is already there
+--  - return True if the branch is already there
+
+addBranch :: ForestId -> Branch -> PM Bool
+addBranch i b
+ = do
+        f <- useS id
+        case Map.lookup i f of
+         Nothing               -> chgS $ \f -> (False, Map.insert i [b] f)
+         Just bs | b `elem` bs -> return True
+                 | otherwise   -> chgS $ \f -> (True,  Map.insert i (b:bs) f)
+
+---
+-- only for use with nodes that exist
+
+getBranches ::  ForestId -> PM [Branch]
+getBranches i
+ = useS $ \s -> Map.findWithDefault no_such_node i s
+   where
+        no_such_node = error $ "No such node in Forest: " ++ show i
+
+
+
+
+
+-----------------------------------------------------------------------------
+-- Auxiliary functions
+
+(<>) x y = (x,y)  -- syntactic sugar
+
+
+
+-- Tomita stack
+--  - basic idea taken from Peter Ljungloef's Licentiate thesis
+
+
+data TStack a
+ = TS { top      :: Int#            -- state
+      , ts_id    :: Int#            -- ID
+      , stoup    :: !(Maybe a)          -- temp holding place, for left rec.
+      , ts_tail  :: ![(a,TStack a)]     -- [(element on arc , child)]
+      }
+
+instance Show a => Show (TStack a) where
+  show ts
+   = "St" ++ show ((I# (top ts)))
+
+     ++ "\n" ++ render (spp $ ts_tail ts)
+     where
+        spp ss = nest 2
+                $ vcat [ vcat [text (show (v,(I# (top s)))), spp (ts_tail s)]
+                       | (v,s) <- ss ]
+
+
+
+---
+-- id uniquely identifies a stack
+
+instance Eq (TStack a) where
+      s1 == s2 = (isTrue# (ts_id s1 ==#  ts_id s2))
+
+--instance Ord (TStack a) where
+--      s1 `compare` s2 = (I# (ts_id s1)) `compare` (I# (ts_id s2))
+
+---
+-- Nothing special done for insertion
+-- - NB merging done at strategic points
+
+insertStack :: TStack a -> [TStack a] -> [TStack a]
+insertStack = (:)
+
+---
+
+initTS :: Int -> TStack a
+initTS (I# (id)) = TS 0# id Nothing []
+
+---
+
+push :: ForestId -> Int# -> Int -> TStack ForestId -> TStack ForestId
+push x@(s_i,e_i,m) st (I# (id)) stk
+ = TS st id stoup [(x,stk)]
+   where
+        -- only fill stoup for cyclic states that don't consume input
+       stoup | s_i == e_i && (isTrue# (st ==#  goto st m)) = Just x
+             | otherwise                        = Nothing
+
+---
+
+pop :: Int -> TStack a -> [([a],TStack a)]
+pop 0 ts = [([],ts)]
+pop 1 st@TS{stoup=Just x}
+ = pop 1 st{stoup=Nothing} ++ [ ([x],st) ]
+pop n ts = [ (xs ++ [x] , stk')
+            | (x,stk) <- ts_tail ts
+            , (xs,stk') <- pop (n-1) stk ]
+
+---
+
+popF :: TStack a -> TStack a
+popF ts = case ts_tail ts of (_,c):_ -> c
+
+---
+
+endpoint stk
+ = case ts_tail stk of
+     [] -> 0
+     ((_,e_i,_),_):_ -> e_i
+
+
+
+---
+
+merge :: (Eq a, Show a) => [TStack a] -> [TStack a]
+merge stks
+ = [ TS st id ss (nub ch)
+   | (I# (st)) <- nub (map (\s -> (I# (top s))) stks)
+   , let ch  = concat  [ x | TS st2 _ _ x <- stks, (isTrue# (st ==# st2)) ]
+         ss  = mkss    [ s | TS st2 _ s _ <- stks, (isTrue# (st ==# st2)) ]
+         (! (I# (id))) = head [ (I# (i)) | TS st2 i _ _ <- stks, (isTrue# (st ==# st2)) ]
+          -- reuse of id is ok, since merge discards old stacks
+   ]
+   where
+        mkss s = case nub [ x | Just x <- s ] of
+                   []  -> Nothing
+                   [x] -> Just x
+                   xs  -> error $ unlines $ ("Stoup merge: " ++ show xs)
+                                           : map show stks
+
+
+
+----------------------------------------------------------------------------
+-- Monad
+-- TODO (pcc): combine the s/i, or use the modern libraries - might be faster?
+--             but some other things are much, much, much more expensive!
+
+data ST s i a = MkST (s -> i -> (a,s,i))
+
+instance Functor (ST s i) where
+ fmap f (MkST sf)
+  = MkST $ \s i -> case sf s i of (a,s',i') -> (f a,s',i')
+
+instance Applicative (ST s i) where
+ pure a = MkST $ \s i -> (a,s,i)
+ (<*>) = ap
+
+instance Monad (ST s i) where
+ return = pure
+ MkST sf >>= k
+  = MkST $ \s i ->
+        case sf s i of
+         (a,s',i') -> let (MkST sf') = k a in  sf' s' i'
+
+runST :: s -> i -> ST s i a -> (s,a)
+runST s i (MkST sf) = case sf s i of
+                           (a,s,_) -> (s,a)
+
+chgS :: (s -> (a,s)) -> ST s i a
+chgS sf = MkST $ \s i -> let (a,s') = sf s in (a,s',i)
+
+useS :: (s -> b) -> ST s i b
+useS fn = MkST $ \s i -> (fn s,s,i)
+
+getID :: ST s [Int] Int
+getID = MkST $ \s (i:is) -> (i,s,is)
+
+
diff --git a/data/HappyTemplate b/data/HappyTemplate
new file mode 100644
index 0000000..5b9e7d1
--- /dev/null
+++ b/data/HappyTemplate
@@ -0,0 +1,449 @@
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+{-# LINE 1 "<built-in>" #-}
+{-# LINE 15 "<built-in>" #-}
+{-# LINE 1 "/Users/jyothsnasrinivas/.stack/programs/x86_64-osx/ghc-8.2.2/lib/ghc-8.2.2/include/ghcversion.h" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{-# LINE 16 "<built-in>" #-}
+{-# LINE 1 "/var/folders/m6/wm286css74x1_rxyssdx0b1m0000gn/T/ghc9222_0/ghc_2.h" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{-# LINE 17 "<built-in>" #-}
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+-- Id: GenericTemplate.hs,v 1.26 2005/01/14 14:47:22 simonmar Exp 
+
+
+
+
+
+
+
+
+
+
+{-# LINE 43 "templates/GenericTemplate.hs" #-}
+
+data Happy_IntList = HappyCons Int Happy_IntList
+
+
+
+
+
+
+
+
+{-# LINE 65 "templates/GenericTemplate.hs" #-}
+
+
+{-# LINE 75 "templates/GenericTemplate.hs" #-}
+
+
+
+
+
+
+
+
+
+
+infixr 9 `HappyStk`
+data HappyStk a = HappyStk a (HappyStk a)
+
+-----------------------------------------------------------------------------
+-- starting the parse
+
+happyParse start_state = happyNewToken start_state notHappyAtAll notHappyAtAll
+
+-----------------------------------------------------------------------------
+-- Accepting the parse
+
+-- If the current token is (1), it means we've just accepted a partial
+-- parse (a %partial parser).  We must ignore the saved token on the top of
+-- the stack in this case.
+happyAccept (1) tk st sts (_ `HappyStk` ans `HappyStk` _) =
+        happyReturn1 ans
+happyAccept j tk st sts (HappyStk ans _) = 
+         (happyReturn1 ans)
+
+-----------------------------------------------------------------------------
+-- Arrays only: do the next action
+
+
+{-# LINE 137 "templates/GenericTemplate.hs" #-}
+
+
+{-# LINE 147 "templates/GenericTemplate.hs" #-}
+indexShortOffAddr arr off = arr Happy_Data_Array.! off
+
+
+{-# INLINE happyLt #-}
+happyLt x y = (x < y)
+
+
+
+
+
+
+readArrayBit arr bit =
+    Bits.testBit (indexShortOffAddr arr (bit `div` 16)) (bit `mod` 16)
+
+
+
+
+
+
+-----------------------------------------------------------------------------
+-- HappyState data type (not arrays)
+
+
+
+newtype HappyState b c = HappyState
+        (Int ->                    -- token number
+         Int ->                    -- token number (yes, again)
+         b ->                           -- token semantic value
+         HappyState b c ->              -- current state
+         [HappyState b c] ->            -- state stack
+         c)
+
+
+
+-----------------------------------------------------------------------------
+-- Shifting a token
+
+happyShift new_state (1) tk st sts stk@(x `HappyStk` _) =
+     let i = (case x of { HappyErrorToken (i) -> i }) in
+--     trace "shifting the error token" $
+     new_state i i tk (HappyState (new_state)) ((st):(sts)) (stk)
+
+happyShift new_state i tk st sts stk =
+     happyNewToken new_state ((st):(sts)) ((HappyTerminal (tk))`HappyStk`stk)
+
+-- happyReduce is specialised for the common cases.
+
+happySpecReduce_0 i fn (1) tk st sts stk
+     = happyFail [] (1) tk st sts stk
+happySpecReduce_0 nt fn j tk st@((HappyState (action))) sts stk
+     = action nt j tk st ((st):(sts)) (fn `HappyStk` stk)
+
+happySpecReduce_1 i fn (1) tk st sts stk
+     = happyFail [] (1) tk st sts stk
+happySpecReduce_1 nt fn j tk _ sts@(((st@(HappyState (action))):(_))) (v1`HappyStk`stk')
+     = let r = fn v1 in
+       happySeq r (action nt j tk st sts (r `HappyStk` stk'))
+
+happySpecReduce_2 i fn (1) tk st sts stk
+     = happyFail [] (1) tk st sts stk
+happySpecReduce_2 nt fn j tk _ ((_):(sts@(((st@(HappyState (action))):(_))))) (v1`HappyStk`v2`HappyStk`stk')
+     = let r = fn v1 v2 in
+       happySeq r (action nt j tk st sts (r `HappyStk` stk'))
+
+happySpecReduce_3 i fn (1) tk st sts stk
+     = happyFail [] (1) tk st sts stk
+happySpecReduce_3 nt fn j tk _ ((_):(((_):(sts@(((st@(HappyState (action))):(_))))))) (v1`HappyStk`v2`HappyStk`v3`HappyStk`stk')
+     = let r = fn v1 v2 v3 in
+       happySeq r (action nt j tk st sts (r `HappyStk` stk'))
+
+happyReduce k i fn (1) tk st sts stk
+     = happyFail [] (1) tk st sts stk
+happyReduce k nt fn j tk st sts stk
+     = case happyDrop (k - ((1) :: Int)) sts of
+         sts1@(((st1@(HappyState (action))):(_))) ->
+                let r = fn stk in  -- it doesn't hurt to always seq here...
+                happyDoSeq r (action nt j tk st1 sts1 r)
+
+happyMonadReduce k nt fn (1) tk st sts stk
+     = happyFail [] (1) tk st sts stk
+happyMonadReduce k nt fn j tk st sts stk =
+      case happyDrop k ((st):(sts)) of
+        sts1@(((st1@(HappyState (action))):(_))) ->
+          let drop_stk = happyDropStk k stk in
+          happyThen1 (fn stk tk) (\r -> action nt j tk st1 sts1 (r `HappyStk` drop_stk))
+
+happyMonad2Reduce k nt fn (1) tk st sts stk
+     = happyFail [] (1) tk st sts stk
+happyMonad2Reduce k nt fn j tk st sts stk =
+      case happyDrop k ((st):(sts)) of
+        sts1@(((st1@(HappyState (action))):(_))) ->
+         let drop_stk = happyDropStk k stk
+
+
+
+
+
+             _ = nt :: Int
+             new_state = action
+
+          in
+          happyThen1 (fn stk tk) (\r -> happyNewToken new_state sts1 (r `HappyStk` drop_stk))
+
+happyDrop (0) l = l
+happyDrop n ((_):(t)) = happyDrop (n - ((1) :: Int)) t
+
+happyDropStk (0) l = l
+happyDropStk n (x `HappyStk` xs) = happyDropStk (n - ((1)::Int)) xs
+
+-----------------------------------------------------------------------------
+-- Moving to a new state after a reduction
+
+
+
+
+
+
+
+
+
+happyGoto action j tk st = action j j tk (HappyState action)
+
+
+-----------------------------------------------------------------------------
+-- Error recovery ((1) is the error token)
+
+-- parse error if we are in recovery and we fail again
+happyFail explist (1) tk old_st _ stk@(x `HappyStk` _) =
+     let i = (case x of { HappyErrorToken (i) -> i }) in
+--      trace "failing" $ 
+        happyError_ explist i tk
+
+{-  We don't need state discarding for our restricted implementation of
+    "error".  In fact, it can cause some bogus parses, so I've disabled it
+    for now --SDM
+
+-- discard a state
+happyFail  (1) tk old_st (((HappyState (action))):(sts)) 
+                                                (saved_tok `HappyStk` _ `HappyStk` stk) =
+--      trace ("discarding state, depth " ++ show (length stk))  $
+        action (1) (1) tk (HappyState (action)) sts ((saved_tok`HappyStk`stk))
+-}
+
+-- Enter error recovery: generate an error token,
+--                       save the old token and carry on.
+happyFail explist i tk (HappyState (action)) sts stk =
+--      trace "entering error recovery" $
+        action (1) (1) tk (HappyState (action)) sts ( (HappyErrorToken (i)) `HappyStk` stk)
+
+-- Internal happy errors:
+
+notHappyAtAll :: a
+notHappyAtAll = error "Internal Happy error\n"
+
+-----------------------------------------------------------------------------
+-- Hack to get the typechecker to accept our action functions
+
+
+
+
+
+
+
+-----------------------------------------------------------------------------
+-- Seq-ing.  If the --strict flag is given, then Happy emits 
+--      happySeq = happyDoSeq
+-- otherwise it emits
+--      happySeq = happyDontSeq
+
+happyDoSeq, happyDontSeq :: a -> b -> b
+happyDoSeq   a b = a `seq` b
+happyDontSeq a b = b
+
+-----------------------------------------------------------------------------
+-- Don't inline any functions from the template.  GHC has a nasty habit
+-- of deciding to inline happyGoto everywhere, which increases the size of
+-- the generated parser quite a bit.
+
+
+
+
+
+
+
+
+
+{-# NOINLINE happyShift #-}
+{-# NOINLINE happySpecReduce_0 #-}
+{-# NOINLINE happySpecReduce_1 #-}
+{-# NOINLINE happySpecReduce_2 #-}
+{-# NOINLINE happySpecReduce_3 #-}
+{-# NOINLINE happyReduce #-}
+{-# NOINLINE happyMonadReduce #-}
+{-# NOINLINE happyGoto #-}
+{-# NOINLINE happyFail #-}
+
+-- end of Happy Template.
+
diff --git a/data/HappyTemplate-arrays b/data/HappyTemplate-arrays
new file mode 100644
index 0000000..fdd4404
--- /dev/null
+++ b/data/HappyTemplate-arrays
@@ -0,0 +1,468 @@
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+{-# LINE 1 "<built-in>" #-}
+{-# LINE 16 "<built-in>" #-}
+{-# LINE 1 "/Users/jyothsnasrinivas/.stack/programs/x86_64-osx/ghc-8.2.2/lib/ghc-8.2.2/include/ghcversion.h" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{-# LINE 17 "<built-in>" #-}
+{-# LINE 1 "/var/folders/m6/wm286css74x1_rxyssdx0b1m0000gn/T/ghc9231_0/ghc_2.h" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{-# LINE 18 "<built-in>" #-}
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+-- Id: GenericTemplate.hs,v 1.26 2005/01/14 14:47:22 simonmar Exp 
+
+
+
+
+
+
+
+
+
+
+{-# LINE 43 "templates/GenericTemplate.hs" #-}
+
+data Happy_IntList = HappyCons Int Happy_IntList
+
+
+
+
+
+
+
+
+{-# LINE 65 "templates/GenericTemplate.hs" #-}
+
+
+{-# LINE 75 "templates/GenericTemplate.hs" #-}
+
+
+
+
+
+
+
+
+
+
+infixr 9 `HappyStk`
+data HappyStk a = HappyStk a (HappyStk a)
+
+-----------------------------------------------------------------------------
+-- starting the parse
+
+happyParse start_state = happyNewToken start_state notHappyAtAll notHappyAtAll
+
+-----------------------------------------------------------------------------
+-- Accepting the parse
+
+-- If the current token is (0), it means we've just accepted a partial
+-- parse (a %partial parser).  We must ignore the saved token on the top of
+-- the stack in this case.
+happyAccept (0) tk st sts (_ `HappyStk` ans `HappyStk` _) =
+        happyReturn1 ans
+happyAccept j tk st sts (HappyStk ans _) = 
+         (happyReturn1 ans)
+
+-----------------------------------------------------------------------------
+-- Arrays only: do the next action
+
+
+
+happyDoAction i tk st
+        = {- nothing -}
+          
+
+          case action of
+                (0)           -> {- nothing -}
+                                     happyFail (happyExpListPerState ((st) :: Int)) i tk st
+                (-1)          -> {- nothing -}
+                                     happyAccept i tk st
+                n | (n < ((0) :: Int)) -> {- nothing -}
+                                                   
+                                                   (happyReduceArr Happy_Data_Array.! rule) i tk st
+                                                   where rule = ((negate ((n + ((1) :: Int)))))
+                n                 -> {- nothing -}
+                                     
+
+                                     happyShift new_state i tk st
+                                     where new_state = (n - ((1) :: Int))
+   where off    = happyAdjustOffset (indexShortOffAddr happyActOffsets st)
+         off_i  = (off +  i)
+         check  = if (off_i >= ((0) :: Int))
+                  then (indexShortOffAddr happyCheck off_i ==  i)
+                  else False
+         action
+          | check     = indexShortOffAddr happyTable off_i
+          | otherwise = indexShortOffAddr happyDefActions st
+
+
+
+
+{-# LINE 147 "templates/GenericTemplate.hs" #-}
+indexShortOffAddr arr off = arr Happy_Data_Array.! off
+
+
+{-# INLINE happyLt #-}
+happyLt x y = (x < y)
+
+
+
+
+
+
+readArrayBit arr bit =
+    Bits.testBit (indexShortOffAddr arr (bit `div` 16)) (bit `mod` 16)
+
+
+
+
+
+
+-----------------------------------------------------------------------------
+-- HappyState data type (not arrays)
+
+
+{-# LINE 180 "templates/GenericTemplate.hs" #-}
+
+-----------------------------------------------------------------------------
+-- Shifting a token
+
+happyShift new_state (0) tk st sts stk@(x `HappyStk` _) =
+     let i = (case x of { HappyErrorToken (i) -> i }) in
+--     trace "shifting the error token" $
+     happyDoAction i tk new_state (HappyCons (st) (sts)) (stk)
+
+happyShift new_state i tk st sts stk =
+     happyNewToken new_state (HappyCons (st) (sts)) ((HappyTerminal (tk))`HappyStk`stk)
+
+-- happyReduce is specialised for the common cases.
+
+happySpecReduce_0 i fn (0) tk st sts stk
+     = happyFail [] (0) tk st sts stk
+happySpecReduce_0 nt fn j tk st@((action)) sts stk
+     = happyGoto nt j tk st (HappyCons (st) (sts)) (fn `HappyStk` stk)
+
+happySpecReduce_1 i fn (0) tk st sts stk
+     = happyFail [] (0) tk st sts stk
+happySpecReduce_1 nt fn j tk _ sts@((HappyCons (st@(action)) (_))) (v1`HappyStk`stk')
+     = let r = fn v1 in
+       happySeq r (happyGoto nt j tk st sts (r `HappyStk` stk'))
+
+happySpecReduce_2 i fn (0) tk st sts stk
+     = happyFail [] (0) tk st sts stk
+happySpecReduce_2 nt fn j tk _ (HappyCons (_) (sts@((HappyCons (st@(action)) (_))))) (v1`HappyStk`v2`HappyStk`stk')
+     = let r = fn v1 v2 in
+       happySeq r (happyGoto nt j tk st sts (r `HappyStk` stk'))
+
+happySpecReduce_3 i fn (0) tk st sts stk
+     = happyFail [] (0) tk st sts stk
+happySpecReduce_3 nt fn j tk _ (HappyCons (_) ((HappyCons (_) (sts@((HappyCons (st@(action)) (_))))))) (v1`HappyStk`v2`HappyStk`v3`HappyStk`stk')
+     = let r = fn v1 v2 v3 in
+       happySeq r (happyGoto nt j tk st sts (r `HappyStk` stk'))
+
+happyReduce k i fn (0) tk st sts stk
+     = happyFail [] (0) tk st sts stk
+happyReduce k nt fn j tk st sts stk
+     = case happyDrop (k - ((1) :: Int)) sts of
+         sts1@((HappyCons (st1@(action)) (_))) ->
+                let r = fn stk in  -- it doesn't hurt to always seq here...
+                happyDoSeq r (happyGoto nt j tk st1 sts1 r)
+
+happyMonadReduce k nt fn (0) tk st sts stk
+     = happyFail [] (0) tk st sts stk
+happyMonadReduce k nt fn j tk st sts stk =
+      case happyDrop k (HappyCons (st) (sts)) of
+        sts1@((HappyCons (st1@(action)) (_))) ->
+          let drop_stk = happyDropStk k stk in
+          happyThen1 (fn stk tk) (\r -> happyGoto nt j tk st1 sts1 (r `HappyStk` drop_stk))
+
+happyMonad2Reduce k nt fn (0) tk st sts stk
+     = happyFail [] (0) tk st sts stk
+happyMonad2Reduce k nt fn j tk st sts stk =
+      case happyDrop k (HappyCons (st) (sts)) of
+        sts1@((HappyCons (st1@(action)) (_))) ->
+         let drop_stk = happyDropStk k stk
+
+             off = happyAdjustOffset (indexShortOffAddr happyGotoOffsets st1)
+             off_i = (off +  nt)
+             new_state = indexShortOffAddr happyTable off_i
+
+
+
+
+          in
+          happyThen1 (fn stk tk) (\r -> happyNewToken new_state sts1 (r `HappyStk` drop_stk))
+
+happyDrop (0) l = l
+happyDrop n (HappyCons (_) (t)) = happyDrop (n - ((1) :: Int)) t
+
+happyDropStk (0) l = l
+happyDropStk n (x `HappyStk` xs) = happyDropStk (n - ((1)::Int)) xs
+
+-----------------------------------------------------------------------------
+-- Moving to a new state after a reduction
+
+
+happyGoto nt j tk st = 
+   {- nothing -}
+   happyDoAction j tk new_state
+   where off = happyAdjustOffset (indexShortOffAddr happyGotoOffsets st)
+         off_i = (off +  nt)
+         new_state = indexShortOffAddr happyTable off_i
+
+
+
+
+-----------------------------------------------------------------------------
+-- Error recovery ((0) is the error token)
+
+-- parse error if we are in recovery and we fail again
+happyFail explist (0) tk old_st _ stk@(x `HappyStk` _) =
+     let i = (case x of { HappyErrorToken (i) -> i }) in
+--      trace "failing" $ 
+        happyError_ explist i tk
+
+{-  We don't need state discarding for our restricted implementation of
+    "error".  In fact, it can cause some bogus parses, so I've disabled it
+    for now --SDM
+
+-- discard a state
+happyFail  (0) tk old_st (HappyCons ((action)) (sts)) 
+                                                (saved_tok `HappyStk` _ `HappyStk` stk) =
+--      trace ("discarding state, depth " ++ show (length stk))  $
+        happyDoAction (0) tk action sts ((saved_tok`HappyStk`stk))
+-}
+
+-- Enter error recovery: generate an error token,
+--                       save the old token and carry on.
+happyFail explist i tk (action) sts stk =
+--      trace "entering error recovery" $
+        happyDoAction (0) tk action sts ( (HappyErrorToken (i)) `HappyStk` stk)
+
+-- Internal happy errors:
+
+notHappyAtAll :: a
+notHappyAtAll = error "Internal Happy error\n"
+
+-----------------------------------------------------------------------------
+-- Hack to get the typechecker to accept our action functions
+
+
+
+
+
+
+
+-----------------------------------------------------------------------------
+-- Seq-ing.  If the --strict flag is given, then Happy emits 
+--      happySeq = happyDoSeq
+-- otherwise it emits
+--      happySeq = happyDontSeq
+
+happyDoSeq, happyDontSeq :: a -> b -> b
+happyDoSeq   a b = a `seq` b
+happyDontSeq a b = b
+
+-----------------------------------------------------------------------------
+-- Don't inline any functions from the template.  GHC has a nasty habit
+-- of deciding to inline happyGoto everywhere, which increases the size of
+-- the generated parser quite a bit.
+
+
+{-# NOINLINE happyDoAction #-}
+{-# NOINLINE happyTable #-}
+{-# NOINLINE happyCheck #-}
+{-# NOINLINE happyActOffsets #-}
+{-# NOINLINE happyGotoOffsets #-}
+{-# NOINLINE happyDefActions #-}
+
+{-# NOINLINE happyShift #-}
+{-# NOINLINE happySpecReduce_0 #-}
+{-# NOINLINE happySpecReduce_1 #-}
+{-# NOINLINE happySpecReduce_2 #-}
+{-# NOINLINE happySpecReduce_3 #-}
+{-# NOINLINE happyReduce #-}
+{-# NOINLINE happyMonadReduce #-}
+{-# NOINLINE happyGoto #-}
+{-# NOINLINE happyFail #-}
+
+-- end of Happy Template.
+
diff --git a/data/HappyTemplate-arrays-coerce b/data/HappyTemplate-arrays-coerce
new file mode 100644
index 0000000..d225738
--- /dev/null
+++ b/data/HappyTemplate-arrays-coerce
@@ -0,0 +1,489 @@
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+{-# LINE 1 "<built-in>" #-}
+{-# LINE 18 "<built-in>" #-}
+{-# LINE 1 "/Users/jyothsnasrinivas/.stack/programs/x86_64-osx/ghc-8.2.2/lib/ghc-8.2.2/include/ghcversion.h" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{-# LINE 19 "<built-in>" #-}
+{-# LINE 1 "/var/folders/m6/wm286css74x1_rxyssdx0b1m0000gn/T/ghc9237_0/ghc_2.h" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{-# LINE 20 "<built-in>" #-}
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+-- Id: GenericTemplate.hs,v 1.26 2005/01/14 14:47:22 simonmar Exp 
+
+
+
+
+
+
+
+
+
+
+
+
+
+-- Do not remove this comment. Required to fix CPP parsing when using GCC and a clang-compiled alex.
+#if __GLASGOW_HASKELL__ > 706
+#define LT(n,m) ((Happy_GHC_Exts.tagToEnum# (n Happy_GHC_Exts.<# m)) :: Bool)
+#define GTE(n,m) ((Happy_GHC_Exts.tagToEnum# (n Happy_GHC_Exts.>=# m)) :: Bool)
+#define EQ(n,m) ((Happy_GHC_Exts.tagToEnum# (n Happy_GHC_Exts.==# m)) :: Bool)
+#else
+#define LT(n,m) (n Happy_GHC_Exts.<# m)
+#define GTE(n,m) (n Happy_GHC_Exts.>=# m)
+#define EQ(n,m) (n Happy_GHC_Exts.==# m)
+#endif
+
+{-# LINE 43 "templates/GenericTemplate.hs" #-}
+
+data Happy_IntList = HappyCons Happy_GHC_Exts.Int# Happy_IntList
+
+
+
+
+
+
+
+
+{-# LINE 65 "templates/GenericTemplate.hs" #-}
+
+
+{-# LINE 75 "templates/GenericTemplate.hs" #-}
+
+
+
+
+
+
+
+
+
+
+infixr 9 `HappyStk`
+data HappyStk a = HappyStk a (HappyStk a)
+
+-----------------------------------------------------------------------------
+-- starting the parse
+
+happyParse start_state = happyNewToken start_state notHappyAtAll notHappyAtAll
+
+-----------------------------------------------------------------------------
+-- Accepting the parse
+
+-- If the current token is 0#, it means we've just accepted a partial
+-- parse (a %partial parser).  We must ignore the saved token on the top of
+-- the stack in this case.
+happyAccept 0# tk st sts (_ `HappyStk` ans `HappyStk` _) =
+        happyReturn1 ans
+happyAccept j tk st sts (HappyStk ans _) = 
+        (happyTcHack j (happyTcHack st)) (happyReturn1 ans)
+
+-----------------------------------------------------------------------------
+-- Arrays only: do the next action
+
+
+
+happyDoAction i tk st
+        = {- nothing -}
+          
+
+          case action of
+                0#           -> {- nothing -}
+                                     happyFail (happyExpListPerState ((Happy_GHC_Exts.I# (st)) :: Int)) i tk st
+                -1#          -> {- nothing -}
+                                     happyAccept i tk st
+                n | LT(n,(0# :: Happy_GHC_Exts.Int#)) -> {- nothing -}
+                                                   
+                                                   (happyReduceArr Happy_Data_Array.! rule) i tk st
+                                                   where rule = (Happy_GHC_Exts.I# ((Happy_GHC_Exts.negateInt# ((n Happy_GHC_Exts.+# (1# :: Happy_GHC_Exts.Int#))))))
+                n                 -> {- nothing -}
+                                     
+
+                                     happyShift new_state i tk st
+                                     where new_state = (n Happy_GHC_Exts.-# (1# :: Happy_GHC_Exts.Int#))
+   where off    = happyAdjustOffset (indexShortOffAddr happyActOffsets st)
+         off_i  = (off Happy_GHC_Exts.+#  i)
+         check  = if GTE(off_i,(0# :: Happy_GHC_Exts.Int#))
+                  then EQ(indexShortOffAddr happyCheck off_i, i)
+                  else False
+         action
+          | check     = indexShortOffAddr happyTable off_i
+          | otherwise = indexShortOffAddr happyDefActions st
+
+
+
+
+indexShortOffAddr (HappyA# arr) off =
+        Happy_GHC_Exts.narrow16Int# i
+  where
+        i = Happy_GHC_Exts.word2Int# (Happy_GHC_Exts.or# (Happy_GHC_Exts.uncheckedShiftL# high 8#) low)
+        high = Happy_GHC_Exts.int2Word# (Happy_GHC_Exts.ord# (Happy_GHC_Exts.indexCharOffAddr# arr (off' Happy_GHC_Exts.+# 1#)))
+        low  = Happy_GHC_Exts.int2Word# (Happy_GHC_Exts.ord# (Happy_GHC_Exts.indexCharOffAddr# arr off'))
+        off' = off Happy_GHC_Exts.*# 2#
+
+
+
+
+{-# INLINE happyLt #-}
+happyLt x y = LT(x,y)
+
+
+readArrayBit arr bit =
+    Bits.testBit (Happy_GHC_Exts.I# (indexShortOffAddr arr ((unbox_int bit) `Happy_GHC_Exts.iShiftRA#` 4#))) (bit `mod` 16)
+  where unbox_int (Happy_GHC_Exts.I# x) = x
+
+
+
+
+
+
+data HappyAddr = HappyA# Happy_GHC_Exts.Addr#
+
+
+-----------------------------------------------------------------------------
+-- HappyState data type (not arrays)
+
+
+{-# LINE 180 "templates/GenericTemplate.hs" #-}
+
+-----------------------------------------------------------------------------
+-- Shifting a token
+
+happyShift new_state 0# tk st sts stk@(x `HappyStk` _) =
+     let i = (case Happy_GHC_Exts.unsafeCoerce# x of { (Happy_GHC_Exts.I# (i)) -> i }) in
+--     trace "shifting the error token" $
+     happyDoAction i tk new_state (HappyCons (st) (sts)) (stk)
+
+happyShift new_state i tk st sts stk =
+     happyNewToken new_state (HappyCons (st) (sts)) ((happyInTok (tk))`HappyStk`stk)
+
+-- happyReduce is specialised for the common cases.
+
+happySpecReduce_0 i fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happySpecReduce_0 nt fn j tk st@((action)) sts stk
+     = happyGoto nt j tk st (HappyCons (st) (sts)) (fn `HappyStk` stk)
+
+happySpecReduce_1 i fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happySpecReduce_1 nt fn j tk _ sts@((HappyCons (st@(action)) (_))) (v1`HappyStk`stk')
+     = let r = fn v1 in
+       happySeq r (happyGoto nt j tk st sts (r `HappyStk` stk'))
+
+happySpecReduce_2 i fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happySpecReduce_2 nt fn j tk _ (HappyCons (_) (sts@((HappyCons (st@(action)) (_))))) (v1`HappyStk`v2`HappyStk`stk')
+     = let r = fn v1 v2 in
+       happySeq r (happyGoto nt j tk st sts (r `HappyStk` stk'))
+
+happySpecReduce_3 i fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happySpecReduce_3 nt fn j tk _ (HappyCons (_) ((HappyCons (_) (sts@((HappyCons (st@(action)) (_))))))) (v1`HappyStk`v2`HappyStk`v3`HappyStk`stk')
+     = let r = fn v1 v2 v3 in
+       happySeq r (happyGoto nt j tk st sts (r `HappyStk` stk'))
+
+happyReduce k i fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happyReduce k nt fn j tk st sts stk
+     = case happyDrop (k Happy_GHC_Exts.-# (1# :: Happy_GHC_Exts.Int#)) sts of
+         sts1@((HappyCons (st1@(action)) (_))) ->
+                let r = fn stk in  -- it doesn't hurt to always seq here...
+                happyDoSeq r (happyGoto nt j tk st1 sts1 r)
+
+happyMonadReduce k nt fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happyMonadReduce k nt fn j tk st sts stk =
+      case happyDrop k (HappyCons (st) (sts)) of
+        sts1@((HappyCons (st1@(action)) (_))) ->
+          let drop_stk = happyDropStk k stk in
+          happyThen1 (fn stk tk) (\r -> happyGoto nt j tk st1 sts1 (r `HappyStk` drop_stk))
+
+happyMonad2Reduce k nt fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happyMonad2Reduce k nt fn j tk st sts stk =
+      case happyDrop k (HappyCons (st) (sts)) of
+        sts1@((HappyCons (st1@(action)) (_))) ->
+         let drop_stk = happyDropStk k stk
+
+             off = happyAdjustOffset (indexShortOffAddr happyGotoOffsets st1)
+             off_i = (off Happy_GHC_Exts.+#  nt)
+             new_state = indexShortOffAddr happyTable off_i
+
+
+
+
+          in
+          happyThen1 (fn stk tk) (\r -> happyNewToken new_state sts1 (r `HappyStk` drop_stk))
+
+happyDrop 0# l = l
+happyDrop n (HappyCons (_) (t)) = happyDrop (n Happy_GHC_Exts.-# (1# :: Happy_GHC_Exts.Int#)) t
+
+happyDropStk 0# l = l
+happyDropStk n (x `HappyStk` xs) = happyDropStk (n Happy_GHC_Exts.-# (1#::Happy_GHC_Exts.Int#)) xs
+
+-----------------------------------------------------------------------------
+-- Moving to a new state after a reduction
+
+
+happyGoto nt j tk st = 
+   {- nothing -}
+   happyDoAction j tk new_state
+   where off = happyAdjustOffset (indexShortOffAddr happyGotoOffsets st)
+         off_i = (off Happy_GHC_Exts.+#  nt)
+         new_state = indexShortOffAddr happyTable off_i
+
+
+
+
+-----------------------------------------------------------------------------
+-- Error recovery (0# is the error token)
+
+-- parse error if we are in recovery and we fail again
+happyFail explist 0# tk old_st _ stk@(x `HappyStk` _) =
+     let i = (case Happy_GHC_Exts.unsafeCoerce# x of { (Happy_GHC_Exts.I# (i)) -> i }) in
+--      trace "failing" $ 
+        happyError_ explist i tk
+
+{-  We don't need state discarding for our restricted implementation of
+    "error".  In fact, it can cause some bogus parses, so I've disabled it
+    for now --SDM
+
+-- discard a state
+happyFail  0# tk old_st (HappyCons ((action)) (sts)) 
+                                                (saved_tok `HappyStk` _ `HappyStk` stk) =
+--      trace ("discarding state, depth " ++ show (length stk))  $
+        happyDoAction 0# tk action sts ((saved_tok`HappyStk`stk))
+-}
+
+-- Enter error recovery: generate an error token,
+--                       save the old token and carry on.
+happyFail explist i tk (action) sts stk =
+--      trace "entering error recovery" $
+        happyDoAction 0# tk action sts ( (Happy_GHC_Exts.unsafeCoerce# (Happy_GHC_Exts.I# (i))) `HappyStk` stk)
+
+-- Internal happy errors:
+
+notHappyAtAll :: a
+notHappyAtAll = error "Internal Happy error\n"
+
+-----------------------------------------------------------------------------
+-- Hack to get the typechecker to accept our action functions
+
+
+happyTcHack :: Happy_GHC_Exts.Int# -> a -> a
+happyTcHack x y = y
+{-# INLINE happyTcHack #-}
+
+
+-----------------------------------------------------------------------------
+-- Seq-ing.  If the --strict flag is given, then Happy emits 
+--      happySeq = happyDoSeq
+-- otherwise it emits
+--      happySeq = happyDontSeq
+
+happyDoSeq, happyDontSeq :: a -> b -> b
+happyDoSeq   a b = a `seq` b
+happyDontSeq a b = b
+
+-----------------------------------------------------------------------------
+-- Don't inline any functions from the template.  GHC has a nasty habit
+-- of deciding to inline happyGoto everywhere, which increases the size of
+-- the generated parser quite a bit.
+
+
+{-# NOINLINE happyDoAction #-}
+{-# NOINLINE happyTable #-}
+{-# NOINLINE happyCheck #-}
+{-# NOINLINE happyActOffsets #-}
+{-# NOINLINE happyGotoOffsets #-}
+{-# NOINLINE happyDefActions #-}
+
+{-# NOINLINE happyShift #-}
+{-# NOINLINE happySpecReduce_0 #-}
+{-# NOINLINE happySpecReduce_1 #-}
+{-# NOINLINE happySpecReduce_2 #-}
+{-# NOINLINE happySpecReduce_3 #-}
+{-# NOINLINE happyReduce #-}
+{-# NOINLINE happyMonadReduce #-}
+{-# NOINLINE happyGoto #-}
+{-# NOINLINE happyFail #-}
+
+-- end of Happy Template.
+
diff --git a/data/HappyTemplate-arrays-coerce-debug b/data/HappyTemplate-arrays-coerce-debug
new file mode 100644
index 0000000..b599b41
--- /dev/null
+++ b/data/HappyTemplate-arrays-coerce-debug
@@ -0,0 +1,504 @@
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+{-# LINE 1 "<built-in>" #-}
+{-# LINE 19 "<built-in>" #-}
+{-# LINE 1 "/Users/jyothsnasrinivas/.stack/programs/x86_64-osx/ghc-8.2.2/lib/ghc-8.2.2/include/ghcversion.h" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{-# LINE 20 "<built-in>" #-}
+{-# LINE 1 "/var/folders/m6/wm286css74x1_rxyssdx0b1m0000gn/T/ghc9246_0/ghc_2.h" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{-# LINE 21 "<built-in>" #-}
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+-- Id: GenericTemplate.hs,v 1.26 2005/01/14 14:47:22 simonmar Exp 
+
+
+
+
+
+
+
+
+
+
+
+
+
+-- Do not remove this comment. Required to fix CPP parsing when using GCC and a clang-compiled alex.
+#if __GLASGOW_HASKELL__ > 706
+#define LT(n,m) ((Happy_GHC_Exts.tagToEnum# (n Happy_GHC_Exts.<# m)) :: Bool)
+#define GTE(n,m) ((Happy_GHC_Exts.tagToEnum# (n Happy_GHC_Exts.>=# m)) :: Bool)
+#define EQ(n,m) ((Happy_GHC_Exts.tagToEnum# (n Happy_GHC_Exts.==# m)) :: Bool)
+#else
+#define LT(n,m) (n Happy_GHC_Exts.<# m)
+#define GTE(n,m) (n Happy_GHC_Exts.>=# m)
+#define EQ(n,m) (n Happy_GHC_Exts.==# m)
+#endif
+
+{-# LINE 43 "templates/GenericTemplate.hs" #-}
+
+data Happy_IntList = HappyCons Happy_GHC_Exts.Int# Happy_IntList
+
+
+
+
+
+
+
+
+{-# LINE 65 "templates/GenericTemplate.hs" #-}
+
+
+{-# LINE 75 "templates/GenericTemplate.hs" #-}
+
+
+
+happyTrace string expr = Happy_System_IO_Unsafe.unsafePerformIO $ do
+    Happy_System_IO.hPutStr Happy_System_IO.stderr string
+    return expr
+
+
+
+
+infixr 9 `HappyStk`
+data HappyStk a = HappyStk a (HappyStk a)
+
+-----------------------------------------------------------------------------
+-- starting the parse
+
+happyParse start_state = happyNewToken start_state notHappyAtAll notHappyAtAll
+
+-----------------------------------------------------------------------------
+-- Accepting the parse
+
+-- If the current token is 0#, it means we've just accepted a partial
+-- parse (a %partial parser).  We must ignore the saved token on the top of
+-- the stack in this case.
+happyAccept 0# tk st sts (_ `HappyStk` ans `HappyStk` _) =
+        happyReturn1 ans
+happyAccept j tk st sts (HappyStk ans _) = 
+        (happyTcHack j (happyTcHack st)) (happyReturn1 ans)
+
+-----------------------------------------------------------------------------
+-- Arrays only: do the next action
+
+
+
+happyDoAction i tk st
+        = (happyTrace ("state: " ++ show (Happy_GHC_Exts.I# (st)) ++ 
+                      
+{-# LINE 110 "templates/GenericTemplate.hs" #-}
+          ",\ttoken: " ++ show (Happy_GHC_Exts.I# (i)) ++
+                      
+{-# LINE 110 "templates/GenericTemplate.hs" #-}
+          ",\taction: ")) $
+          
+
+          case action of
+                0#           -> (happyTrace ("fail.\n")) $
+                                     happyFail (happyExpListPerState ((Happy_GHC_Exts.I# (st)) :: Int)) i tk st
+                -1#          -> (happyTrace ("accept.\n")) $
+                                     happyAccept i tk st
+                n | LT(n,(0# :: Happy_GHC_Exts.Int#)) -> (happyTrace ("reduce (rule " ++ show rule
+                                                               
+{-# LINE 118 "templates/GenericTemplate.hs" #-}
+                                                   ++ ")")) $
+                                                   
+                                                   (happyReduceArr Happy_Data_Array.! rule) i tk st
+                                                   where rule = (Happy_GHC_Exts.I# ((Happy_GHC_Exts.negateInt# ((n Happy_GHC_Exts.+# (1# :: Happy_GHC_Exts.Int#))))))
+                n                 -> (happyTrace ("shift, enter state "
+                                                 
+{-# LINE 122 "templates/GenericTemplate.hs" #-}
+                                     ++ show (Happy_GHC_Exts.I# (new_state))
+                                                 
+{-# LINE 122 "templates/GenericTemplate.hs" #-}
+                                     ++ "\n")) $
+                                     
+
+                                     happyShift new_state i tk st
+                                     where new_state = (n Happy_GHC_Exts.-# (1# :: Happy_GHC_Exts.Int#))
+   where off    = happyAdjustOffset (indexShortOffAddr happyActOffsets st)
+         off_i  = (off Happy_GHC_Exts.+#  i)
+         check  = if GTE(off_i,(0# :: Happy_GHC_Exts.Int#))
+                  then EQ(indexShortOffAddr happyCheck off_i, i)
+                  else False
+         action
+          | check     = indexShortOffAddr happyTable off_i
+          | otherwise = indexShortOffAddr happyDefActions st
+
+
+
+
+indexShortOffAddr (HappyA# arr) off =
+        Happy_GHC_Exts.narrow16Int# i
+  where
+        i = Happy_GHC_Exts.word2Int# (Happy_GHC_Exts.or# (Happy_GHC_Exts.uncheckedShiftL# high 8#) low)
+        high = Happy_GHC_Exts.int2Word# (Happy_GHC_Exts.ord# (Happy_GHC_Exts.indexCharOffAddr# arr (off' Happy_GHC_Exts.+# 1#)))
+        low  = Happy_GHC_Exts.int2Word# (Happy_GHC_Exts.ord# (Happy_GHC_Exts.indexCharOffAddr# arr off'))
+        off' = off Happy_GHC_Exts.*# 2#
+
+
+
+
+{-# INLINE happyLt #-}
+happyLt x y = LT(x,y)
+
+
+readArrayBit arr bit =
+    Bits.testBit (Happy_GHC_Exts.I# (indexShortOffAddr arr ((unbox_int bit) `Happy_GHC_Exts.iShiftRA#` 4#))) (bit `mod` 16)
+  where unbox_int (Happy_GHC_Exts.I# x) = x
+
+
+
+
+
+
+data HappyAddr = HappyA# Happy_GHC_Exts.Addr#
+
+
+-----------------------------------------------------------------------------
+-- HappyState data type (not arrays)
+
+
+{-# LINE 180 "templates/GenericTemplate.hs" #-}
+
+-----------------------------------------------------------------------------
+-- Shifting a token
+
+happyShift new_state 0# tk st sts stk@(x `HappyStk` _) =
+     let i = (case Happy_GHC_Exts.unsafeCoerce# x of { (Happy_GHC_Exts.I# (i)) -> i }) in
+--     trace "shifting the error token" $
+     happyDoAction i tk new_state (HappyCons (st) (sts)) (stk)
+
+happyShift new_state i tk st sts stk =
+     happyNewToken new_state (HappyCons (st) (sts)) ((happyInTok (tk))`HappyStk`stk)
+
+-- happyReduce is specialised for the common cases.
+
+happySpecReduce_0 i fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happySpecReduce_0 nt fn j tk st@((action)) sts stk
+     = happyGoto nt j tk st (HappyCons (st) (sts)) (fn `HappyStk` stk)
+
+happySpecReduce_1 i fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happySpecReduce_1 nt fn j tk _ sts@((HappyCons (st@(action)) (_))) (v1`HappyStk`stk')
+     = let r = fn v1 in
+       happySeq r (happyGoto nt j tk st sts (r `HappyStk` stk'))
+
+happySpecReduce_2 i fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happySpecReduce_2 nt fn j tk _ (HappyCons (_) (sts@((HappyCons (st@(action)) (_))))) (v1`HappyStk`v2`HappyStk`stk')
+     = let r = fn v1 v2 in
+       happySeq r (happyGoto nt j tk st sts (r `HappyStk` stk'))
+
+happySpecReduce_3 i fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happySpecReduce_3 nt fn j tk _ (HappyCons (_) ((HappyCons (_) (sts@((HappyCons (st@(action)) (_))))))) (v1`HappyStk`v2`HappyStk`v3`HappyStk`stk')
+     = let r = fn v1 v2 v3 in
+       happySeq r (happyGoto nt j tk st sts (r `HappyStk` stk'))
+
+happyReduce k i fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happyReduce k nt fn j tk st sts stk
+     = case happyDrop (k Happy_GHC_Exts.-# (1# :: Happy_GHC_Exts.Int#)) sts of
+         sts1@((HappyCons (st1@(action)) (_))) ->
+                let r = fn stk in  -- it doesn't hurt to always seq here...
+                happyDoSeq r (happyGoto nt j tk st1 sts1 r)
+
+happyMonadReduce k nt fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happyMonadReduce k nt fn j tk st sts stk =
+      case happyDrop k (HappyCons (st) (sts)) of
+        sts1@((HappyCons (st1@(action)) (_))) ->
+          let drop_stk = happyDropStk k stk in
+          happyThen1 (fn stk tk) (\r -> happyGoto nt j tk st1 sts1 (r `HappyStk` drop_stk))
+
+happyMonad2Reduce k nt fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happyMonad2Reduce k nt fn j tk st sts stk =
+      case happyDrop k (HappyCons (st) (sts)) of
+        sts1@((HappyCons (st1@(action)) (_))) ->
+         let drop_stk = happyDropStk k stk
+
+             off = happyAdjustOffset (indexShortOffAddr happyGotoOffsets st1)
+             off_i = (off Happy_GHC_Exts.+#  nt)
+             new_state = indexShortOffAddr happyTable off_i
+
+
+
+
+          in
+          happyThen1 (fn stk tk) (\r -> happyNewToken new_state sts1 (r `HappyStk` drop_stk))
+
+happyDrop 0# l = l
+happyDrop n (HappyCons (_) (t)) = happyDrop (n Happy_GHC_Exts.-# (1# :: Happy_GHC_Exts.Int#)) t
+
+happyDropStk 0# l = l
+happyDropStk n (x `HappyStk` xs) = happyDropStk (n Happy_GHC_Exts.-# (1#::Happy_GHC_Exts.Int#)) xs
+
+-----------------------------------------------------------------------------
+-- Moving to a new state after a reduction
+
+
+happyGoto nt j tk st = 
+   (happyTrace (", goto state " ++ show (Happy_GHC_Exts.I# (new_state)) ++ "\n")) $
+   happyDoAction j tk new_state
+   where off = happyAdjustOffset (indexShortOffAddr happyGotoOffsets st)
+         off_i = (off Happy_GHC_Exts.+#  nt)
+         new_state = indexShortOffAddr happyTable off_i
+
+
+
+
+-----------------------------------------------------------------------------
+-- Error recovery (0# is the error token)
+
+-- parse error if we are in recovery and we fail again
+happyFail explist 0# tk old_st _ stk@(x `HappyStk` _) =
+     let i = (case Happy_GHC_Exts.unsafeCoerce# x of { (Happy_GHC_Exts.I# (i)) -> i }) in
+--      trace "failing" $ 
+        happyError_ explist i tk
+
+{-  We don't need state discarding for our restricted implementation of
+    "error".  In fact, it can cause some bogus parses, so I've disabled it
+    for now --SDM
+
+-- discard a state
+happyFail  0# tk old_st (HappyCons ((action)) (sts)) 
+                                                (saved_tok `HappyStk` _ `HappyStk` stk) =
+--      trace ("discarding state, depth " ++ show (length stk))  $
+        happyDoAction 0# tk action sts ((saved_tok`HappyStk`stk))
+-}
+
+-- Enter error recovery: generate an error token,
+--                       save the old token and carry on.
+happyFail explist i tk (action) sts stk =
+--      trace "entering error recovery" $
+        happyDoAction 0# tk action sts ( (Happy_GHC_Exts.unsafeCoerce# (Happy_GHC_Exts.I# (i))) `HappyStk` stk)
+
+-- Internal happy errors:
+
+notHappyAtAll :: a
+notHappyAtAll = error "Internal Happy error\n"
+
+-----------------------------------------------------------------------------
+-- Hack to get the typechecker to accept our action functions
+
+
+happyTcHack :: Happy_GHC_Exts.Int# -> a -> a
+happyTcHack x y = y
+{-# INLINE happyTcHack #-}
+
+
+-----------------------------------------------------------------------------
+-- Seq-ing.  If the --strict flag is given, then Happy emits 
+--      happySeq = happyDoSeq
+-- otherwise it emits
+--      happySeq = happyDontSeq
+
+happyDoSeq, happyDontSeq :: a -> b -> b
+happyDoSeq   a b = a `seq` b
+happyDontSeq a b = b
+
+-----------------------------------------------------------------------------
+-- Don't inline any functions from the template.  GHC has a nasty habit
+-- of deciding to inline happyGoto everywhere, which increases the size of
+-- the generated parser quite a bit.
+
+
+{-# NOINLINE happyDoAction #-}
+{-# NOINLINE happyTable #-}
+{-# NOINLINE happyCheck #-}
+{-# NOINLINE happyActOffsets #-}
+{-# NOINLINE happyGotoOffsets #-}
+{-# NOINLINE happyDefActions #-}
+
+{-# NOINLINE happyShift #-}
+{-# NOINLINE happySpecReduce_0 #-}
+{-# NOINLINE happySpecReduce_1 #-}
+{-# NOINLINE happySpecReduce_2 #-}
+{-# NOINLINE happySpecReduce_3 #-}
+{-# NOINLINE happyReduce #-}
+{-# NOINLINE happyMonadReduce #-}
+{-# NOINLINE happyGoto #-}
+{-# NOINLINE happyFail #-}
+
+-- end of Happy Template.
+
diff --git a/data/HappyTemplate-arrays-debug b/data/HappyTemplate-arrays-debug
new file mode 100644
index 0000000..0e05d53
--- /dev/null
+++ b/data/HappyTemplate-arrays-debug
@@ -0,0 +1,483 @@
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+{-# LINE 1 "<built-in>" #-}
+{-# LINE 17 "<built-in>" #-}
+{-# LINE 1 "/Users/jyothsnasrinivas/.stack/programs/x86_64-osx/ghc-8.2.2/lib/ghc-8.2.2/include/ghcversion.h" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{-# LINE 18 "<built-in>" #-}
+{-# LINE 1 "/var/folders/m6/wm286css74x1_rxyssdx0b1m0000gn/T/ghc9240_0/ghc_2.h" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{-# LINE 19 "<built-in>" #-}
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+-- Id: GenericTemplate.hs,v 1.26 2005/01/14 14:47:22 simonmar Exp 
+
+
+
+
+
+
+
+
+
+
+{-# LINE 43 "templates/GenericTemplate.hs" #-}
+
+data Happy_IntList = HappyCons Int Happy_IntList
+
+
+
+
+
+
+
+
+{-# LINE 65 "templates/GenericTemplate.hs" #-}
+
+
+{-# LINE 75 "templates/GenericTemplate.hs" #-}
+
+
+
+happyTrace string expr = Happy_System_IO_Unsafe.unsafePerformIO $ do
+    Happy_System_IO.hPutStr Happy_System_IO.stderr string
+    return expr
+
+
+
+
+infixr 9 `HappyStk`
+data HappyStk a = HappyStk a (HappyStk a)
+
+-----------------------------------------------------------------------------
+-- starting the parse
+
+happyParse start_state = happyNewToken start_state notHappyAtAll notHappyAtAll
+
+-----------------------------------------------------------------------------
+-- Accepting the parse
+
+-- If the current token is (0), it means we've just accepted a partial
+-- parse (a %partial parser).  We must ignore the saved token on the top of
+-- the stack in this case.
+happyAccept (0) tk st sts (_ `HappyStk` ans `HappyStk` _) =
+        happyReturn1 ans
+happyAccept j tk st sts (HappyStk ans _) = 
+         (happyReturn1 ans)
+
+-----------------------------------------------------------------------------
+-- Arrays only: do the next action
+
+
+
+happyDoAction i tk st
+        = (happyTrace ("state: " ++ show (st) ++ 
+                      
+{-# LINE 110 "templates/GenericTemplate.hs" #-}
+          ",\ttoken: " ++ show (i) ++
+                      
+{-# LINE 110 "templates/GenericTemplate.hs" #-}
+          ",\taction: ")) $
+          
+
+          case action of
+                (0)           -> (happyTrace ("fail.\n")) $
+                                     happyFail (happyExpListPerState ((st) :: Int)) i tk st
+                (-1)          -> (happyTrace ("accept.\n")) $
+                                     happyAccept i tk st
+                n | (n < ((0) :: Int)) -> (happyTrace ("reduce (rule " ++ show rule
+                                                               
+{-# LINE 118 "templates/GenericTemplate.hs" #-}
+                                                   ++ ")")) $
+                                                   
+                                                   (happyReduceArr Happy_Data_Array.! rule) i tk st
+                                                   where rule = ((negate ((n + ((1) :: Int)))))
+                n                 -> (happyTrace ("shift, enter state "
+                                                 
+{-# LINE 122 "templates/GenericTemplate.hs" #-}
+                                     ++ show (new_state)
+                                                 
+{-# LINE 122 "templates/GenericTemplate.hs" #-}
+                                     ++ "\n")) $
+                                     
+
+                                     happyShift new_state i tk st
+                                     where new_state = (n - ((1) :: Int))
+   where off    = happyAdjustOffset (indexShortOffAddr happyActOffsets st)
+         off_i  = (off +  i)
+         check  = if (off_i >= ((0) :: Int))
+                  then (indexShortOffAddr happyCheck off_i ==  i)
+                  else False
+         action
+          | check     = indexShortOffAddr happyTable off_i
+          | otherwise = indexShortOffAddr happyDefActions st
+
+
+
+
+{-# LINE 147 "templates/GenericTemplate.hs" #-}
+indexShortOffAddr arr off = arr Happy_Data_Array.! off
+
+
+{-# INLINE happyLt #-}
+happyLt x y = (x < y)
+
+
+
+
+
+
+readArrayBit arr bit =
+    Bits.testBit (indexShortOffAddr arr (bit `div` 16)) (bit `mod` 16)
+
+
+
+
+
+
+-----------------------------------------------------------------------------
+-- HappyState data type (not arrays)
+
+
+{-# LINE 180 "templates/GenericTemplate.hs" #-}
+
+-----------------------------------------------------------------------------
+-- Shifting a token
+
+happyShift new_state (0) tk st sts stk@(x `HappyStk` _) =
+     let i = (case x of { HappyErrorToken (i) -> i }) in
+--     trace "shifting the error token" $
+     happyDoAction i tk new_state (HappyCons (st) (sts)) (stk)
+
+happyShift new_state i tk st sts stk =
+     happyNewToken new_state (HappyCons (st) (sts)) ((HappyTerminal (tk))`HappyStk`stk)
+
+-- happyReduce is specialised for the common cases.
+
+happySpecReduce_0 i fn (0) tk st sts stk
+     = happyFail [] (0) tk st sts stk
+happySpecReduce_0 nt fn j tk st@((action)) sts stk
+     = happyGoto nt j tk st (HappyCons (st) (sts)) (fn `HappyStk` stk)
+
+happySpecReduce_1 i fn (0) tk st sts stk
+     = happyFail [] (0) tk st sts stk
+happySpecReduce_1 nt fn j tk _ sts@((HappyCons (st@(action)) (_))) (v1`HappyStk`stk')
+     = let r = fn v1 in
+       happySeq r (happyGoto nt j tk st sts (r `HappyStk` stk'))
+
+happySpecReduce_2 i fn (0) tk st sts stk
+     = happyFail [] (0) tk st sts stk
+happySpecReduce_2 nt fn j tk _ (HappyCons (_) (sts@((HappyCons (st@(action)) (_))))) (v1`HappyStk`v2`HappyStk`stk')
+     = let r = fn v1 v2 in
+       happySeq r (happyGoto nt j tk st sts (r `HappyStk` stk'))
+
+happySpecReduce_3 i fn (0) tk st sts stk
+     = happyFail [] (0) tk st sts stk
+happySpecReduce_3 nt fn j tk _ (HappyCons (_) ((HappyCons (_) (sts@((HappyCons (st@(action)) (_))))))) (v1`HappyStk`v2`HappyStk`v3`HappyStk`stk')
+     = let r = fn v1 v2 v3 in
+       happySeq r (happyGoto nt j tk st sts (r `HappyStk` stk'))
+
+happyReduce k i fn (0) tk st sts stk
+     = happyFail [] (0) tk st sts stk
+happyReduce k nt fn j tk st sts stk
+     = case happyDrop (k - ((1) :: Int)) sts of
+         sts1@((HappyCons (st1@(action)) (_))) ->
+                let r = fn stk in  -- it doesn't hurt to always seq here...
+                happyDoSeq r (happyGoto nt j tk st1 sts1 r)
+
+happyMonadReduce k nt fn (0) tk st sts stk
+     = happyFail [] (0) tk st sts stk
+happyMonadReduce k nt fn j tk st sts stk =
+      case happyDrop k (HappyCons (st) (sts)) of
+        sts1@((HappyCons (st1@(action)) (_))) ->
+          let drop_stk = happyDropStk k stk in
+          happyThen1 (fn stk tk) (\r -> happyGoto nt j tk st1 sts1 (r `HappyStk` drop_stk))
+
+happyMonad2Reduce k nt fn (0) tk st sts stk
+     = happyFail [] (0) tk st sts stk
+happyMonad2Reduce k nt fn j tk st sts stk =
+      case happyDrop k (HappyCons (st) (sts)) of
+        sts1@((HappyCons (st1@(action)) (_))) ->
+         let drop_stk = happyDropStk k stk
+
+             off = happyAdjustOffset (indexShortOffAddr happyGotoOffsets st1)
+             off_i = (off +  nt)
+             new_state = indexShortOffAddr happyTable off_i
+
+
+
+
+          in
+          happyThen1 (fn stk tk) (\r -> happyNewToken new_state sts1 (r `HappyStk` drop_stk))
+
+happyDrop (0) l = l
+happyDrop n (HappyCons (_) (t)) = happyDrop (n - ((1) :: Int)) t
+
+happyDropStk (0) l = l
+happyDropStk n (x `HappyStk` xs) = happyDropStk (n - ((1)::Int)) xs
+
+-----------------------------------------------------------------------------
+-- Moving to a new state after a reduction
+
+
+happyGoto nt j tk st = 
+   (happyTrace (", goto state " ++ show (new_state) ++ "\n")) $
+   happyDoAction j tk new_state
+   where off = happyAdjustOffset (indexShortOffAddr happyGotoOffsets st)
+         off_i = (off +  nt)
+         new_state = indexShortOffAddr happyTable off_i
+
+
+
+
+-----------------------------------------------------------------------------
+-- Error recovery ((0) is the error token)
+
+-- parse error if we are in recovery and we fail again
+happyFail explist (0) tk old_st _ stk@(x `HappyStk` _) =
+     let i = (case x of { HappyErrorToken (i) -> i }) in
+--      trace "failing" $ 
+        happyError_ explist i tk
+
+{-  We don't need state discarding for our restricted implementation of
+    "error".  In fact, it can cause some bogus parses, so I've disabled it
+    for now --SDM
+
+-- discard a state
+happyFail  (0) tk old_st (HappyCons ((action)) (sts)) 
+                                                (saved_tok `HappyStk` _ `HappyStk` stk) =
+--      trace ("discarding state, depth " ++ show (length stk))  $
+        happyDoAction (0) tk action sts ((saved_tok`HappyStk`stk))
+-}
+
+-- Enter error recovery: generate an error token,
+--                       save the old token and carry on.
+happyFail explist i tk (action) sts stk =
+--      trace "entering error recovery" $
+        happyDoAction (0) tk action sts ( (HappyErrorToken (i)) `HappyStk` stk)
+
+-- Internal happy errors:
+
+notHappyAtAll :: a
+notHappyAtAll = error "Internal Happy error\n"
+
+-----------------------------------------------------------------------------
+-- Hack to get the typechecker to accept our action functions
+
+
+
+
+
+
+
+-----------------------------------------------------------------------------
+-- Seq-ing.  If the --strict flag is given, then Happy emits 
+--      happySeq = happyDoSeq
+-- otherwise it emits
+--      happySeq = happyDontSeq
+
+happyDoSeq, happyDontSeq :: a -> b -> b
+happyDoSeq   a b = a `seq` b
+happyDontSeq a b = b
+
+-----------------------------------------------------------------------------
+-- Don't inline any functions from the template.  GHC has a nasty habit
+-- of deciding to inline happyGoto everywhere, which increases the size of
+-- the generated parser quite a bit.
+
+
+{-# NOINLINE happyDoAction #-}
+{-# NOINLINE happyTable #-}
+{-# NOINLINE happyCheck #-}
+{-# NOINLINE happyActOffsets #-}
+{-# NOINLINE happyGotoOffsets #-}
+{-# NOINLINE happyDefActions #-}
+
+{-# NOINLINE happyShift #-}
+{-# NOINLINE happySpecReduce_0 #-}
+{-# NOINLINE happySpecReduce_1 #-}
+{-# NOINLINE happySpecReduce_2 #-}
+{-# NOINLINE happySpecReduce_3 #-}
+{-# NOINLINE happyReduce #-}
+{-# NOINLINE happyMonadReduce #-}
+{-# NOINLINE happyGoto #-}
+{-# NOINLINE happyFail #-}
+
+-- end of Happy Template.
+
diff --git a/data/HappyTemplate-arrays-ghc b/data/HappyTemplate-arrays-ghc
new file mode 100644
index 0000000..4f5ac34
--- /dev/null
+++ b/data/HappyTemplate-arrays-ghc
@@ -0,0 +1,489 @@
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+{-# LINE 1 "<built-in>" #-}
+{-# LINE 17 "<built-in>" #-}
+{-# LINE 1 "/Users/jyothsnasrinivas/.stack/programs/x86_64-osx/ghc-8.2.2/lib/ghc-8.2.2/include/ghcversion.h" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{-# LINE 18 "<built-in>" #-}
+{-# LINE 1 "/var/folders/m6/wm286css74x1_rxyssdx0b1m0000gn/T/ghc9234_0/ghc_2.h" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{-# LINE 19 "<built-in>" #-}
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+-- Id: GenericTemplate.hs,v 1.26 2005/01/14 14:47:22 simonmar Exp 
+
+
+
+
+
+
+
+
+
+
+
+
+
+-- Do not remove this comment. Required to fix CPP parsing when using GCC and a clang-compiled alex.
+#if __GLASGOW_HASKELL__ > 706
+#define LT(n,m) ((Happy_GHC_Exts.tagToEnum# (n Happy_GHC_Exts.<# m)) :: Bool)
+#define GTE(n,m) ((Happy_GHC_Exts.tagToEnum# (n Happy_GHC_Exts.>=# m)) :: Bool)
+#define EQ(n,m) ((Happy_GHC_Exts.tagToEnum# (n Happy_GHC_Exts.==# m)) :: Bool)
+#else
+#define LT(n,m) (n Happy_GHC_Exts.<# m)
+#define GTE(n,m) (n Happy_GHC_Exts.>=# m)
+#define EQ(n,m) (n Happy_GHC_Exts.==# m)
+#endif
+
+{-# LINE 43 "templates/GenericTemplate.hs" #-}
+
+data Happy_IntList = HappyCons Happy_GHC_Exts.Int# Happy_IntList
+
+
+
+
+
+
+
+
+{-# LINE 65 "templates/GenericTemplate.hs" #-}
+
+
+{-# LINE 75 "templates/GenericTemplate.hs" #-}
+
+
+
+
+
+
+
+
+
+
+infixr 9 `HappyStk`
+data HappyStk a = HappyStk a (HappyStk a)
+
+-----------------------------------------------------------------------------
+-- starting the parse
+
+happyParse start_state = happyNewToken start_state notHappyAtAll notHappyAtAll
+
+-----------------------------------------------------------------------------
+-- Accepting the parse
+
+-- If the current token is 0#, it means we've just accepted a partial
+-- parse (a %partial parser).  We must ignore the saved token on the top of
+-- the stack in this case.
+happyAccept 0# tk st sts (_ `HappyStk` ans `HappyStk` _) =
+        happyReturn1 ans
+happyAccept j tk st sts (HappyStk ans _) = 
+        (happyTcHack j (happyTcHack st)) (happyReturn1 ans)
+
+-----------------------------------------------------------------------------
+-- Arrays only: do the next action
+
+
+
+happyDoAction i tk st
+        = {- nothing -}
+          
+
+          case action of
+                0#           -> {- nothing -}
+                                     happyFail (happyExpListPerState ((Happy_GHC_Exts.I# (st)) :: Int)) i tk st
+                -1#          -> {- nothing -}
+                                     happyAccept i tk st
+                n | LT(n,(0# :: Happy_GHC_Exts.Int#)) -> {- nothing -}
+                                                   
+                                                   (happyReduceArr Happy_Data_Array.! rule) i tk st
+                                                   where rule = (Happy_GHC_Exts.I# ((Happy_GHC_Exts.negateInt# ((n Happy_GHC_Exts.+# (1# :: Happy_GHC_Exts.Int#))))))
+                n                 -> {- nothing -}
+                                     
+
+                                     happyShift new_state i tk st
+                                     where new_state = (n Happy_GHC_Exts.-# (1# :: Happy_GHC_Exts.Int#))
+   where off    = happyAdjustOffset (indexShortOffAddr happyActOffsets st)
+         off_i  = (off Happy_GHC_Exts.+#  i)
+         check  = if GTE(off_i,(0# :: Happy_GHC_Exts.Int#))
+                  then EQ(indexShortOffAddr happyCheck off_i, i)
+                  else False
+         action
+          | check     = indexShortOffAddr happyTable off_i
+          | otherwise = indexShortOffAddr happyDefActions st
+
+
+
+
+indexShortOffAddr (HappyA# arr) off =
+        Happy_GHC_Exts.narrow16Int# i
+  where
+        i = Happy_GHC_Exts.word2Int# (Happy_GHC_Exts.or# (Happy_GHC_Exts.uncheckedShiftL# high 8#) low)
+        high = Happy_GHC_Exts.int2Word# (Happy_GHC_Exts.ord# (Happy_GHC_Exts.indexCharOffAddr# arr (off' Happy_GHC_Exts.+# 1#)))
+        low  = Happy_GHC_Exts.int2Word# (Happy_GHC_Exts.ord# (Happy_GHC_Exts.indexCharOffAddr# arr off'))
+        off' = off Happy_GHC_Exts.*# 2#
+
+
+
+
+{-# INLINE happyLt #-}
+happyLt x y = LT(x,y)
+
+
+readArrayBit arr bit =
+    Bits.testBit (Happy_GHC_Exts.I# (indexShortOffAddr arr ((unbox_int bit) `Happy_GHC_Exts.iShiftRA#` 4#))) (bit `mod` 16)
+  where unbox_int (Happy_GHC_Exts.I# x) = x
+
+
+
+
+
+
+data HappyAddr = HappyA# Happy_GHC_Exts.Addr#
+
+
+-----------------------------------------------------------------------------
+-- HappyState data type (not arrays)
+
+
+{-# LINE 180 "templates/GenericTemplate.hs" #-}
+
+-----------------------------------------------------------------------------
+-- Shifting a token
+
+happyShift new_state 0# tk st sts stk@(x `HappyStk` _) =
+     let i = (case x of { HappyErrorToken (Happy_GHC_Exts.I# (i)) -> i }) in
+--     trace "shifting the error token" $
+     happyDoAction i tk new_state (HappyCons (st) (sts)) (stk)
+
+happyShift new_state i tk st sts stk =
+     happyNewToken new_state (HappyCons (st) (sts)) ((HappyTerminal (tk))`HappyStk`stk)
+
+-- happyReduce is specialised for the common cases.
+
+happySpecReduce_0 i fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happySpecReduce_0 nt fn j tk st@((action)) sts stk
+     = happyGoto nt j tk st (HappyCons (st) (sts)) (fn `HappyStk` stk)
+
+happySpecReduce_1 i fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happySpecReduce_1 nt fn j tk _ sts@((HappyCons (st@(action)) (_))) (v1`HappyStk`stk')
+     = let r = fn v1 in
+       happySeq r (happyGoto nt j tk st sts (r `HappyStk` stk'))
+
+happySpecReduce_2 i fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happySpecReduce_2 nt fn j tk _ (HappyCons (_) (sts@((HappyCons (st@(action)) (_))))) (v1`HappyStk`v2`HappyStk`stk')
+     = let r = fn v1 v2 in
+       happySeq r (happyGoto nt j tk st sts (r `HappyStk` stk'))
+
+happySpecReduce_3 i fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happySpecReduce_3 nt fn j tk _ (HappyCons (_) ((HappyCons (_) (sts@((HappyCons (st@(action)) (_))))))) (v1`HappyStk`v2`HappyStk`v3`HappyStk`stk')
+     = let r = fn v1 v2 v3 in
+       happySeq r (happyGoto nt j tk st sts (r `HappyStk` stk'))
+
+happyReduce k i fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happyReduce k nt fn j tk st sts stk
+     = case happyDrop (k Happy_GHC_Exts.-# (1# :: Happy_GHC_Exts.Int#)) sts of
+         sts1@((HappyCons (st1@(action)) (_))) ->
+                let r = fn stk in  -- it doesn't hurt to always seq here...
+                happyDoSeq r (happyGoto nt j tk st1 sts1 r)
+
+happyMonadReduce k nt fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happyMonadReduce k nt fn j tk st sts stk =
+      case happyDrop k (HappyCons (st) (sts)) of
+        sts1@((HappyCons (st1@(action)) (_))) ->
+          let drop_stk = happyDropStk k stk in
+          happyThen1 (fn stk tk) (\r -> happyGoto nt j tk st1 sts1 (r `HappyStk` drop_stk))
+
+happyMonad2Reduce k nt fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happyMonad2Reduce k nt fn j tk st sts stk =
+      case happyDrop k (HappyCons (st) (sts)) of
+        sts1@((HappyCons (st1@(action)) (_))) ->
+         let drop_stk = happyDropStk k stk
+
+             off = happyAdjustOffset (indexShortOffAddr happyGotoOffsets st1)
+             off_i = (off Happy_GHC_Exts.+#  nt)
+             new_state = indexShortOffAddr happyTable off_i
+
+
+
+
+          in
+          happyThen1 (fn stk tk) (\r -> happyNewToken new_state sts1 (r `HappyStk` drop_stk))
+
+happyDrop 0# l = l
+happyDrop n (HappyCons (_) (t)) = happyDrop (n Happy_GHC_Exts.-# (1# :: Happy_GHC_Exts.Int#)) t
+
+happyDropStk 0# l = l
+happyDropStk n (x `HappyStk` xs) = happyDropStk (n Happy_GHC_Exts.-# (1#::Happy_GHC_Exts.Int#)) xs
+
+-----------------------------------------------------------------------------
+-- Moving to a new state after a reduction
+
+
+happyGoto nt j tk st = 
+   {- nothing -}
+   happyDoAction j tk new_state
+   where off = happyAdjustOffset (indexShortOffAddr happyGotoOffsets st)
+         off_i = (off Happy_GHC_Exts.+#  nt)
+         new_state = indexShortOffAddr happyTable off_i
+
+
+
+
+-----------------------------------------------------------------------------
+-- Error recovery (0# is the error token)
+
+-- parse error if we are in recovery and we fail again
+happyFail explist 0# tk old_st _ stk@(x `HappyStk` _) =
+     let i = (case x of { HappyErrorToken (Happy_GHC_Exts.I# (i)) -> i }) in
+--      trace "failing" $ 
+        happyError_ explist i tk
+
+{-  We don't need state discarding for our restricted implementation of
+    "error".  In fact, it can cause some bogus parses, so I've disabled it
+    for now --SDM
+
+-- discard a state
+happyFail  0# tk old_st (HappyCons ((action)) (sts)) 
+                                                (saved_tok `HappyStk` _ `HappyStk` stk) =
+--      trace ("discarding state, depth " ++ show (length stk))  $
+        happyDoAction 0# tk action sts ((saved_tok`HappyStk`stk))
+-}
+
+-- Enter error recovery: generate an error token,
+--                       save the old token and carry on.
+happyFail explist i tk (action) sts stk =
+--      trace "entering error recovery" $
+        happyDoAction 0# tk action sts ( (HappyErrorToken (Happy_GHC_Exts.I# (i))) `HappyStk` stk)
+
+-- Internal happy errors:
+
+notHappyAtAll :: a
+notHappyAtAll = error "Internal Happy error\n"
+
+-----------------------------------------------------------------------------
+-- Hack to get the typechecker to accept our action functions
+
+
+happyTcHack :: Happy_GHC_Exts.Int# -> a -> a
+happyTcHack x y = y
+{-# INLINE happyTcHack #-}
+
+
+-----------------------------------------------------------------------------
+-- Seq-ing.  If the --strict flag is given, then Happy emits 
+--      happySeq = happyDoSeq
+-- otherwise it emits
+--      happySeq = happyDontSeq
+
+happyDoSeq, happyDontSeq :: a -> b -> b
+happyDoSeq   a b = a `seq` b
+happyDontSeq a b = b
+
+-----------------------------------------------------------------------------
+-- Don't inline any functions from the template.  GHC has a nasty habit
+-- of deciding to inline happyGoto everywhere, which increases the size of
+-- the generated parser quite a bit.
+
+
+{-# NOINLINE happyDoAction #-}
+{-# NOINLINE happyTable #-}
+{-# NOINLINE happyCheck #-}
+{-# NOINLINE happyActOffsets #-}
+{-# NOINLINE happyGotoOffsets #-}
+{-# NOINLINE happyDefActions #-}
+
+{-# NOINLINE happyShift #-}
+{-# NOINLINE happySpecReduce_0 #-}
+{-# NOINLINE happySpecReduce_1 #-}
+{-# NOINLINE happySpecReduce_2 #-}
+{-# NOINLINE happySpecReduce_3 #-}
+{-# NOINLINE happyReduce #-}
+{-# NOINLINE happyMonadReduce #-}
+{-# NOINLINE happyGoto #-}
+{-# NOINLINE happyFail #-}
+
+-- end of Happy Template.
+
diff --git a/data/HappyTemplate-arrays-ghc-debug b/data/HappyTemplate-arrays-ghc-debug
new file mode 100644
index 0000000..8a6dca1
--- /dev/null
+++ b/data/HappyTemplate-arrays-ghc-debug
@@ -0,0 +1,504 @@
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+{-# LINE 1 "<built-in>" #-}
+{-# LINE 18 "<built-in>" #-}
+{-# LINE 1 "/Users/jyothsnasrinivas/.stack/programs/x86_64-osx/ghc-8.2.2/lib/ghc-8.2.2/include/ghcversion.h" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{-# LINE 19 "<built-in>" #-}
+{-# LINE 1 "/var/folders/m6/wm286css74x1_rxyssdx0b1m0000gn/T/ghc9243_0/ghc_2.h" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{-# LINE 20 "<built-in>" #-}
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+-- Id: GenericTemplate.hs,v 1.26 2005/01/14 14:47:22 simonmar Exp 
+
+
+
+
+
+
+
+
+
+
+
+
+
+-- Do not remove this comment. Required to fix CPP parsing when using GCC and a clang-compiled alex.
+#if __GLASGOW_HASKELL__ > 706
+#define LT(n,m) ((Happy_GHC_Exts.tagToEnum# (n Happy_GHC_Exts.<# m)) :: Bool)
+#define GTE(n,m) ((Happy_GHC_Exts.tagToEnum# (n Happy_GHC_Exts.>=# m)) :: Bool)
+#define EQ(n,m) ((Happy_GHC_Exts.tagToEnum# (n Happy_GHC_Exts.==# m)) :: Bool)
+#else
+#define LT(n,m) (n Happy_GHC_Exts.<# m)
+#define GTE(n,m) (n Happy_GHC_Exts.>=# m)
+#define EQ(n,m) (n Happy_GHC_Exts.==# m)
+#endif
+
+{-# LINE 43 "templates/GenericTemplate.hs" #-}
+
+data Happy_IntList = HappyCons Happy_GHC_Exts.Int# Happy_IntList
+
+
+
+
+
+
+
+
+{-# LINE 65 "templates/GenericTemplate.hs" #-}
+
+
+{-# LINE 75 "templates/GenericTemplate.hs" #-}
+
+
+
+happyTrace string expr = Happy_System_IO_Unsafe.unsafePerformIO $ do
+    Happy_System_IO.hPutStr Happy_System_IO.stderr string
+    return expr
+
+
+
+
+infixr 9 `HappyStk`
+data HappyStk a = HappyStk a (HappyStk a)
+
+-----------------------------------------------------------------------------
+-- starting the parse
+
+happyParse start_state = happyNewToken start_state notHappyAtAll notHappyAtAll
+
+-----------------------------------------------------------------------------
+-- Accepting the parse
+
+-- If the current token is 0#, it means we've just accepted a partial
+-- parse (a %partial parser).  We must ignore the saved token on the top of
+-- the stack in this case.
+happyAccept 0# tk st sts (_ `HappyStk` ans `HappyStk` _) =
+        happyReturn1 ans
+happyAccept j tk st sts (HappyStk ans _) = 
+        (happyTcHack j (happyTcHack st)) (happyReturn1 ans)
+
+-----------------------------------------------------------------------------
+-- Arrays only: do the next action
+
+
+
+happyDoAction i tk st
+        = (happyTrace ("state: " ++ show (Happy_GHC_Exts.I# (st)) ++ 
+                      
+{-# LINE 110 "templates/GenericTemplate.hs" #-}
+          ",\ttoken: " ++ show (Happy_GHC_Exts.I# (i)) ++
+                      
+{-# LINE 110 "templates/GenericTemplate.hs" #-}
+          ",\taction: ")) $
+          
+
+          case action of
+                0#           -> (happyTrace ("fail.\n")) $
+                                     happyFail (happyExpListPerState ((Happy_GHC_Exts.I# (st)) :: Int)) i tk st
+                -1#          -> (happyTrace ("accept.\n")) $
+                                     happyAccept i tk st
+                n | LT(n,(0# :: Happy_GHC_Exts.Int#)) -> (happyTrace ("reduce (rule " ++ show rule
+                                                               
+{-# LINE 118 "templates/GenericTemplate.hs" #-}
+                                                   ++ ")")) $
+                                                   
+                                                   (happyReduceArr Happy_Data_Array.! rule) i tk st
+                                                   where rule = (Happy_GHC_Exts.I# ((Happy_GHC_Exts.negateInt# ((n Happy_GHC_Exts.+# (1# :: Happy_GHC_Exts.Int#))))))
+                n                 -> (happyTrace ("shift, enter state "
+                                                 
+{-# LINE 122 "templates/GenericTemplate.hs" #-}
+                                     ++ show (Happy_GHC_Exts.I# (new_state))
+                                                 
+{-# LINE 122 "templates/GenericTemplate.hs" #-}
+                                     ++ "\n")) $
+                                     
+
+                                     happyShift new_state i tk st
+                                     where new_state = (n Happy_GHC_Exts.-# (1# :: Happy_GHC_Exts.Int#))
+   where off    = happyAdjustOffset (indexShortOffAddr happyActOffsets st)
+         off_i  = (off Happy_GHC_Exts.+#  i)
+         check  = if GTE(off_i,(0# :: Happy_GHC_Exts.Int#))
+                  then EQ(indexShortOffAddr happyCheck off_i, i)
+                  else False
+         action
+          | check     = indexShortOffAddr happyTable off_i
+          | otherwise = indexShortOffAddr happyDefActions st
+
+
+
+
+indexShortOffAddr (HappyA# arr) off =
+        Happy_GHC_Exts.narrow16Int# i
+  where
+        i = Happy_GHC_Exts.word2Int# (Happy_GHC_Exts.or# (Happy_GHC_Exts.uncheckedShiftL# high 8#) low)
+        high = Happy_GHC_Exts.int2Word# (Happy_GHC_Exts.ord# (Happy_GHC_Exts.indexCharOffAddr# arr (off' Happy_GHC_Exts.+# 1#)))
+        low  = Happy_GHC_Exts.int2Word# (Happy_GHC_Exts.ord# (Happy_GHC_Exts.indexCharOffAddr# arr off'))
+        off' = off Happy_GHC_Exts.*# 2#
+
+
+
+
+{-# INLINE happyLt #-}
+happyLt x y = LT(x,y)
+
+
+readArrayBit arr bit =
+    Bits.testBit (Happy_GHC_Exts.I# (indexShortOffAddr arr ((unbox_int bit) `Happy_GHC_Exts.iShiftRA#` 4#))) (bit `mod` 16)
+  where unbox_int (Happy_GHC_Exts.I# x) = x
+
+
+
+
+
+
+data HappyAddr = HappyA# Happy_GHC_Exts.Addr#
+
+
+-----------------------------------------------------------------------------
+-- HappyState data type (not arrays)
+
+
+{-# LINE 180 "templates/GenericTemplate.hs" #-}
+
+-----------------------------------------------------------------------------
+-- Shifting a token
+
+happyShift new_state 0# tk st sts stk@(x `HappyStk` _) =
+     let i = (case x of { HappyErrorToken (Happy_GHC_Exts.I# (i)) -> i }) in
+--     trace "shifting the error token" $
+     happyDoAction i tk new_state (HappyCons (st) (sts)) (stk)
+
+happyShift new_state i tk st sts stk =
+     happyNewToken new_state (HappyCons (st) (sts)) ((HappyTerminal (tk))`HappyStk`stk)
+
+-- happyReduce is specialised for the common cases.
+
+happySpecReduce_0 i fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happySpecReduce_0 nt fn j tk st@((action)) sts stk
+     = happyGoto nt j tk st (HappyCons (st) (sts)) (fn `HappyStk` stk)
+
+happySpecReduce_1 i fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happySpecReduce_1 nt fn j tk _ sts@((HappyCons (st@(action)) (_))) (v1`HappyStk`stk')
+     = let r = fn v1 in
+       happySeq r (happyGoto nt j tk st sts (r `HappyStk` stk'))
+
+happySpecReduce_2 i fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happySpecReduce_2 nt fn j tk _ (HappyCons (_) (sts@((HappyCons (st@(action)) (_))))) (v1`HappyStk`v2`HappyStk`stk')
+     = let r = fn v1 v2 in
+       happySeq r (happyGoto nt j tk st sts (r `HappyStk` stk'))
+
+happySpecReduce_3 i fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happySpecReduce_3 nt fn j tk _ (HappyCons (_) ((HappyCons (_) (sts@((HappyCons (st@(action)) (_))))))) (v1`HappyStk`v2`HappyStk`v3`HappyStk`stk')
+     = let r = fn v1 v2 v3 in
+       happySeq r (happyGoto nt j tk st sts (r `HappyStk` stk'))
+
+happyReduce k i fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happyReduce k nt fn j tk st sts stk
+     = case happyDrop (k Happy_GHC_Exts.-# (1# :: Happy_GHC_Exts.Int#)) sts of
+         sts1@((HappyCons (st1@(action)) (_))) ->
+                let r = fn stk in  -- it doesn't hurt to always seq here...
+                happyDoSeq r (happyGoto nt j tk st1 sts1 r)
+
+happyMonadReduce k nt fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happyMonadReduce k nt fn j tk st sts stk =
+      case happyDrop k (HappyCons (st) (sts)) of
+        sts1@((HappyCons (st1@(action)) (_))) ->
+          let drop_stk = happyDropStk k stk in
+          happyThen1 (fn stk tk) (\r -> happyGoto nt j tk st1 sts1 (r `HappyStk` drop_stk))
+
+happyMonad2Reduce k nt fn 0# tk st sts stk
+     = happyFail [] 0# tk st sts stk
+happyMonad2Reduce k nt fn j tk st sts stk =
+      case happyDrop k (HappyCons (st) (sts)) of
+        sts1@((HappyCons (st1@(action)) (_))) ->
+         let drop_stk = happyDropStk k stk
+
+             off = happyAdjustOffset (indexShortOffAddr happyGotoOffsets st1)
+             off_i = (off Happy_GHC_Exts.+#  nt)
+             new_state = indexShortOffAddr happyTable off_i
+
+
+
+
+          in
+          happyThen1 (fn stk tk) (\r -> happyNewToken new_state sts1 (r `HappyStk` drop_stk))
+
+happyDrop 0# l = l
+happyDrop n (HappyCons (_) (t)) = happyDrop (n Happy_GHC_Exts.-# (1# :: Happy_GHC_Exts.Int#)) t
+
+happyDropStk 0# l = l
+happyDropStk n (x `HappyStk` xs) = happyDropStk (n Happy_GHC_Exts.-# (1#::Happy_GHC_Exts.Int#)) xs
+
+-----------------------------------------------------------------------------
+-- Moving to a new state after a reduction
+
+
+happyGoto nt j tk st = 
+   (happyTrace (", goto state " ++ show (Happy_GHC_Exts.I# (new_state)) ++ "\n")) $
+   happyDoAction j tk new_state
+   where off = happyAdjustOffset (indexShortOffAddr happyGotoOffsets st)
+         off_i = (off Happy_GHC_Exts.+#  nt)
+         new_state = indexShortOffAddr happyTable off_i
+
+
+
+
+-----------------------------------------------------------------------------
+-- Error recovery (0# is the error token)
+
+-- parse error if we are in recovery and we fail again
+happyFail explist 0# tk old_st _ stk@(x `HappyStk` _) =
+     let i = (case x of { HappyErrorToken (Happy_GHC_Exts.I# (i)) -> i }) in
+--      trace "failing" $ 
+        happyError_ explist i tk
+
+{-  We don't need state discarding for our restricted implementation of
+    "error".  In fact, it can cause some bogus parses, so I've disabled it
+    for now --SDM
+
+-- discard a state
+happyFail  0# tk old_st (HappyCons ((action)) (sts)) 
+                                                (saved_tok `HappyStk` _ `HappyStk` stk) =
+--      trace ("discarding state, depth " ++ show (length stk))  $
+        happyDoAction 0# tk action sts ((saved_tok`HappyStk`stk))
+-}
+
+-- Enter error recovery: generate an error token,
+--                       save the old token and carry on.
+happyFail explist i tk (action) sts stk =
+--      trace "entering error recovery" $
+        happyDoAction 0# tk action sts ( (HappyErrorToken (Happy_GHC_Exts.I# (i))) `HappyStk` stk)
+
+-- Internal happy errors:
+
+notHappyAtAll :: a
+notHappyAtAll = error "Internal Happy error\n"
+
+-----------------------------------------------------------------------------
+-- Hack to get the typechecker to accept our action functions
+
+
+happyTcHack :: Happy_GHC_Exts.Int# -> a -> a
+happyTcHack x y = y
+{-# INLINE happyTcHack #-}
+
+
+-----------------------------------------------------------------------------
+-- Seq-ing.  If the --strict flag is given, then Happy emits 
+--      happySeq = happyDoSeq
+-- otherwise it emits
+--      happySeq = happyDontSeq
+
+happyDoSeq, happyDontSeq :: a -> b -> b
+happyDoSeq   a b = a `seq` b
+happyDontSeq a b = b
+
+-----------------------------------------------------------------------------
+-- Don't inline any functions from the template.  GHC has a nasty habit
+-- of deciding to inline happyGoto everywhere, which increases the size of
+-- the generated parser quite a bit.
+
+
+{-# NOINLINE happyDoAction #-}
+{-# NOINLINE happyTable #-}
+{-# NOINLINE happyCheck #-}
+{-# NOINLINE happyActOffsets #-}
+{-# NOINLINE happyGotoOffsets #-}
+{-# NOINLINE happyDefActions #-}
+
+{-# NOINLINE happyShift #-}
+{-# NOINLINE happySpecReduce_0 #-}
+{-# NOINLINE happySpecReduce_1 #-}
+{-# NOINLINE happySpecReduce_2 #-}
+{-# NOINLINE happySpecReduce_3 #-}
+{-# NOINLINE happyReduce #-}
+{-# NOINLINE happyMonadReduce #-}
+{-# NOINLINE happyGoto #-}
+{-# NOINLINE happyFail #-}
+
+-- end of Happy Template.
+
diff --git a/data/HappyTemplate-coerce b/data/HappyTemplate-coerce
new file mode 100644
index 0000000..34fa0f4
--- /dev/null
+++ b/data/HappyTemplate-coerce
@@ -0,0 +1,470 @@
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+{-# LINE 1 "<built-in>" #-}
+{-# LINE 17 "<built-in>" #-}
+{-# LINE 1 "/Users/jyothsnasrinivas/.stack/programs/x86_64-osx/ghc-8.2.2/lib/ghc-8.2.2/include/ghcversion.h" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{-# LINE 18 "<built-in>" #-}
+{-# LINE 1 "/var/folders/m6/wm286css74x1_rxyssdx0b1m0000gn/T/ghc9228_0/ghc_2.h" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{-# LINE 19 "<built-in>" #-}
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+-- Id: GenericTemplate.hs,v 1.26 2005/01/14 14:47:22 simonmar Exp 
+
+
+
+
+
+
+
+
+
+
+
+
+
+-- Do not remove this comment. Required to fix CPP parsing when using GCC and a clang-compiled alex.
+#if __GLASGOW_HASKELL__ > 706
+#define LT(n,m) ((Happy_GHC_Exts.tagToEnum# (n Happy_GHC_Exts.<# m)) :: Bool)
+#define GTE(n,m) ((Happy_GHC_Exts.tagToEnum# (n Happy_GHC_Exts.>=# m)) :: Bool)
+#define EQ(n,m) ((Happy_GHC_Exts.tagToEnum# (n Happy_GHC_Exts.==# m)) :: Bool)
+#else
+#define LT(n,m) (n Happy_GHC_Exts.<# m)
+#define GTE(n,m) (n Happy_GHC_Exts.>=# m)
+#define EQ(n,m) (n Happy_GHC_Exts.==# m)
+#endif
+
+{-# LINE 43 "templates/GenericTemplate.hs" #-}
+
+data Happy_IntList = HappyCons Happy_GHC_Exts.Int# Happy_IntList
+
+
+
+
+
+
+
+
+{-# LINE 65 "templates/GenericTemplate.hs" #-}
+
+
+{-# LINE 75 "templates/GenericTemplate.hs" #-}
+
+
+
+
+
+
+
+
+
+
+infixr 9 `HappyStk`
+data HappyStk a = HappyStk a (HappyStk a)
+
+-----------------------------------------------------------------------------
+-- starting the parse
+
+happyParse start_state = happyNewToken start_state notHappyAtAll notHappyAtAll
+
+-----------------------------------------------------------------------------
+-- Accepting the parse
+
+-- If the current token is 1#, it means we've just accepted a partial
+-- parse (a %partial parser).  We must ignore the saved token on the top of
+-- the stack in this case.
+happyAccept 1# tk st sts (_ `HappyStk` ans `HappyStk` _) =
+        happyReturn1 ans
+happyAccept j tk st sts (HappyStk ans _) = 
+        (happyTcHack j ) (happyReturn1 ans)
+
+-----------------------------------------------------------------------------
+-- Arrays only: do the next action
+
+
+{-# LINE 137 "templates/GenericTemplate.hs" #-}
+
+
+indexShortOffAddr (HappyA# arr) off =
+        Happy_GHC_Exts.narrow16Int# i
+  where
+        i = Happy_GHC_Exts.word2Int# (Happy_GHC_Exts.or# (Happy_GHC_Exts.uncheckedShiftL# high 8#) low)
+        high = Happy_GHC_Exts.int2Word# (Happy_GHC_Exts.ord# (Happy_GHC_Exts.indexCharOffAddr# arr (off' Happy_GHC_Exts.+# 1#)))
+        low  = Happy_GHC_Exts.int2Word# (Happy_GHC_Exts.ord# (Happy_GHC_Exts.indexCharOffAddr# arr off'))
+        off' = off Happy_GHC_Exts.*# 2#
+
+
+
+
+{-# INLINE happyLt #-}
+happyLt x y = LT(x,y)
+
+
+readArrayBit arr bit =
+    Bits.testBit (Happy_GHC_Exts.I# (indexShortOffAddr arr ((unbox_int bit) `Happy_GHC_Exts.iShiftRA#` 4#))) (bit `mod` 16)
+  where unbox_int (Happy_GHC_Exts.I# x) = x
+
+
+
+
+
+
+data HappyAddr = HappyA# Happy_GHC_Exts.Addr#
+
+
+-----------------------------------------------------------------------------
+-- HappyState data type (not arrays)
+
+
+
+newtype HappyState b c = HappyState
+        (Happy_GHC_Exts.Int# ->                    -- token number
+         Happy_GHC_Exts.Int# ->                    -- token number (yes, again)
+         b ->                           -- token semantic value
+         HappyState b c ->              -- current state
+         [HappyState b c] ->            -- state stack
+         c)
+
+
+
+-----------------------------------------------------------------------------
+-- Shifting a token
+
+happyShift new_state 1# tk st sts stk@(x `HappyStk` _) =
+     let i = (case Happy_GHC_Exts.unsafeCoerce# x of { (Happy_GHC_Exts.I# (i)) -> i }) in
+--     trace "shifting the error token" $
+     new_state i i tk (HappyState (new_state)) ((st):(sts)) (stk)
+
+happyShift new_state i tk st sts stk =
+     happyNewToken new_state ((st):(sts)) ((happyInTok (tk))`HappyStk`stk)
+
+-- happyReduce is specialised for the common cases.
+
+happySpecReduce_0 i fn 1# tk st sts stk
+     = happyFail [] 1# tk st sts stk
+happySpecReduce_0 nt fn j tk st@((HappyState (action))) sts stk
+     = action nt j tk st ((st):(sts)) (fn `HappyStk` stk)
+
+happySpecReduce_1 i fn 1# tk st sts stk
+     = happyFail [] 1# tk st sts stk
+happySpecReduce_1 nt fn j tk _ sts@(((st@(HappyState (action))):(_))) (v1`HappyStk`stk')
+     = let r = fn v1 in
+       happySeq r (action nt j tk st sts (r `HappyStk` stk'))
+
+happySpecReduce_2 i fn 1# tk st sts stk
+     = happyFail [] 1# tk st sts stk
+happySpecReduce_2 nt fn j tk _ ((_):(sts@(((st@(HappyState (action))):(_))))) (v1`HappyStk`v2`HappyStk`stk')
+     = let r = fn v1 v2 in
+       happySeq r (action nt j tk st sts (r `HappyStk` stk'))
+
+happySpecReduce_3 i fn 1# tk st sts stk
+     = happyFail [] 1# tk st sts stk
+happySpecReduce_3 nt fn j tk _ ((_):(((_):(sts@(((st@(HappyState (action))):(_))))))) (v1`HappyStk`v2`HappyStk`v3`HappyStk`stk')
+     = let r = fn v1 v2 v3 in
+       happySeq r (action nt j tk st sts (r `HappyStk` stk'))
+
+happyReduce k i fn 1# tk st sts stk
+     = happyFail [] 1# tk st sts stk
+happyReduce k nt fn j tk st sts stk
+     = case happyDrop (k Happy_GHC_Exts.-# (1# :: Happy_GHC_Exts.Int#)) sts of
+         sts1@(((st1@(HappyState (action))):(_))) ->
+                let r = fn stk in  -- it doesn't hurt to always seq here...
+                happyDoSeq r (action nt j tk st1 sts1 r)
+
+happyMonadReduce k nt fn 1# tk st sts stk
+     = happyFail [] 1# tk st sts stk
+happyMonadReduce k nt fn j tk st sts stk =
+      case happyDrop k ((st):(sts)) of
+        sts1@(((st1@(HappyState (action))):(_))) ->
+          let drop_stk = happyDropStk k stk in
+          happyThen1 (fn stk tk) (\r -> action nt j tk st1 sts1 (r `HappyStk` drop_stk))
+
+happyMonad2Reduce k nt fn 1# tk st sts stk
+     = happyFail [] 1# tk st sts stk
+happyMonad2Reduce k nt fn j tk st sts stk =
+      case happyDrop k ((st):(sts)) of
+        sts1@(((st1@(HappyState (action))):(_))) ->
+         let drop_stk = happyDropStk k stk
+
+
+
+
+
+             _ = nt :: Happy_GHC_Exts.Int#
+             new_state = action
+
+          in
+          happyThen1 (fn stk tk) (\r -> happyNewToken new_state sts1 (r `HappyStk` drop_stk))
+
+happyDrop 0# l = l
+happyDrop n ((_):(t)) = happyDrop (n Happy_GHC_Exts.-# (1# :: Happy_GHC_Exts.Int#)) t
+
+happyDropStk 0# l = l
+happyDropStk n (x `HappyStk` xs) = happyDropStk (n Happy_GHC_Exts.-# (1#::Happy_GHC_Exts.Int#)) xs
+
+-----------------------------------------------------------------------------
+-- Moving to a new state after a reduction
+
+
+
+
+
+
+
+
+
+happyGoto action j tk st = action j j tk (HappyState action)
+
+
+-----------------------------------------------------------------------------
+-- Error recovery (1# is the error token)
+
+-- parse error if we are in recovery and we fail again
+happyFail explist 1# tk old_st _ stk@(x `HappyStk` _) =
+     let i = (case Happy_GHC_Exts.unsafeCoerce# x of { (Happy_GHC_Exts.I# (i)) -> i }) in
+--      trace "failing" $ 
+        happyError_ explist i tk
+
+{-  We don't need state discarding for our restricted implementation of
+    "error".  In fact, it can cause some bogus parses, so I've disabled it
+    for now --SDM
+
+-- discard a state
+happyFail  1# tk old_st (((HappyState (action))):(sts)) 
+                                                (saved_tok `HappyStk` _ `HappyStk` stk) =
+--      trace ("discarding state, depth " ++ show (length stk))  $
+        action 1# 1# tk (HappyState (action)) sts ((saved_tok`HappyStk`stk))
+-}
+
+-- Enter error recovery: generate an error token,
+--                       save the old token and carry on.
+happyFail explist i tk (HappyState (action)) sts stk =
+--      trace "entering error recovery" $
+        action 1# 1# tk (HappyState (action)) sts ( (Happy_GHC_Exts.unsafeCoerce# (Happy_GHC_Exts.I# (i))) `HappyStk` stk)
+
+-- Internal happy errors:
+
+notHappyAtAll :: a
+notHappyAtAll = error "Internal Happy error\n"
+
+-----------------------------------------------------------------------------
+-- Hack to get the typechecker to accept our action functions
+
+
+happyTcHack :: Happy_GHC_Exts.Int# -> a -> a
+happyTcHack x y = y
+{-# INLINE happyTcHack #-}
+
+
+-----------------------------------------------------------------------------
+-- Seq-ing.  If the --strict flag is given, then Happy emits 
+--      happySeq = happyDoSeq
+-- otherwise it emits
+--      happySeq = happyDontSeq
+
+happyDoSeq, happyDontSeq :: a -> b -> b
+happyDoSeq   a b = a `seq` b
+happyDontSeq a b = b
+
+-----------------------------------------------------------------------------
+-- Don't inline any functions from the template.  GHC has a nasty habit
+-- of deciding to inline happyGoto everywhere, which increases the size of
+-- the generated parser quite a bit.
+
+
+
+
+
+
+
+
+
+{-# NOINLINE happyShift #-}
+{-# NOINLINE happySpecReduce_0 #-}
+{-# NOINLINE happySpecReduce_1 #-}
+{-# NOINLINE happySpecReduce_2 #-}
+{-# NOINLINE happySpecReduce_3 #-}
+{-# NOINLINE happyReduce #-}
+{-# NOINLINE happyMonadReduce #-}
+{-# NOINLINE happyGoto #-}
+{-# NOINLINE happyFail #-}
+
+-- end of Happy Template.
+
diff --git a/data/HappyTemplate-ghc b/data/HappyTemplate-ghc
new file mode 100644
index 0000000..4a9eb3d
--- /dev/null
+++ b/data/HappyTemplate-ghc
@@ -0,0 +1,470 @@
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+{-# LINE 1 "<built-in>" #-}
+{-# LINE 16 "<built-in>" #-}
+{-# LINE 1 "/Users/jyothsnasrinivas/.stack/programs/x86_64-osx/ghc-8.2.2/lib/ghc-8.2.2/include/ghcversion.h" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{-# LINE 17 "<built-in>" #-}
+{-# LINE 1 "/var/folders/m6/wm286css74x1_rxyssdx0b1m0000gn/T/ghc9225_0/ghc_2.h" #-}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{-# LINE 18 "<built-in>" #-}
+{-# LINE 1 "templates/GenericTemplate.hs" #-}
+-- Id: GenericTemplate.hs,v 1.26 2005/01/14 14:47:22 simonmar Exp 
+
+
+
+
+
+
+
+
+
+
+
+
+
+-- Do not remove this comment. Required to fix CPP parsing when using GCC and a clang-compiled alex.
+#if __GLASGOW_HASKELL__ > 706
+#define LT(n,m) ((Happy_GHC_Exts.tagToEnum# (n Happy_GHC_Exts.<# m)) :: Bool)
+#define GTE(n,m) ((Happy_GHC_Exts.tagToEnum# (n Happy_GHC_Exts.>=# m)) :: Bool)
+#define EQ(n,m) ((Happy_GHC_Exts.tagToEnum# (n Happy_GHC_Exts.==# m)) :: Bool)
+#else
+#define LT(n,m) (n Happy_GHC_Exts.<# m)
+#define GTE(n,m) (n Happy_GHC_Exts.>=# m)
+#define EQ(n,m) (n Happy_GHC_Exts.==# m)
+#endif
+
+{-# LINE 43 "templates/GenericTemplate.hs" #-}
+
+data Happy_IntList = HappyCons Happy_GHC_Exts.Int# Happy_IntList
+
+
+
+
+
+
+
+
+{-# LINE 65 "templates/GenericTemplate.hs" #-}
+
+
+{-# LINE 75 "templates/GenericTemplate.hs" #-}
+
+
+
+
+
+
+
+
+
+
+infixr 9 `HappyStk`
+data HappyStk a = HappyStk a (HappyStk a)
+
+-----------------------------------------------------------------------------
+-- starting the parse
+
+happyParse start_state = happyNewToken start_state notHappyAtAll notHappyAtAll
+
+-----------------------------------------------------------------------------
+-- Accepting the parse
+
+-- If the current token is 1#, it means we've just accepted a partial
+-- parse (a %partial parser).  We must ignore the saved token on the top of
+-- the stack in this case.
+happyAccept 1# tk st sts (_ `HappyStk` ans `HappyStk` _) =
+        happyReturn1 ans
+happyAccept j tk st sts (HappyStk ans _) = 
+        (happyTcHack j ) (happyReturn1 ans)
+
+-----------------------------------------------------------------------------
+-- Arrays only: do the next action
+
+
+{-# LINE 137 "templates/GenericTemplate.hs" #-}
+
+
+indexShortOffAddr (HappyA# arr) off =
+        Happy_GHC_Exts.narrow16Int# i
+  where
+        i = Happy_GHC_Exts.word2Int# (Happy_GHC_Exts.or# (Happy_GHC_Exts.uncheckedShiftL# high 8#) low)
+        high = Happy_GHC_Exts.int2Word# (Happy_GHC_Exts.ord# (Happy_GHC_Exts.indexCharOffAddr# arr (off' Happy_GHC_Exts.+# 1#)))
+        low  = Happy_GHC_Exts.int2Word# (Happy_GHC_Exts.ord# (Happy_GHC_Exts.indexCharOffAddr# arr off'))
+        off' = off Happy_GHC_Exts.*# 2#
+
+
+
+
+{-# INLINE happyLt #-}
+happyLt x y = LT(x,y)
+
+
+readArrayBit arr bit =
+    Bits.testBit (Happy_GHC_Exts.I# (indexShortOffAddr arr ((unbox_int bit) `Happy_GHC_Exts.iShiftRA#` 4#))) (bit `mod` 16)
+  where unbox_int (Happy_GHC_Exts.I# x) = x
+
+
+
+
+
+
+data HappyAddr = HappyA# Happy_GHC_Exts.Addr#
+
+
+-----------------------------------------------------------------------------
+-- HappyState data type (not arrays)
+
+
+
+newtype HappyState b c = HappyState
+        (Happy_GHC_Exts.Int# ->                    -- token number
+         Happy_GHC_Exts.Int# ->                    -- token number (yes, again)
+         b ->                           -- token semantic value
+         HappyState b c ->              -- current state
+         [HappyState b c] ->            -- state stack
+         c)
+
+
+
+-----------------------------------------------------------------------------
+-- Shifting a token
+
+happyShift new_state 1# tk st sts stk@(x `HappyStk` _) =
+     let i = (case x of { HappyErrorToken (Happy_GHC_Exts.I# (i)) -> i }) in
+--     trace "shifting the error token" $
+     new_state i i tk (HappyState (new_state)) ((st):(sts)) (stk)
+
+happyShift new_state i tk st sts stk =
+     happyNewToken new_state ((st):(sts)) ((HappyTerminal (tk))`HappyStk`stk)
+
+-- happyReduce is specialised for the common cases.
+
+happySpecReduce_0 i fn 1# tk st sts stk
+     = happyFail [] 1# tk st sts stk
+happySpecReduce_0 nt fn j tk st@((HappyState (action))) sts stk
+     = action nt j tk st ((st):(sts)) (fn `HappyStk` stk)
+
+happySpecReduce_1 i fn 1# tk st sts stk
+     = happyFail [] 1# tk st sts stk
+happySpecReduce_1 nt fn j tk _ sts@(((st@(HappyState (action))):(_))) (v1`HappyStk`stk')
+     = let r = fn v1 in
+       happySeq r (action nt j tk st sts (r `HappyStk` stk'))
+
+happySpecReduce_2 i fn 1# tk st sts stk
+     = happyFail [] 1# tk st sts stk
+happySpecReduce_2 nt fn j tk _ ((_):(sts@(((st@(HappyState (action))):(_))))) (v1`HappyStk`v2`HappyStk`stk')
+     = let r = fn v1 v2 in
+       happySeq r (action nt j tk st sts (r `HappyStk` stk'))
+
+happySpecReduce_3 i fn 1# tk st sts stk
+     = happyFail [] 1# tk st sts stk
+happySpecReduce_3 nt fn j tk _ ((_):(((_):(sts@(((st@(HappyState (action))):(_))))))) (v1`HappyStk`v2`HappyStk`v3`HappyStk`stk')
+     = let r = fn v1 v2 v3 in
+       happySeq r (action nt j tk st sts (r `HappyStk` stk'))
+
+happyReduce k i fn 1# tk st sts stk
+     = happyFail [] 1# tk st sts stk
+happyReduce k nt fn j tk st sts stk
+     = case happyDrop (k Happy_GHC_Exts.-# (1# :: Happy_GHC_Exts.Int#)) sts of
+         sts1@(((st1@(HappyState (action))):(_))) ->
+                let r = fn stk in  -- it doesn't hurt to always seq here...
+                happyDoSeq r (action nt j tk st1 sts1 r)
+
+happyMonadReduce k nt fn 1# tk st sts stk
+     = happyFail [] 1# tk st sts stk
+happyMonadReduce k nt fn j tk st sts stk =
+      case happyDrop k ((st):(sts)) of
+        sts1@(((st1@(HappyState (action))):(_))) ->
+          let drop_stk = happyDropStk k stk in
+          happyThen1 (fn stk tk) (\r -> action nt j tk st1 sts1 (r `HappyStk` drop_stk))
+
+happyMonad2Reduce k nt fn 1# tk st sts stk
+     = happyFail [] 1# tk st sts stk
+happyMonad2Reduce k nt fn j tk st sts stk =
+      case happyDrop k ((st):(sts)) of
+        sts1@(((st1@(HappyState (action))):(_))) ->
+         let drop_stk = happyDropStk k stk
+
+
+
+
+
+             _ = nt :: Happy_GHC_Exts.Int#
+             new_state = action
+
+          in
+          happyThen1 (fn stk tk) (\r -> happyNewToken new_state sts1 (r `HappyStk` drop_stk))
+
+happyDrop 0# l = l
+happyDrop n ((_):(t)) = happyDrop (n Happy_GHC_Exts.-# (1# :: Happy_GHC_Exts.Int#)) t
+
+happyDropStk 0# l = l
+happyDropStk n (x `HappyStk` xs) = happyDropStk (n Happy_GHC_Exts.-# (1#::Happy_GHC_Exts.Int#)) xs
+
+-----------------------------------------------------------------------------
+-- Moving to a new state after a reduction
+
+
+
+
+
+
+
+
+
+happyGoto action j tk st = action j j tk (HappyState action)
+
+
+-----------------------------------------------------------------------------
+-- Error recovery (1# is the error token)
+
+-- parse error if we are in recovery and we fail again
+happyFail explist 1# tk old_st _ stk@(x `HappyStk` _) =
+     let i = (case x of { HappyErrorToken (Happy_GHC_Exts.I# (i)) -> i }) in
+--      trace "failing" $ 
+        happyError_ explist i tk
+
+{-  We don't need state discarding for our restricted implementation of
+    "error".  In fact, it can cause some bogus parses, so I've disabled it
+    for now --SDM
+
+-- discard a state
+happyFail  1# tk old_st (((HappyState (action))):(sts)) 
+                                                (saved_tok `HappyStk` _ `HappyStk` stk) =
+--      trace ("discarding state, depth " ++ show (length stk))  $
+        action 1# 1# tk (HappyState (action)) sts ((saved_tok`HappyStk`stk))
+-}
+
+-- Enter error recovery: generate an error token,
+--                       save the old token and carry on.
+happyFail explist i tk (HappyState (action)) sts stk =
+--      trace "entering error recovery" $
+        action 1# 1# tk (HappyState (action)) sts ( (HappyErrorToken (Happy_GHC_Exts.I# (i))) `HappyStk` stk)
+
+-- Internal happy errors:
+
+notHappyAtAll :: a
+notHappyAtAll = error "Internal Happy error\n"
+
+-----------------------------------------------------------------------------
+-- Hack to get the typechecker to accept our action functions
+
+
+happyTcHack :: Happy_GHC_Exts.Int# -> a -> a
+happyTcHack x y = y
+{-# INLINE happyTcHack #-}
+
+
+-----------------------------------------------------------------------------
+-- Seq-ing.  If the --strict flag is given, then Happy emits 
+--      happySeq = happyDoSeq
+-- otherwise it emits
+--      happySeq = happyDontSeq
+
+happyDoSeq, happyDontSeq :: a -> b -> b
+happyDoSeq   a b = a `seq` b
+happyDontSeq a b = b
+
+-----------------------------------------------------------------------------
+-- Don't inline any functions from the template.  GHC has a nasty habit
+-- of deciding to inline happyGoto everywhere, which increases the size of
+-- the generated parser quite a bit.
+
+
+
+
+
+
+
+
+
+{-# NOINLINE happyShift #-}
+{-# NOINLINE happySpecReduce_0 #-}
+{-# NOINLINE happySpecReduce_1 #-}
+{-# NOINLINE happySpecReduce_2 #-}
+{-# NOINLINE happySpecReduce_3 #-}
+{-# NOINLINE happyReduce #-}
+{-# NOINLINE happyMonadReduce #-}
+{-# NOINLINE happyGoto #-}
+{-# NOINLINE happyFail #-}
+
+-- end of Happy Template.
+
diff --git a/happy.cabal b/happy.cabal
index 2819546..9fdf53f 100644
--- a/happy.cabal
+++ b/happy.cabal
@@ -128,12 +128,6 @@ extra-source-files:
         tests/typeclass_monad002.ly
         tests/typeclass_monad_lexer.y
 
-custom-setup
-  setup-depends: Cabal <2.2,
-                 base <5,
-                 directory <1.4,
-                 filepath <1.5
-
 source-repository head
   type:     git
   location: https://github.com/simonmar/happy.git
@@ -148,7 +142,8 @@ executable happy
   build-depends: base < 5,
                  array,
                  containers >= 0.4.2,
-                 mtl >= 2.2.1
+                 mtl >= 2.2.1,
+                 file-embed
                      -- mtl-2.2.1 added Control.Monad.Except
 
   extensions: CPP, MagicHash, FlexibleContexts
@@ -177,4 +172,3 @@ test-suite tests
   type: exitcode-stdio-1.0
   main-is: test.hs
   build-depends: base, process
-
diff --git a/src/Main.lhs b/src/Main.lhs
index ee9a7c4..1a5d361 100644
--- a/src/Main.lhs
+++ b/src/Main.lhs
@@ -39,6 +39,7 @@ Path settings auto-generated by Cabal:
 #if defined(__GLASGOW_HASKELL__)
 > import GHC.Exts ( unsafeCoerce# )
 #endif
+> import Data.List
 
 #if defined(__GLASGOW_HASKELL__)
 > -- XXX What's going on here?!
@@ -198,7 +199,6 @@ of code we should generate, and where it should go:
 
 >       getTarget cli                                   >>= \target ->
 >       getOutputFileName fl_name cli                   >>= \outfilename ->
->       getTemplate getDataDir cli                      >>= \template' ->
 >       getCoerce target cli                            >>= \opt_coerce ->
 >       getStrict cli                                   >>= \opt_strict ->
 >       getGhc cli                                      >>= \opt_ghc ->
@@ -228,7 +228,6 @@ Branch off to GLR parser production
 >       in
 >       if OptGLR `elem` cli
 >       then produceGLRParser outfilename   -- specified output file name
->                             template'     -- template files directory
 >                             action        -- action table (:: ActionTable)
 >                             goto          -- goto table (:: GotoTable)
 >                             header        -- header from grammar spec
@@ -243,11 +242,11 @@ Branch off to GLR parser production
 Resume normal (ie, non-GLR) processing
 
 >       let
->           template = template_file template' target cli opt_coerce in
+>           template = getPureTemplate (template_file target cli opt_coerce) in
 
 Read in the template file for this target:
 
->       readFile template                               >>= \ templ ->
+>       return template                               >>= \ templ ->
 
 and generate the code.
 
@@ -335,13 +334,17 @@ Find unused rules and tokens
 >       actions          = concat (map assocs (elems action_table))
 >       start_rules      = [ 0 .. (length starts' - 1) ]
 >       used_rules       = start_rules ++
->                          nub [ r | (_,a) <- actions, r <- extract_reductions a ]
+>                          nub (foldl' (\x y -> forceList (x ++ y)) [] $ map (\(_,a) -> extract_reductions a) actions)
 >       used_tokens      = errorTok : eof :
 >                              nub [ t | (t,a) <- actions, is_shift a ]
 >       n_prods          = length productions'
 >       unused_terminals = filter (`notElem` used_tokens) terms
 >       unused_rules     = filter (`notElem` used_rules ) [0..n_prods-1]
 
+> forceList :: [a] -> [a]
+> forceList (x:xs) = x `seq` forceList xs
+> forceList _ = []
+
 > is_shift :: LRAction -> Bool
 > is_shift (LR'Shift _ _)             = True
 > is_shift (LR'Multiple _ LR'Shift{}) = True
@@ -475,9 +478,9 @@ How would we like our code to be generated?
 > optToTarget OptArrayTarget    = Just TargetArrayBased
 > optToTarget _                 = Nothing
 
-> template_file :: String -> Target -> [CLIFlags] -> Bool -> String
-> template_file temp_dir target cli _coerce
->   = temp_dir ++ "/HappyTemplate" ++ array_extn ++ ghc_extn ++ debug_extn
+> template_file :: Target -> [CLIFlags] -> Bool -> String
+> template_file target cli _coerce
+>   = "HappyTemplate" ++ array_extn ++ ghc_extn ++ debug_extn
 >  where
 >        ghc_extn   | OptUseCoercions `elem` cli = "-coerce"
 >                   | OptGhcTarget    `elem` cli = "-ghc"
@@ -570,12 +573,6 @@ Extract various command-line options.
 >                               Just j  -> return (Just j)
 >               _many   -> dieHappy "multiple --pretty/-p options\n"
 
-> getTemplate :: IO String -> [CLIFlags] -> IO String
-> getTemplate def cli
->       = case [ s | (OptTemplate s) <- cli ] of
->               []         -> def
->               f:fs       -> return (last (f:fs))
-
 > getMagicName :: [CLIFlags] -> IO (Maybe String)
 > getMagicName cli
 >       = case [ s | (OptMagicName s) <- cli ] of
diff --git a/src/ParseMonad.hs b/src/ParseMonad.hs
index 6214819..a2bf12e 100644
--- a/src/ParseMonad.hs
+++ b/src/ParseMonad.hs
@@ -1,6 +1,7 @@
 module ParseMonad where
 
 import Control.Monad.Reader
+import Data.Function
 
 type ParseResult = Either String
 type P a = ReaderT (String, Int) ParseResult a
@@ -13,3 +14,6 @@ runP f s l = runReaderT f (s, l)
 
 lineP :: P Int
 lineP = asks snd >>= return
+
+trampolineP :: P a -> P a
+trampolineP p = ReaderT $ \r -> trampoline $ runReaderT p r
diff --git a/src/Parser.hs b/src/Parser.hs
index 48f3262..7cb37f9 100644
--- a/src/Parser.hs
+++ b/src/Parser.hs
@@ -730,7 +730,7 @@ happyError' :: () => (Token) -> P a
 happyError' tk = (\token -> happyError) tk
 
 ourParser = happySomeParser where
-  happySomeParser = happyThen (happyParse 0#) (\x -> happyReturn (happyOut4 x))
+  happySomeParser = happyThen (trampolineP (happyParse 0#)) (\x -> happyReturn (happyOut4 x))
 
 happySeq = happyDontSeq
 
diff --git a/src/ProduceGLRCode.lhs b/src/ProduceGLRCode.lhs
index 2c8984b..8cfb257 100644
--- a/src/ProduceGLRCode.lhs
+++ b/src/ProduceGLRCode.lhs
@@ -7,7 +7,9 @@ This module is designed as an extension to the Haskell parser generator Happy.
         -- extension to semantic rules, and various optimisations
 %-----------------------------------------------------------------------------
 
+> {-# LANGUAGE TemplateHaskell #-}
 > module ProduceGLRCode ( produceGLRParser
+>                       , getPureTemplate
 >                       , DecodeOption(..)
 >                       , FilterOption(..)
 >                       , GhcExts(..)
@@ -22,13 +24,14 @@ This module is designed as an extension to the Haskell parser generator Happy.
 > import Data.Char ( isSpace, isAlphaNum )
 > import Data.List ( nub, (\\), sort, find, tails )
 > import Data.Version ( showVersion )
+> import Data.FileEmbed
 
 %-----------------------------------------------------------------------------
 File and Function Names
 
-> base_template, lib_template :: String -> String
-> base_template td = td ++ "/GLR_Base"          -- NB Happy uses / too
-> lib_template  td = td ++ "/GLR_Lib"           -- Windows accepts this?
+> base_template, lib_template :: String
+> base_template = "GLR_Base"          -- NB Happy uses / too
+> lib_template  = "GLR_Lib"           -- Windows accepts this?
 
 ---
 prefix for production names, to avoid name clashes
@@ -76,7 +79,6 @@ Main exported function
 
 > produceGLRParser
 >        :: FilePath      -- Output file name
->        -> String        -- Templates directory
 >        -> ActionTable   -- LR tables
 >        -> GotoTable     -- LR tables
 >        -> Maybe String  -- Module header
@@ -85,7 +87,7 @@ Main exported function
 >        -> Grammar       -- Happy Grammar
 >        -> IO ()
 
-> produceGLRParser outfilename template_dir action goto header trailer options g
+> produceGLRParser outfilename action goto header trailer options g
 >  = do
 >     let basename  = takeWhile (/='.') outfilename
 >     let tbls  = (action,goto)
@@ -96,7 +98,7 @@ Main exported function
 >                                    putStrLn "Defaulting to first start point."
 >                                    return s
 >                          [] -> error "produceGLRParser: []"
->     mkFiles basename tbls parseName template_dir header trailer options g
+>     mkFiles basename tbls parseName header trailer options g
 
 
 %-----------------------------------------------------------------------------
@@ -108,24 +110,23 @@ the driver and data strs (large template).
 >        -> (ActionTable
 >           ,GotoTable)   -- LR tables
 >        -> String        -- Start parse function name
->        -> String        -- Templates directory
 >        -> Maybe String  -- Module header
 >        -> Maybe String  -- User-defined stuff (token DT, lexer etc.)
 >        -> (DebugMode,Options)       -- selecting code-gen style
 >        -> Grammar       -- Happy Grammar
 >        -> IO ()
 >
-> mkFiles basename tables start templdir header trailer (debug,options) g
+> mkFiles basename tables start header trailer (debug,options) g
 >  = do
 >       let debug_ext = if debug then "-debug" else ""
 >       let (ext,imps,opts) = case ghcExts_opt of
 >                               UseGhcExts is os -> ("-ghc", is, os)
 >                               _                -> ("", "", "")
->       base <- readFile (base_template templdir)
+>       let base = getPureTemplate base_template
 >       --writeFile (basename ++ ".si") (unlines $ map show sem_info)
 >       writeFile (basename ++ "Data.hs") (content base opts $ "")
 
->       lib <- readFile (lib_template templdir ++ ext ++ debug_ext)
+>       let lib = getPureTemplate (lib_template ++ ext ++ debug_ext)
 >       writeFile (basename ++ ".hs") (lib_content imps opts lib)
 >  where
 >   (_,_,ghcExts_opt) = options
@@ -729,3 +730,28 @@ remove Happy-generated start symbols.
 
 > mkHappyVar :: Int -> String -> String
 > mkHappyVar n = str "happy_var_" . shows n
+
+---
+
+> getPureTemplate :: FilePath -> String
+> getPureTemplate template = case lookup template templates of
+>   Just contents -> contents
+>   Nothing -> error $ "Template " ++ template ++ " not found!"
+
+---
+
+> templates :: [(FilePath, String)]
+> templates = [
+>   ("GLR_Base", $(embedStringFile "data/GLR_Base")),
+>   ("GLR_Lib", $(embedStringFile "data/GLR_Lib")),
+>   ("GLR_Lib-ghc", $(embedStringFile "data/GLR_Lib-ghc")),
+>   ("GLR_Lib-ghc-debug", $(embedStringFile "data/GLR_Lib-ghc-debug")),
+>   ("HappyTemplate", $(embedStringFile "data/HappyTemplate")),
+>   ("HappyTemplate-arrays", $(embedStringFile "data/HappyTemplate-arrays")),
+>   ("HappyTemplate-arrays-coerce", $(embedStringFile "data/HappyTemplate-arrays-coerce")),
+>   ("HappyTemplate-arrays-coerce-debug", $(embedStringFile "data/HappyTemplate-arrays-coerce-debug")),
+>   ("HappyTemplate-arrays-debug", $(embedStringFile "data/HappyTemplate-arrays-debug")),
+>   ("HappyTemplate-arrays-ghc", $(embedStringFile "data/HappyTemplate-arrays-ghc")),
+>   ("HappyTemplate-arrays-ghc-debug", $(embedStringFile "data/HappyTemplate-arrays-ghc-debug")),
+>   ("HappyTemplate-coerce", $(embedStringFile "data/HappyTemplate-coerce")),
+>   ("HappyTemplate-ghc", $(embedStringFile "data/HappyTemplate-ghc")) ]
-- 
2.7.4 (Apple Git-66)

