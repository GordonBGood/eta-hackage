From e160b7413037721053129502d0157590ed6cb9bd Mon Sep 17 00:00:00 2001
From: Rahul Muttineni <rahulmutt@gmail.com>
Date: Sun, 25 Mar 2018 21:59:01 +0530
Subject: [PATCH] Patched

---
 Network.hs                            |   49 +-
 Network/BSD.hs                        |  393 ++++++++
 Network/BSD.hsc                       |  589 ------------
 Network/Socket.hs                     | 1491 +++++++++++++++++++++++++++++
 Network/Socket.hsc                    | 1683 ---------------------------------
 Network/Socket/ByteString.hs          |  263 ++++++
 Network/Socket/ByteString.hsc         |  338 -------
 Network/Socket/ByteString/Internal.hs |   21 -
 Network/Socket/ByteString/Lazy.hs     |    4 -
 Network/Socket/Internal.hs            |  268 ++++++
 Network/Socket/Internal.hsc           |  274 ------
 Network/Socket/Types.hs               | 1001 ++++++++++++++++++++
 Network/Socket/Types.hsc              | 1111 ----------------------
 include/HsNet.h                       |  359 +++----
 include/HsNetworkConfig.h             |  178 ----
 java/Utils.java                       |  181 ++++
 network.cabal                         |   26 +-
 17 files changed, 3816 insertions(+), 4413 deletions(-)
 create mode 100644 Network/BSD.hs
 delete mode 100644 Network/BSD.hsc
 create mode 100644 Network/Socket.hs
 delete mode 100644 Network/Socket.hsc
 create mode 100644 Network/Socket/ByteString.hs
 delete mode 100644 Network/Socket/ByteString.hsc
 create mode 100644 Network/Socket/Internal.hs
 delete mode 100644 Network/Socket/Internal.hsc
 create mode 100644 Network/Socket/Types.hs
 delete mode 100644 Network/Socket/Types.hsc
 delete mode 100644 include/HsNetworkConfig.h
 create mode 100644 java/Utils.java

diff --git a/Network.hs b/Network.hs
index 8fb8d92..38006df 100644
--- a/Network.hs
+++ b/Network.hs
@@ -17,7 +17,7 @@
 --
 -----------------------------------------------------------------------------
 
-#include "HsNetworkConfig.h"
+#include "HsNet.h"
 
 #ifdef HAVE_GETADDRINFO
 -- Use IPv6-capable function definitions if the OS supports it.
@@ -61,13 +61,14 @@ module Network
 
 import Control.Monad (liftM)
 import Data.Maybe (fromJust)
-import Network.BSD
 import Network.Socket hiding (accept, socketPort, recvFrom,
-                              sendTo, PortNumber, sClose)
-import qualified Network.Socket as Socket (accept)
+                              sendTo, sClose)
+import qualified Network.Socket as Socket
+import qualified Network.Socket.Types as Socket
 import System.IO
 import Prelude
 import qualified Control.Exception as Exception
+import Data.Word(Word32)
 
 -- ---------------------------------------------------------------------------
 -- High Level ``Setup'' functions
@@ -104,9 +105,9 @@ connectTo hostname (PortNumber port) = connect' "Network.connectTo" hostname (sh
 -- IPv4 only.
 
 connectTo hostname (Service serv) = do
-    proto <- getProtocolNumber "tcp"
+    -- proto <- getProtocolNumber "tcp"
     bracketOnError
-        (socket AF_INET Stream proto)
+        (socket AF_INET Stream 6)
         (sClose)  -- only done if there's an error
         (\sock -> do
           port  <- getServicePortNumber serv
@@ -142,9 +143,9 @@ connectTo _ (UnixSocket path) = do
 connect' :: String -> HostName -> ServiceName -> IO Handle
 
 connect' caller host serv = do
-    proto <- getProtocolNumber "tcp"
+    -- proto <- getProtocolNumber "tcp"
     let hints = defaultHints { addrFlags = [AI_ADDRCONFIG]
-                             , addrProtocol = proto
+                             , addrProtocol = 6
                              , addrSocketType = Stream }
     addrs <- getAddrInfo (Just hints) (Just host) (Just serv)
     firstSuccessful caller $ map tryToConnect addrs
@@ -230,13 +231,13 @@ listenOn (UnixSocket path) =
 listen' :: ServiceName -> IO Socket
 
 listen' serv = do
-    proto <- getProtocolNumber "tcp"
+    -- proto <- getProtocolNumber "tcp"
     -- We should probably specify addrFamily = AF_INET6 and the filter
     -- code below should be removed. AI_ADDRCONFIG is probably not
     -- necessary. But this code is well-tested. So, let's keep it.
     let hints = defaultHints { addrFlags = [AI_ADDRCONFIG, AI_PASSIVE]
-                             , addrSocketType = Stream
-                             , addrProtocol = proto }
+                             , addrSocketType = ServerSocket Stream
+                             , addrProtocol = 6 }
     addrs <- getAddrInfo (Just hints) Nothing (Just serv)
     -- Choose an IPv6 socket if exists.  This ensures the socket can
     -- handle both IPv4 and IPv6 if v6only is false.
@@ -274,10 +275,7 @@ accept :: Socket                -- ^ Listening Socket
 accept sock@(MkSocket _ AF_INET _ _ _) = do
  ~(sock', (SockAddrInet port haddr)) <- Socket.accept sock
  peer <- catchIO
-          (do
-             (HostEntry peer _ _ _) <- getHostByAddr AF_INET haddr
-             return peer
-          )
+          (getHostByAddr haddr)
           (\_e -> inet_ntoa haddr)
                 -- if getHostByName fails, we fall back to the IP address
  handle <- socketToHandle sock' ReadWriteMode
@@ -350,9 +348,9 @@ recvFrom :: HostName    -- Hostname
 
 #if defined(IPV6_SOCKET_SUPPORT)
 recvFrom host port = do
-    proto <- getProtocolNumber "tcp"
+    -- proto <- getProtocolNumber "tcp"
     let hints = defaultHints { addrFlags = [AI_ADDRCONFIG]
-                             , addrProtocol = proto
+                             , addrProtocol = 6
                              , addrSocketType = Stream }
     allowed <- map addrAddress `liftM` getAddrInfo (Just hints) (Just host)
                                                    Nothing
@@ -373,14 +371,14 @@ recvFrom host port = do
     _ `oneOf` _ = False
 #else
 recvFrom host port = do
- ip  <- getHostByName host
- let ipHs = hostAddresses ip
+ ip  <- getHostsByName host
+ let ipHs = fromJava ip
  s   <- listenOn port
  let
   waiting = do
      ~(s', SockAddrInet _ haddr)  <-  Socket.accept s
-     he <- getHostByAddr AF_INET haddr
-     if not (any (`elem` ipHs) (hostAddresses he))
+     addresses <- getHostsByAddr haddr
+     if not (any (`elem` ipHs) addresses)
       then do
          sClose s'
          waiting
@@ -476,3 +474,12 @@ firstSuccessful caller = go Nothing
   -- All operations failed, throw error if one exists
   go Nothing  [] = ioError $ userError $ caller ++ ": firstSuccessful: empty list"
   go (Just e) [] = Exception.throwIO e
+
+foreign import java unsafe "@static eta.network.Utils.getHostByAddr"
+  getHostByAddr :: Word32 -> IO String
+
+-- foreign import java unsafe "@static java.net.InetAddess.getAllByName"
+--   getHostsByName :: String -> IO Socket.InetAddressArray
+
+-- foreign import java unsafe "@static eta.network.Utils.getHostsByAddr"
+--   getHostsByAddr :: Word32 -> IO Socket.InetAddressArray
diff --git a/Network/BSD.hs b/Network/BSD.hs
new file mode 100644
index 0000000..5b78bd8
--- /dev/null
+++ b/Network/BSD.hs
@@ -0,0 +1,393 @@
+{-# LANGUAGE CPP, ForeignFunctionInterface #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Network.BSD
+-- Copyright   :  (c) The University of Glasgow 2001
+-- License     :  BSD-style (see the file libraries/network/LICENSE)
+--
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  experimental
+-- Portability :  non-portable
+--
+-- The "Network.BSD" module defines Haskell bindings to network
+-- programming functionality provided by BSD Unix derivatives.
+--
+-----------------------------------------------------------------------------
+
+#include "HsNet.h"
+
+module Network.BSD
+    (
+    -- * Host names
+      HostName
+    , getHostName
+
+    , HostEntry(..)
+    , getHostByName
+    , getHostByAddr
+    , hostAddress
+
+#if defined(HAVE_GETHOSTENT) && !defined(mingw32_HOST_OS)
+    , getHostEntries
+
+    -- ** Low level functionality
+    , setHostEntry
+    , getHostEntry
+    , endHostEntry
+#endif
+
+    -- * Service names
+    , ServiceEntry(..)
+    , ServiceName
+    , getServiceByName
+    , getServiceByPort
+    , getServicePortNumber
+
+#if !defined(mingw32_HOST_OS)
+    , getServiceEntries
+
+    -- ** Low level functionality
+    , getServiceEntry
+    , setServiceEntry
+    , endServiceEntry
+#endif
+
+    -- * Protocol names
+    , ProtocolName
+    , ProtocolNumber
+    , ProtocolEntry(..)
+    , getProtocolByName
+    , getProtocolByNumber
+    , getProtocolNumber
+    , defaultProtocol
+
+#if !defined(mingw32_HOST_OS)
+    , getProtocolEntries
+    -- ** Low level functionality
+    , setProtocolEntry
+    , getProtocolEntry
+    , endProtocolEntry
+#endif
+
+    -- * Port numbers
+    , PortNumber
+
+    -- * Network names
+    , NetworkName
+    , NetworkAddr
+    , NetworkEntry(..)
+
+#if !defined(mingw32_HOST_OS)
+    , getNetworkByName
+    , getNetworkByAddr
+    , getNetworkEntries
+    -- ** Low level functionality
+    , setNetworkEntry
+    , getNetworkEntry
+    , endNetworkEntry
+#endif
+
+#if defined(HAVE_IF_NAMETOINDEX)
+    -- * Interface names
+    , ifNameToIndex
+#endif
+
+    ) where
+
+import Network.Socket
+
+import Control.Concurrent (MVar, newMVar, withMVar)
+import qualified Control.Exception as E
+import Foreign.C.String (CString, peekCString, withCString)
+#if defined(HAVE_WINSOCK2_H)
+import Foreign.C.Types ( CShort )
+#endif
+import Foreign.C.Types ( CInt(..), CUInt(..), CULong(..), CSize(..) )
+import Foreign.Ptr (Ptr, nullPtr)
+import Foreign.Storable (Storable(..))
+import Foreign.Marshal.Array (allocaArray0, peekArray0)
+import Foreign.Marshal.Utils (with, fromBool)
+import Data.Typeable
+import System.IO.Error (ioeSetErrorString, mkIOError)
+import System.IO.Unsafe (unsafePerformIO)
+
+import GHC.IO.Exception
+
+import Control.Monad (liftM)
+
+import Network.Socket.Internal (throwSocketErrorIfMinus1_)
+
+-- ---------------------------------------------------------------------------
+-- Basic Types
+
+type ProtocolName = String
+
+-- ---------------------------------------------------------------------------
+-- Service Database Access
+
+-- Calling getServiceByName for a given service and protocol returns
+-- the systems service entry.  This should be used to find the port
+-- numbers for standard protocols such as SMTP and FTP.  The remaining
+-- three functions should be used for browsing the service database
+-- sequentially.
+
+-- Calling setServiceEntry with True indicates that the service
+-- database should be left open between calls to getServiceEntry.  To
+-- close the database a call to endServiceEntry is required.  This
+-- database file is usually stored in the file /etc/services.
+
+data ServiceEntry  =
+  ServiceEntry  {
+     serviceName     :: ServiceName,    -- Official Name
+     serviceAliases  :: [ServiceName],  -- aliases
+     servicePort     :: PortNumber,     -- Port Number  ( network byte order )
+     serviceProtocol :: ProtocolName    -- Protocol
+  } deriving (Show, Typeable)
+
+-- | Get service by name.
+getServiceByName :: ServiceName         -- Service Name
+                 -> ProtocolName        -- Protocol Name
+                 -> IO ServiceEntry     -- Service Entry
+getServiceByName name proto = error "getServiceByName: Not implemented yet."
+
+-- | Get the service given a 'PortNumber' and 'ProtocolName'.
+getServiceByPort :: PortNumber -> ProtocolName -> IO ServiceEntry
+getServiceByPort port proto = error "getServiceByPort: Not implemented yet."
+
+-- | Get the 'PortNumber' corresponding to the 'ServiceName'.
+getServicePortNumber :: ServiceName -> IO PortNumber
+getServicePortNumber name = error "getServiceByPort: Not implemented yet."
+
+#if !defined(mingw32_HOST_OS)
+getServiceEntry :: IO ServiceEntry
+getServiceEntry = error "getServiceEntry: Not implemented yet."
+
+setServiceEntry :: Bool -> IO ()
+setServiceEntry flg = error "setServiceEntry: Not implemented yet."
+
+endServiceEntry :: IO ()
+endServiceEntry = error "endServiceEntry: Not implemented yet."
+
+getServiceEntries :: Bool -> IO [ServiceEntry]
+getServiceEntries stayOpen = do
+  setServiceEntry stayOpen
+  getEntries (getServiceEntry) (endServiceEntry)
+#endif
+
+-- ---------------------------------------------------------------------------
+-- Protocol Entries
+
+-- The following relate directly to the corresponding UNIX C
+-- calls for returning the protocol entries. The protocol entry is
+-- represented by the Haskell type ProtocolEntry.
+
+-- As for setServiceEntry above, calling setProtocolEntry.
+-- determines whether or not the protocol database file, usually
+-- @/etc/protocols@, is to be kept open between calls of
+-- getProtocolEntry. Similarly,
+
+data ProtocolEntry =
+  ProtocolEntry  {
+     protoName    :: ProtocolName,      -- Official Name
+     protoAliases :: [ProtocolName],    -- aliases
+     protoNumber  :: ProtocolNumber     -- Protocol Number
+  } deriving (Read, Show, Typeable)
+
+getProtocolByName :: ProtocolName -> IO ProtocolEntry
+getProtocolByName name = error "getProtocolByName: Not implemented yet."
+
+getProtocolByNumber :: ProtocolNumber -> IO ProtocolEntry
+getProtocolByNumber num = error "getProtocolByNumber: Not implemented yet."
+
+-- TODO: The protocol number is currently unusued so this
+--       should be OK.
+getProtocolNumber :: ProtocolName -> IO ProtocolNumber
+getProtocolNumber "tcp" = return 6
+getProtocolNumber _ = error "getProtocolNumber: Not implemented yet for non-tcp protocols."
+
+#if !defined(mingw32_HOST_OS)
+getProtocolEntry :: IO ProtocolEntry    -- Next Protocol Entry from DB
+getProtocolEntry = error "getProtocolEntry: Not implemented yet."
+
+setProtocolEntry :: Bool -> IO ()       -- Keep DB Open ?
+setProtocolEntry flg = error "setProtocolEntry: Not implemented yet."
+
+endProtocolEntry :: IO ()
+endProtocolEntry = error "endProtocolEntry: Not implemented yet."
+
+getProtocolEntries :: Bool -> IO [ProtocolEntry]
+getProtocolEntries stayOpen = withLock $ do
+  setProtocolEntry stayOpen
+  getEntries (getProtocolEntry) (endProtocolEntry)
+#endif
+
+-- ---------------------------------------------------------------------------
+-- Host lookups
+
+data HostEntry =
+  HostEntry  {
+     hostName      :: HostName,         -- Official Name
+     hostAliases   :: [HostName],       -- aliases
+     hostFamily    :: Family,           -- Host Type (currently AF_INET)
+     hostAddresses :: [HostAddress]     -- Set of Network Addresses  (in network byte order)
+  } deriving (Read, Show, Typeable)
+
+-- convenience function:
+hostAddress :: HostEntry -> HostAddress
+hostAddress (HostEntry nm _ _ ls) =
+ case ls of
+   []    -> error $ "Network.BSD.hostAddress: empty network address list for " ++ nm
+   (x:_) -> x
+
+-- getHostByName must use the same lock as the *hostent functions
+-- may cause problems if called concurrently.
+
+-- | Resolve a 'HostName' to IPv4 address.
+getHostByName :: HostName -> IO HostEntry
+getHostByName name = error "getHostByName: Not implemented yet."
+
+-- The locking of gethostbyaddr is similar to gethostbyname.
+-- | Get a 'HostEntry' corresponding to the given address and family.
+-- Note that only IPv4 is currently supported.
+getHostByAddr :: Family -> HostAddress -> IO HostEntry
+getHostByAddr family addr = error "getHostByAddr: Not implemented yet."
+
+#if defined(HAVE_GETHOSTENT) && !defined(mingw32_HOST_OS)
+getHostEntry :: IO HostEntry
+getHostEntry = withLock $ do
+ throwNoSuchThingIfNull "Network.BSD.getHostEntry" "unable to retrieve host entry"
+   $ c_gethostent
+ >>= peek
+
+foreign import ccall unsafe "gethostent" c_gethostent :: IO (Ptr HostEntry)
+
+setHostEntry :: Bool -> IO ()
+setHostEntry flg = withLock $ c_sethostent (fromBool flg)
+
+foreign import ccall unsafe "sethostent" c_sethostent :: CInt -> IO ()
+
+endHostEntry :: IO ()
+endHostEntry = withLock $ c_endhostent
+
+foreign import ccall unsafe "endhostent" c_endhostent :: IO ()
+
+getHostEntries :: Bool -> IO [HostEntry]
+getHostEntries stayOpen = do
+  setHostEntry stayOpen
+  getEntries (getHostEntry) (endHostEntry)
+#endif
+
+-- ---------------------------------------------------------------------------
+-- Accessing network information
+
+-- Same set of access functions as for accessing host,protocol and
+-- service system info, this time for the types of networks supported.
+
+-- network addresses are represented in host byte order.
+type NetworkAddr = CULong
+
+type NetworkName = String
+
+data NetworkEntry =
+  NetworkEntry {
+     networkName        :: NetworkName,   -- official name
+     networkAliases     :: [NetworkName], -- aliases
+     networkFamily      :: Family,         -- type
+     networkAddress     :: NetworkAddr
+   } deriving (Read, Show, Typeable)
+
+
+#if !defined(mingw32_HOST_OS)
+getNetworkByName :: NetworkName -> IO NetworkEntry
+getNetworkByName name = error "getNetworkByName: Not implemented yet."
+
+getNetworkByAddr :: NetworkAddr -> Family -> IO NetworkEntry
+getNetworkByAddr addr family = error "getNetworkByAddr: Not implemented yet."
+
+getNetworkEntry :: IO NetworkEntry
+getNetworkEntry = error "getNetworkByEntry: Not implemented yet."
+
+-- | Open the network name database. The parameter specifies
+-- whether a connection is maintained open between various
+-- networkEntry calls
+setNetworkEntry :: Bool -> IO ()
+setNetworkEntry flg = error "setNetworkEntry: Not implemented yet."
+
+-- | Close the connection to the network name database.
+endNetworkEntry :: IO ()
+endNetworkEntry = error "endNetworkEntry: Not implemented yet."
+
+-- | Get the list of network entries.
+getNetworkEntries :: Bool -> IO [NetworkEntry]
+getNetworkEntries stayOpen = do
+  setNetworkEntry stayOpen
+  getEntries (getNetworkEntry) (endNetworkEntry)
+#endif
+
+-- ---------------------------------------------------------------------------
+-- Interface names
+
+#if defined(HAVE_IF_NAMETOINDEX)
+
+-- returns the index of the network interface corresponding to the name ifname.
+ifNameToIndex :: String -> IO (Maybe Int)
+ifNameToIndex ifname = do
+  index <- withCString ifname c_if_nametoindex
+  -- On failure zero is returned. We'll return Nothing.
+  return $ if index == 0 then Nothing else Just $ fromIntegral index
+
+foreign import CALLCONV safe "if_nametoindex"
+   c_if_nametoindex :: CString -> IO CUInt
+
+#endif
+
+
+-- Mutex for name service lockdown
+
+{-# NOINLINE lock #-}
+lock :: MVar ()
+lock = unsafePerformIO $ withSocketsDo $ newMVar ()
+
+withLock :: IO a -> IO a
+withLock act = withMVar lock (\_ -> act)
+
+-- ---------------------------------------------------------------------------
+-- Miscellaneous Functions
+
+-- | Calling getHostName returns the standard host name for the current
+-- processor, as set at boot time.
+
+getHostName :: IO HostName
+getHostName = error "getHostName: Not implemented yet."
+
+-- Helper function used by the exported functions that provides a
+-- Haskellised view of the enumerator functions:
+
+getEntries :: IO a  -- read
+           -> IO () -- at end
+           -> IO [a]
+getEntries getOne atEnd = loop
+  where
+    loop = do
+      vv <- E.catch (liftM Just getOne)
+            (\ e -> let _types = e :: IOException in return Nothing)
+      case vv of
+        Nothing -> return []
+        Just v  -> loop >>= \ vs -> atEnd >> return (v:vs)
+
+
+throwNoSuchThingIfNull :: String -> String -> IO (Ptr a) -> IO (Ptr a)
+throwNoSuchThingIfNull loc desc act = do
+  ptr <- act
+  if (ptr == nullPtr)
+   then ioError (ioeSetErrorString (mkIOError NoSuchThing loc Nothing Nothing) desc)
+   else return ptr
+
+throwUnsupportedOperationPoke :: String -> Ptr a -> a -> IO ()
+throwUnsupportedOperationPoke typ _ _ =
+  ioError $ ioeSetErrorString ioe "Operation not implemented"
+  where
+    ioe = mkIOError UnsupportedOperation
+                    ("Network.BSD: instance Storable " ++ typ ++ ": poke")
+                    Nothing
+                    Nothing
diff --git a/Network/BSD.hsc b/Network/BSD.hsc
deleted file mode 100644
index 8d38dab..0000000
--- a/Network/BSD.hsc
+++ /dev/null
@@ -1,589 +0,0 @@
-{-# LANGUAGE CPP, ForeignFunctionInterface #-}
------------------------------------------------------------------------------
--- |
--- Module      :  Network.BSD
--- Copyright   :  (c) The University of Glasgow 2001
--- License     :  BSD-style (see the file libraries/network/LICENSE)
---
--- Maintainer  :  libraries@haskell.org
--- Stability   :  experimental
--- Portability :  non-portable
---
--- The "Network.BSD" module defines Haskell bindings to network
--- programming functionality provided by BSD Unix derivatives.
---
------------------------------------------------------------------------------
-
-#include "HsNet.h"
-
-module Network.BSD
-    (
-    -- * Host names
-      HostName
-    , getHostName
-
-    , HostEntry(..)
-    , getHostByName
-    , getHostByAddr
-    , hostAddress
-
-#if defined(HAVE_GETHOSTENT) && !defined(mingw32_HOST_OS)
-    , getHostEntries
-
-    -- ** Low level functionality
-    , setHostEntry
-    , getHostEntry
-    , endHostEntry
-#endif
-
-    -- * Service names
-    , ServiceEntry(..)
-    , ServiceName
-    , getServiceByName
-    , getServiceByPort
-    , getServicePortNumber
-
-#if !defined(mingw32_HOST_OS)
-    , getServiceEntries
-
-    -- ** Low level functionality
-    , getServiceEntry
-    , setServiceEntry
-    , endServiceEntry
-#endif
-
-    -- * Protocol names
-    , ProtocolName
-    , ProtocolNumber
-    , ProtocolEntry(..)
-    , getProtocolByName
-    , getProtocolByNumber
-    , getProtocolNumber
-    , defaultProtocol
-
-#if !defined(mingw32_HOST_OS)
-    , getProtocolEntries
-    -- ** Low level functionality
-    , setProtocolEntry
-    , getProtocolEntry
-    , endProtocolEntry
-#endif
-
-    -- * Port numbers
-    , PortNumber
-
-    -- * Network names
-    , NetworkName
-    , NetworkAddr
-    , NetworkEntry(..)
-
-#if !defined(mingw32_HOST_OS)
-    , getNetworkByName
-    , getNetworkByAddr
-    , getNetworkEntries
-    -- ** Low level functionality
-    , setNetworkEntry
-    , getNetworkEntry
-    , endNetworkEntry
-#endif
-
-#if defined(HAVE_IF_NAMETOINDEX)
-    -- * Interface names
-    , ifNameToIndex
-#endif
-
-    ) where
-
-import Network.Socket
-
-import Control.Concurrent (MVar, newMVar, withMVar)
-import qualified Control.Exception as E
-import Foreign.C.String (CString, peekCString, withCString)
-#if defined(HAVE_WINSOCK2_H)
-import Foreign.C.Types ( CShort )
-#endif
-import Foreign.C.Types ( CInt(..), CUInt(..), CULong(..), CSize(..) )
-import Foreign.Ptr (Ptr, nullPtr)
-import Foreign.Storable (Storable(..))
-import Foreign.Marshal.Array (allocaArray0, peekArray0)
-import Foreign.Marshal.Utils (with, fromBool)
-import Data.Typeable
-import System.IO.Error (ioeSetErrorString, mkIOError)
-import System.IO.Unsafe (unsafePerformIO)
-
-import GHC.IO.Exception
-
-import Control.Monad (liftM)
-
-import Network.Socket.Internal (throwSocketErrorIfMinus1_)
-
--- ---------------------------------------------------------------------------
--- Basic Types
-
-type ProtocolName = String
-
--- ---------------------------------------------------------------------------
--- Service Database Access
-
--- Calling getServiceByName for a given service and protocol returns
--- the systems service entry.  This should be used to find the port
--- numbers for standard protocols such as SMTP and FTP.  The remaining
--- three functions should be used for browsing the service database
--- sequentially.
-
--- Calling setServiceEntry with True indicates that the service
--- database should be left open between calls to getServiceEntry.  To
--- close the database a call to endServiceEntry is required.  This
--- database file is usually stored in the file /etc/services.
-
-data ServiceEntry  =
-  ServiceEntry  {
-     serviceName     :: ServiceName,    -- Official Name
-     serviceAliases  :: [ServiceName],  -- aliases
-     servicePort     :: PortNumber,     -- Port Number  ( network byte order )
-     serviceProtocol :: ProtocolName    -- Protocol
-  } deriving (Show, Typeable)
-
-instance Storable ServiceEntry where
-   sizeOf    _ = #const sizeof(struct servent)
-   alignment _ = alignment (undefined :: CInt) -- ???
-
-   peek p = do
-        s_name    <- (#peek struct servent, s_name) p >>= peekCString
-        s_aliases <- (#peek struct servent, s_aliases) p
-                           >>= peekArray0 nullPtr
-                           >>= mapM peekCString
-        s_port    <- (#peek struct servent, s_port) p
-        s_proto   <- (#peek struct servent, s_proto) p >>= peekCString
-        return (ServiceEntry {
-                        serviceName     = s_name,
-                        serviceAliases  = s_aliases,
-#if defined(HAVE_WINSOCK2_H)
-                        servicePort     = (fromIntegral (s_port :: CShort)),
-#else
-                           -- s_port is already in network byte order, but it
-                           -- might be the wrong size.
-                        servicePort     = (fromIntegral (s_port :: CInt)),
-#endif
-                        serviceProtocol = s_proto
-                })
-
-   poke = throwUnsupportedOperationPoke "ServiceEntry"
-
-
--- | Get service by name.
-getServiceByName :: ServiceName         -- Service Name
-                 -> ProtocolName        -- Protocol Name
-                 -> IO ServiceEntry     -- Service Entry
-getServiceByName name proto = withLock $ do
- withCString name  $ \ cstr_name  -> do
- withCString proto $ \ cstr_proto -> do
- throwNoSuchThingIfNull "Network.BSD.getServiceByName" "no such service entry"
-   $ c_getservbyname cstr_name cstr_proto
- >>= peek
-
-foreign import CALLCONV unsafe "getservbyname"
-  c_getservbyname :: CString -> CString -> IO (Ptr ServiceEntry)
-
--- | Get the service given a 'PortNumber' and 'ProtocolName'.
-getServiceByPort :: PortNumber -> ProtocolName -> IO ServiceEntry
-getServiceByPort port proto = withLock $ do
- withCString proto $ \ cstr_proto -> do
- throwNoSuchThingIfNull "Network.BSD.getServiceByPort" "no such service entry"
-   $ c_getservbyport (fromIntegral port) cstr_proto
- >>= peek
-
-foreign import CALLCONV unsafe "getservbyport"
-  c_getservbyport :: CInt -> CString -> IO (Ptr ServiceEntry)
-
--- | Get the 'PortNumber' corresponding to the 'ServiceName'.
-getServicePortNumber :: ServiceName -> IO PortNumber
-getServicePortNumber name = do
-    (ServiceEntry _ _ port _) <- getServiceByName name "tcp"
-    return port
-
-#if !defined(mingw32_HOST_OS)
-getServiceEntry :: IO ServiceEntry
-getServiceEntry = withLock $ do
- throwNoSuchThingIfNull "Network.BSD.getServiceEntry" "no such service entry"
-   $ c_getservent
- >>= peek
-
-foreign import ccall unsafe "getservent" c_getservent :: IO (Ptr ServiceEntry)
-
-setServiceEntry :: Bool -> IO ()
-setServiceEntry flg = withLock $ c_setservent (fromBool flg)
-
-foreign import ccall unsafe  "setservent" c_setservent :: CInt -> IO ()
-
-endServiceEntry :: IO ()
-endServiceEntry = withLock $ c_endservent
-
-foreign import ccall unsafe  "endservent" c_endservent :: IO ()
-
-getServiceEntries :: Bool -> IO [ServiceEntry]
-getServiceEntries stayOpen = do
-  setServiceEntry stayOpen
-  getEntries (getServiceEntry) (endServiceEntry)
-#endif
-
--- ---------------------------------------------------------------------------
--- Protocol Entries
-
--- The following relate directly to the corresponding UNIX C
--- calls for returning the protocol entries. The protocol entry is
--- represented by the Haskell type ProtocolEntry.
-
--- As for setServiceEntry above, calling setProtocolEntry.
--- determines whether or not the protocol database file, usually
--- @/etc/protocols@, is to be kept open between calls of
--- getProtocolEntry. Similarly,
-
-data ProtocolEntry =
-  ProtocolEntry  {
-     protoName    :: ProtocolName,      -- Official Name
-     protoAliases :: [ProtocolName],    -- aliases
-     protoNumber  :: ProtocolNumber     -- Protocol Number
-  } deriving (Read, Show, Typeable)
-
-instance Storable ProtocolEntry where
-   sizeOf    _ = #const sizeof(struct protoent)
-   alignment _ = alignment (undefined :: CInt) -- ???
-
-   peek p = do
-        p_name    <- (#peek struct protoent, p_name) p >>= peekCString
-        p_aliases <- (#peek struct protoent, p_aliases) p
-                           >>= peekArray0 nullPtr
-                           >>= mapM peekCString
-#if defined(HAVE_WINSOCK2_H)
-         -- With WinSock, the protocol number is only a short;
-         -- hoist it in as such, but represent it on the Haskell side
-         -- as a CInt.
-        p_proto_short  <- (#peek struct protoent, p_proto) p
-        let p_proto = fromIntegral (p_proto_short :: CShort)
-#else
-        p_proto        <- (#peek struct protoent, p_proto) p
-#endif
-        return (ProtocolEntry {
-                        protoName    = p_name,
-                        protoAliases = p_aliases,
-                        protoNumber  = p_proto
-                })
-
-   poke = throwUnsupportedOperationPoke "ProtocolEntry"
-
-
-getProtocolByName :: ProtocolName -> IO ProtocolEntry
-getProtocolByName name = withLock $ do
- withCString name $ \ name_cstr -> do
- throwNoSuchThingIfNull "Network.BSD.getProtocolByName" ("no such protocol name: " ++ name)
-   $ c_getprotobyname name_cstr
- >>= peek
-
-foreign import  CALLCONV unsafe  "getprotobyname"
-   c_getprotobyname :: CString -> IO (Ptr ProtocolEntry)
-
-
-getProtocolByNumber :: ProtocolNumber -> IO ProtocolEntry
-getProtocolByNumber num = withLock $ do
- throwNoSuchThingIfNull "Network.BSD.getProtocolByNumber" ("no such protocol number: " ++ show num)
-   $ c_getprotobynumber (fromIntegral num)
- >>= peek
-
-foreign import CALLCONV unsafe  "getprotobynumber"
-   c_getprotobynumber :: CInt -> IO (Ptr ProtocolEntry)
-
-
-getProtocolNumber :: ProtocolName -> IO ProtocolNumber
-getProtocolNumber proto = do
- (ProtocolEntry _ _ num) <- getProtocolByName proto
- return num
-
-#if !defined(mingw32_HOST_OS)
-getProtocolEntry :: IO ProtocolEntry    -- Next Protocol Entry from DB
-getProtocolEntry = withLock $ do
- ent <- throwNoSuchThingIfNull "Network.BSD.getProtocolEntry" "no such protocol entry"
-                $ c_getprotoent
- peek ent
-
-foreign import ccall unsafe  "getprotoent" c_getprotoent :: IO (Ptr ProtocolEntry)
-
-setProtocolEntry :: Bool -> IO ()       -- Keep DB Open ?
-setProtocolEntry flg = withLock $ c_setprotoent (fromBool flg)
-
-foreign import ccall unsafe "setprotoent" c_setprotoent :: CInt -> IO ()
-
-endProtocolEntry :: IO ()
-endProtocolEntry = withLock $ c_endprotoent
-
-foreign import ccall unsafe "endprotoent" c_endprotoent :: IO ()
-
-getProtocolEntries :: Bool -> IO [ProtocolEntry]
-getProtocolEntries stayOpen = withLock $ do
-  setProtocolEntry stayOpen
-  getEntries (getProtocolEntry) (endProtocolEntry)
-#endif
-
--- ---------------------------------------------------------------------------
--- Host lookups
-
-data HostEntry =
-  HostEntry  {
-     hostName      :: HostName,         -- Official Name
-     hostAliases   :: [HostName],       -- aliases
-     hostFamily    :: Family,           -- Host Type (currently AF_INET)
-     hostAddresses :: [HostAddress]     -- Set of Network Addresses  (in network byte order)
-  } deriving (Read, Show, Typeable)
-
-instance Storable HostEntry where
-   sizeOf    _ = #const sizeof(struct hostent)
-   alignment _ = alignment (undefined :: CInt) -- ???
-
-   peek p = do
-        h_name       <- (#peek struct hostent, h_name) p >>= peekCString
-        h_aliases    <- (#peek struct hostent, h_aliases) p
-                                >>= peekArray0 nullPtr
-                                >>= mapM peekCString
-        h_addrtype   <- (#peek struct hostent, h_addrtype) p
-        -- h_length       <- (#peek struct hostent, h_length) p
-        h_addr_list  <- (#peek struct hostent, h_addr_list) p
-                                >>= peekArray0 nullPtr
-                                >>= mapM peek
-        return (HostEntry {
-                        hostName       = h_name,
-                        hostAliases    = h_aliases,
-#if defined(HAVE_WINSOCK2_H)
-                        hostFamily     = unpackFamily (fromIntegral (h_addrtype :: CShort)),
-#else
-                        hostFamily     = unpackFamily h_addrtype,
-#endif
-                        hostAddresses  = h_addr_list
-                })
-
-   poke = throwUnsupportedOperationPoke "HostEntry"
-
-
--- convenience function:
-hostAddress :: HostEntry -> HostAddress
-hostAddress (HostEntry nm _ _ ls) =
- case ls of
-   []    -> error $ "Network.BSD.hostAddress: empty network address list for " ++ nm
-   (x:_) -> x
-
--- getHostByName must use the same lock as the *hostent functions
--- may cause problems if called concurrently.
-
--- | Resolve a 'HostName' to IPv4 address.
-getHostByName :: HostName -> IO HostEntry
-getHostByName name = withLock $ do
-  withCString name $ \ name_cstr -> do
-   ent <- throwNoSuchThingIfNull "Network.BSD.getHostByName" "no such host entry"
-                $ c_gethostbyname name_cstr
-   peek ent
-
-foreign import CALLCONV safe "gethostbyname"
-   c_gethostbyname :: CString -> IO (Ptr HostEntry)
-
-
--- The locking of gethostbyaddr is similar to gethostbyname.
--- | Get a 'HostEntry' corresponding to the given address and family.
--- Note that only IPv4 is currently supported.
-getHostByAddr :: Family -> HostAddress -> IO HostEntry
-getHostByAddr family addr = do
- with addr $ \ ptr_addr -> withLock $ do
- throwNoSuchThingIfNull "Network.BSD.getHostByAddr" "no such host entry"
-   $ c_gethostbyaddr ptr_addr (fromIntegral (sizeOf addr)) (packFamily family)
- >>= peek
-
-foreign import CALLCONV safe "gethostbyaddr"
-   c_gethostbyaddr :: Ptr HostAddress -> CInt -> CInt -> IO (Ptr HostEntry)
-
-#if defined(HAVE_GETHOSTENT) && !defined(mingw32_HOST_OS)
-getHostEntry :: IO HostEntry
-getHostEntry = withLock $ do
- throwNoSuchThingIfNull "Network.BSD.getHostEntry" "unable to retrieve host entry"
-   $ c_gethostent
- >>= peek
-
-foreign import ccall unsafe "gethostent" c_gethostent :: IO (Ptr HostEntry)
-
-setHostEntry :: Bool -> IO ()
-setHostEntry flg = withLock $ c_sethostent (fromBool flg)
-
-foreign import ccall unsafe "sethostent" c_sethostent :: CInt -> IO ()
-
-endHostEntry :: IO ()
-endHostEntry = withLock $ c_endhostent
-
-foreign import ccall unsafe "endhostent" c_endhostent :: IO ()
-
-getHostEntries :: Bool -> IO [HostEntry]
-getHostEntries stayOpen = do
-  setHostEntry stayOpen
-  getEntries (getHostEntry) (endHostEntry)
-#endif
-
--- ---------------------------------------------------------------------------
--- Accessing network information
-
--- Same set of access functions as for accessing host,protocol and
--- service system info, this time for the types of networks supported.
-
--- network addresses are represented in host byte order.
-type NetworkAddr = CULong
-
-type NetworkName = String
-
-data NetworkEntry =
-  NetworkEntry {
-     networkName        :: NetworkName,   -- official name
-     networkAliases     :: [NetworkName], -- aliases
-     networkFamily      :: Family,         -- type
-     networkAddress     :: NetworkAddr
-   } deriving (Read, Show, Typeable)
-
-instance Storable NetworkEntry where
-   sizeOf    _ = #const sizeof(struct hostent)
-   alignment _ = alignment (undefined :: CInt) -- ???
-
-   peek p = do
-        n_name         <- (#peek struct netent, n_name) p >>= peekCString
-        n_aliases      <- (#peek struct netent, n_aliases) p
-                                >>= peekArray0 nullPtr
-                                >>= mapM peekCString
-        n_addrtype     <- (#peek struct netent, n_addrtype) p
-        n_net          <- (#peek struct netent, n_net) p
-        return (NetworkEntry {
-                        networkName      = n_name,
-                        networkAliases   = n_aliases,
-                        networkFamily    = unpackFamily (fromIntegral
-                                                        (n_addrtype :: CInt)),
-                        networkAddress   = n_net
-                })
-
-   poke = throwUnsupportedOperationPoke "NetworkEntry"
-
-
-#if !defined(mingw32_HOST_OS)
-getNetworkByName :: NetworkName -> IO NetworkEntry
-getNetworkByName name = withLock $ do
- withCString name $ \ name_cstr -> do
-  throwNoSuchThingIfNull "Network.BSD.getNetworkByName" "no such network entry"
-    $ c_getnetbyname name_cstr
-  >>= peek
-
-foreign import ccall unsafe "getnetbyname"
-   c_getnetbyname  :: CString -> IO (Ptr NetworkEntry)
-
-getNetworkByAddr :: NetworkAddr -> Family -> IO NetworkEntry
-getNetworkByAddr addr family = withLock $ do
- throwNoSuchThingIfNull "Network.BSD.getNetworkByAddr" "no such network entry"
-   $ c_getnetbyaddr addr (packFamily family)
- >>= peek
-
-foreign import ccall unsafe "getnetbyaddr"
-   c_getnetbyaddr  :: NetworkAddr -> CInt -> IO (Ptr NetworkEntry)
-
-getNetworkEntry :: IO NetworkEntry
-getNetworkEntry = withLock $ do
- throwNoSuchThingIfNull "Network.BSD.getNetworkEntry" "no more network entries"
-          $ c_getnetent
- >>= peek
-
-foreign import ccall unsafe "getnetent" c_getnetent :: IO (Ptr NetworkEntry)
-
--- | Open the network name database. The parameter specifies
--- whether a connection is maintained open between various
--- networkEntry calls
-setNetworkEntry :: Bool -> IO ()
-setNetworkEntry flg = withLock $ c_setnetent (fromBool flg)
-
-foreign import ccall unsafe "setnetent" c_setnetent :: CInt -> IO ()
-
--- | Close the connection to the network name database.
-endNetworkEntry :: IO ()
-endNetworkEntry = withLock $ c_endnetent
-
-foreign import ccall unsafe "endnetent" c_endnetent :: IO ()
-
--- | Get the list of network entries.
-getNetworkEntries :: Bool -> IO [NetworkEntry]
-getNetworkEntries stayOpen = do
-  setNetworkEntry stayOpen
-  getEntries (getNetworkEntry) (endNetworkEntry)
-#endif
-
--- ---------------------------------------------------------------------------
--- Interface names
-
-#if defined(HAVE_IF_NAMETOINDEX)
-
--- returns the index of the network interface corresponding to the name ifname.
-ifNameToIndex :: String -> IO (Maybe Int)
-ifNameToIndex ifname = do
-  index <- withCString ifname c_if_nametoindex
-  -- On failure zero is returned. We'll return Nothing.
-  return $ if index == 0 then Nothing else Just $ fromIntegral index
-
-foreign import CALLCONV safe "if_nametoindex"
-   c_if_nametoindex :: CString -> IO CUInt
-
-#endif
-
-
--- Mutex for name service lockdown
-
-{-# NOINLINE lock #-}
-lock :: MVar ()
-lock = unsafePerformIO $ withSocketsDo $ newMVar ()
-
-withLock :: IO a -> IO a
-withLock act = withMVar lock (\_ -> act)
-
--- ---------------------------------------------------------------------------
--- Miscellaneous Functions
-
--- | Calling getHostName returns the standard host name for the current
--- processor, as set at boot time.
-
-getHostName :: IO HostName
-getHostName = do
-  let size = 256
-  allocaArray0 size $ \ cstr -> do
-    throwSocketErrorIfMinus1_ "Network.BSD.getHostName" $ c_gethostname cstr (fromIntegral size)
-    peekCString cstr
-
-foreign import CALLCONV unsafe "gethostname"
-   c_gethostname :: CString -> CSize -> IO CInt
-
--- Helper function used by the exported functions that provides a
--- Haskellised view of the enumerator functions:
-
-getEntries :: IO a  -- read
-           -> IO () -- at end
-           -> IO [a]
-getEntries getOne atEnd = loop
-  where
-    loop = do
-      vv <- E.catch (liftM Just getOne)
-            (\ e -> let _types = e :: IOException in return Nothing)
-      case vv of
-        Nothing -> return []
-        Just v  -> loop >>= \ vs -> atEnd >> return (v:vs)
-
-
-throwNoSuchThingIfNull :: String -> String -> IO (Ptr a) -> IO (Ptr a)
-throwNoSuchThingIfNull loc desc act = do
-  ptr <- act
-  if (ptr == nullPtr)
-   then ioError (ioeSetErrorString (mkIOError NoSuchThing loc Nothing Nothing) desc)
-   else return ptr
-
-throwUnsupportedOperationPoke :: String -> Ptr a -> a -> IO ()
-throwUnsupportedOperationPoke typ _ _ =
-  ioError $ ioeSetErrorString ioe "Operation not implemented"
-  where
-    ioe = mkIOError UnsupportedOperation
-                    ("Network.BSD: instance Storable " ++ typ ++ ": poke")
-                    Nothing
-                    Nothing
diff --git a/Network/Socket.hs b/Network/Socket.hs
new file mode 100644
index 0000000..01bed0d
--- /dev/null
+++ b/Network/Socket.hs
@@ -0,0 +1,1491 @@
+{-# LANGUAGE CPP, ScopedTypeVariables, MultiWayIf #-}
+{-# OPTIONS_GHC -fno-warn-orphans #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Network.Socket
+-- Copyright   :  (c) The University of Glasgow 2001
+-- License     :  BSD-style (see the file libraries/network/LICENSE)
+--
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  provisional
+-- Portability :  portable
+--
+-- The "Network.Socket" module is for when you want full control over
+-- sockets.  Essentially the entire C socket API is exposed through
+-- this module; in general the operations follow the behaviour of the C
+-- functions of the same name (consult your favourite Unix networking book).
+--
+-- A higher level interface to networking operations is provided
+-- through the module "Network".
+--
+-----------------------------------------------------------------------------
+
+#include "HsNet.h"
+
+-- In order to process this file, you need to have CALLCONV defined.
+
+module Network.Socket
+    (
+    -- * Types
+      Socket(..)
+    , Family(..)
+    , isSupportedFamily
+    , SocketType(..)
+    , isSupportedSocketType
+    , SockAddr(..)
+    , isSupportedSockAddr
+    , SocketStatus(..)
+    , HostAddress
+    , hostAddressToTuple
+    , tupleToHostAddress
+#if defined(IPV6_SOCKET_SUPPORT)
+    , HostAddress6
+    , hostAddress6ToTuple
+    , tupleToHostAddress6
+    , FlowInfo
+    , ScopeID
+#endif
+    -- , htonl
+    -- , ntohl
+    , ShutdownCmd(..)
+    , ProtocolNumber
+    , defaultProtocol
+    , PortNumber(..)
+    -- PortNumber is used non-abstractly in Network.BSD.  ToDo: remove
+    -- this use and make the type abstract.
+
+    -- * Address operations
+
+    , HostName
+    , ServiceName
+
+#if defined(IPV6_SOCKET_SUPPORT)
+    , AddrInfo(..)
+
+    , AddrInfoFlag(..)
+    , addrInfoFlagImplemented
+
+    , defaultHints
+
+    , getAddrInfo
+
+    , NameInfoFlag(..)
+
+    , getNameInfo
+#endif
+
+    -- * Socket operations
+    , socket
+#if defined(DOMAIN_SOCKET_SUPPORT)
+    , socketPair
+#endif
+    , connect
+    , bind
+    , listen
+    , accept
+    , getPeerName
+    , getSocketName
+
+#if defined(HAVE_STRUCT_UCRED) || defined(HAVE_GETPEEREID)
+    -- get the credentials of our domain socket peer.
+    , getPeerCred
+#if defined(HAVE_GETPEEREID)
+    , getPeerEid
+#endif
+#endif
+
+    , socketPort
+
+    , socketToHandle
+
+    -- ** Sending and receiving data
+    -- *** Sending and receiving with String
+    -- $sendrecv
+    , send
+    , sendTo
+    , recv
+    , recvFrom
+    , recvLen
+
+    -- *** Sending and receiving with a buffer
+    , sendBuf
+    , recvBuf
+    , sendBufTo
+    , recvBufFrom
+
+    -- ** Misc
+    , inet_addr
+    , inet_ntoa
+
+    , shutdown
+    , close
+
+    -- ** Predicates on sockets
+    , isConnected
+    , isBound
+    , isListening
+    , isReadable
+    , isWritable
+
+    -- * Socket options
+    , SocketOption(..)
+    , isSupportedSocketOption
+    , getSocketOption
+    , setSocketOption
+
+    -- * File descriptor transmission
+#ifdef DOMAIN_SOCKET_SUPPORT
+    , sendFd
+    , recvFd
+
+#endif
+
+    -- * Special constants
+    , aNY_PORT
+    , iNADDR_ANY
+#if defined(IPV6_SOCKET_SUPPORT)
+    , iN6ADDR_ANY
+#endif
+    , sOMAXCONN
+    , sOL_SOCKET
+#ifdef SCM_RIGHTS
+    , sCM_RIGHTS
+#endif
+    , maxListenQueue
+
+    -- * Initialisation
+    , withSocketsDo
+
+    -- * Very low level operations
+    -- in case you ever want to get at the underlying file descriptor..
+    , fdSocket
+    , mkSocket
+    , setNonBlockIfNeeded
+
+    -- * Deprecated aliases
+    -- $deprecated-aliases
+    , bindSocket
+    , sClose
+    , sIsConnected
+    , sIsBound
+    , sIsListening
+    , sIsReadable
+    , sIsWritable
+
+    -- * Internal
+
+    -- | The following are exported ONLY for use in the BSD module and
+    -- should not be used anywhere else.
+
+    , packFamily
+    , unpackFamily
+    , packSocketType
+    ) where
+
+import Data.Bits
+import Data.Functor
+import Data.List (foldl')
+import Data.Maybe (isJust)
+import Data.Word (Word8, Word32)
+import Foreign.Ptr (Ptr, castPtr, nullPtr)
+import Foreign.Storable (Storable(..))
+import Foreign.C.Error
+import Foreign.C.String (CString, withCString, withCStringLen, peekCString, peekCStringLen)
+import Foreign.C.Types (CUInt, CChar)
+import Foreign.C.Types (CInt(..), CSize(..))
+import Foreign.Marshal.Alloc ( alloca, allocaBytes )
+import Foreign.Marshal.Array ( peekArray )
+import Foreign.Marshal.Utils ( maybeWith, with )
+
+import System.IO
+import Control.Monad (liftM, when)
+
+import Control.Concurrent.MVar
+import Data.Typeable
+import System.IO.Error
+
+import GHC.Conc (threadWaitRead, threadWaitWrite, threadWaitConnect, threadWaitAccept)
+#if MIN_VERSION_base(4,3,1)
+import GHC.Conc (closeFdWith)
+#endif
+# if defined(mingw32_HOST_OS)
+import qualified Control.Exception as E
+import GHC.Conc (asyncDoProc)
+import GHC.IO.FD (FD(..), readRawBufferPtr, writeRawBufferPtr)
+import Foreign (FunPtr)
+# endif
+# if defined(darwin_HOST_OS)
+import Data.List (delete)
+# endif
+import qualified GHC.IO.Device
+import GHC.IO.Handle.FD
+import GHC.IO.Exception
+import GHC.IO
+import qualified System.Posix.Internals
+#if ((ETA_VERSION == 9) && (ETA_BUILD_NUMBER >= 2)) || (ETA_VERSION > 9)
+import GHC.IO.FD
+import System.Posix.Types     (Channel)
+import System.Posix.Internals (c_close)
+import Control.Monad
+import Java
+import Java.Array
+import Data.Maybe
+#endif
+
+import Network.Socket.Internal
+import Network.Socket.Types
+
+import Prelude -- Silence AMP warnings
+
+-- | Either a host name e.g., @\"haskell.org\"@ or a numeric host
+-- address string consisting of a dotted decimal IPv4 address or an
+-- IPv6 address e.g., @\"192.168.0.1\"@.
+type HostName       = String
+type ServiceName    = String
+
+-- ----------------------------------------------------------------------------
+-- On Windows, our sockets are not put in non-blocking mode (non-blocking
+-- is not supported for regular file descriptors on Windows, and it would
+-- be a pain to support it only for sockets).  So there are two cases:
+--
+--  - the threaded RTS uses safe calls for socket operations to get
+--    non-blocking I/O, just like the rest of the I/O library
+--
+--  - with the non-threaded RTS, only some operations on sockets will be
+--    non-blocking.  Reads and writes go through the normal async I/O
+--    system.  accept() uses asyncDoProc so is non-blocking.  A handful
+--    of others (recvFrom, sendFd, recvFd) will block all threads - if this
+--    is a problem, -threaded is the workaround.
+--
+#define SAFE_ON_WIN safe
+
+-----------------------------------------------------------------------------
+-- Socket types
+
+socket2FD  (MkSocket fd _ _ _ _) = do
+  blocking <- isBlocking fd
+  return $ FD { fdFD = FDGeneric fd, fdIsNonBlocking = not blocking }
+
+-- | Smart constructor for constructing a 'Socket'. It should only be
+-- called once for every new file descriptor. The caller must make
+-- sure that the socket is in non-blocking mode. See
+-- 'setNonBlockIfNeeded'.
+mkSocket :: Channel
+         -> Family
+         -> SocketType
+         -> ProtocolNumber
+         -> SocketStatus
+         -> IO Socket
+mkSocket fd fam sType pNum stat = do
+   mStat <- newMVar stat
+   withSocketsDo $ return ()
+   return (MkSocket fd fam sType pNum mStat)
+
+
+fdSocket :: Socket -> Channel
+fdSocket (MkSocket fd _ _ _ _) = fd
+
+-- | This is the default protocol for a given service.
+defaultProtocol :: ProtocolNumber
+defaultProtocol = 0
+
+-----------------------------------------------------------------------------
+-- SockAddr
+
+instance Show SockAddr where
+#if defined(DOMAIN_SOCKET_SUPPORT)
+  showsPrec _ (SockAddrUnix str) = showString str
+#endif
+  showsPrec _ (SockAddrInet port ha)
+   = showString (unsafePerformIO (inet_ntoa ha))
+   . showString ":"
+   . shows port
+#if defined(IPV6_SOCKET_SUPPORT)
+  showsPrec _ addr@(SockAddrInet6 port _ _ _)
+   = showChar '['
+   . showString (unsafePerformIO $
+                 fst `liftM` getNameInfo [NI_NUMERICHOST] True False addr >>=
+                 maybe (fail "showsPrec: impossible internal error") return)
+   . showString "]:"
+   . shows port
+#endif
+#if defined(CAN_SOCKET_SUPPORT)
+  showsPrec _ (SockAddrCan ifidx) = shows ifidx
+#endif
+
+-----------------------------------------------------------------------------
+-- Connection Functions
+
+-- In the following connection and binding primitives.  The names of
+-- the equivalent C functions have been preserved where possible. It
+-- should be noted that some of these names used in the C library,
+-- \tr{bind} in particular, have a different meaning to many Haskell
+-- programmers and have thus been renamed by appending the prefix
+-- Socket.
+
+-- | Create a new socket using the given address family, socket type
+-- and protocol number.  The address family is usually 'AF_INET',
+-- 'AF_INET6', or 'AF_UNIX'.  The socket type is usually 'Stream' or
+-- 'Datagram'.  The protocol number is usually 'defaultProtocol'.
+-- If 'AF_INET6' is used and the socket type is 'Stream' or 'Datagram',
+-- the 'IPv6Only' socket option is set to 0 so that both IPv4 and IPv6
+-- can be handled with one socket.
+--
+-- >>> let hints = defaultHints { addrFlags = [AI_NUMERICHOST, AI_NUMERICSERV], addrSocketType = Stream }
+-- >>> addr:_ <- getAddrInfo (Just hints) (Just "127.0.0.1") (Just "5000")
+-- >>> sock@(MkSocket _ fam stype _ _) <- socket (addrFamily addr) (addrSocketType addr) (addrProtocol addr)
+-- >>> fam
+-- AF_INET
+-- >>> stype
+-- Stream
+-- >>> bind sock (addrAddress addr)
+-- >>> getSocketName sock
+-- 127.0.0.1:5000
+socket :: Family         -- Family Name (usually AF_INET)
+       -> SocketType     -- Socket Type (usually Stream)
+       -> ProtocolNumber -- Protocol Number (getProtocolByName to find value)
+       -> IO Socket      -- Unconnected Socket
+socket family stype protocol = do
+    c_stype <- packSocketTypeOrThrow "socket" stype
+    fd      <- c_socket (packFamily family) c_stype protocol
+    setNonBlockIfNeeded fd
+    socket_status <- newMVar NotConnected
+    withSocketsDo $ return ()
+    let sock = MkSocket fd family stype protocol socket_status
+#if HAVE_DECL_IPV6_V6ONLY
+    -- The default value of the IPv6Only option is platform specific,
+    -- so we explicitly set it to 0 to provide a common default.
+# if defined(mingw32_HOST_OS)
+    -- The IPv6Only option is only supported on Windows Vista and later,
+    -- so trying to change it might throw an error.
+    when (family == AF_INET6 && (stype == Stream || stype == Datagram)) $
+      E.catch (setSocketOption sock IPv6Only 0) $ (\(_ :: E.IOException) -> return ())
+# else
+    when (family == AF_INET6 && (stype == Stream || stype == Datagram)) $
+      setSocketOption sock IPv6Only 0 `onException` close sock
+# endif
+#endif
+    return sock
+
+-- | Build a pair of connected socket objects using the given address
+-- family, socket type, and protocol number.  Address family, socket
+-- type, and protocol number are as for the 'socket' function above.
+-- Availability: Unix.
+#if defined(DOMAIN_SOCKET_SUPPORT)
+socketPair :: Family              -- Family Name (usually AF_INET or AF_INET6)
+           -> SocketType          -- Socket Type (usually Stream)
+           -> ProtocolNumber      -- Protocol Number
+           -> IO (Socket, Socket) -- unnamed and connected.
+socketPair family stype protocol = do
+    allocaBytes (2 * sizeOf (1 :: CInt)) $ \ fdArr -> do
+    c_stype <- packSocketTypeOrThrow "socketPair" stype
+    _rc <- throwSocketErrorIfMinus1Retry "Network.Socket.socketpair" $
+                c_socketpair (packFamily family) c_stype protocol fdArr
+    [fd1,fd2] <- peekArray 2 fdArr
+    s1 <- mkNonBlockingSocket fd1
+    s2 <- mkNonBlockingSocket fd2
+    return (s1,s2)
+  where
+    mkNonBlockingSocket fd = do
+       setNonBlockIfNeeded fd
+       stat <- newMVar Connected
+       withSocketsDo $ return ()
+       return (MkSocket fd family stype protocol stat)
+
+foreign import ccall unsafe "socketpair"
+  c_socketpair :: CInt -> CInt -> CInt -> Ptr CInt -> IO CInt
+#endif
+
+-- | Set the socket to nonblocking, if applicable to this platform.
+--
+-- Depending on the platform this is required when using sockets from file
+-- descriptors that are passed in through 'recvFd' or other means.
+setNonBlockIfNeeded :: Channel -> IO ()
+setNonBlockIfNeeded fd =
+    System.Posix.Internals.setNonBlockingFD fd True
+
+-----------------------------------------------------------------------------
+-- Binding a socket
+
+-- | Bind the socket to an address. The socket must not already be
+-- bound.  The 'Family' passed to @bind@ must be the
+-- same as that passed to 'socket'.  If the special port number
+-- 'aNY_PORT' is passed then the system assigns the next available
+-- use port.
+bind :: Socket    -- Unconnected Socket
+           -> SockAddr  -- Address to Bind to
+           -> IO ()
+bind (MkSocket s _family _stype _protocol socketStatus) addr = do
+ modifyMVar_ socketStatus $ \ status -> do
+ if status /= NotConnected
+  then
+   ioError $ userError $
+     "Network.Socket.bind: can't bind to socket with non-default status."
+  else do
+   withSockAddr addr $ \saddr -> do
+     _status <- c_bind s saddr
+     return (Bound addr)
+
+-----------------------------------------------------------------------------
+-- Connecting a socket
+
+-- | Connect to a remote socket at address.
+connect :: Socket    -- Unconnected Socket
+        -> SockAddr  -- Socket address stuff
+        -> IO ()
+connect sock@(MkSocket s _family _stype _protocol socketStatus) addr = withSocketsDo $ do
+ modifyMVar_ socketStatus $ \currentStatus -> do
+ if shouldError currentStatus
+  then
+    ioError $ userError $
+      errLoc ++ ": can't connect to socket with status that is not bound or default."
+  else do
+    withSockAddr addr $ \saddr -> do
+
+    let connectLoop = do
+           connected <- c_connect s saddr
+           unless connected $ do
+             connectBlocked
+             connectLoop
+
+        connectBlocked = threadWaitConnect s
+
+    connectLoop
+    return Connected
+ where
+   errLoc = "Network.Socket.connect: " ++ show sock
+   shouldError NotConnected = False
+   shouldError (Bound _) = False
+   shouldError _ = True
+
+-----------------------------------------------------------------------------
+-- Listen
+
+-- | Listen for connections made to the socket.  The second argument
+-- specifies the maximum number of queued connections and should be at
+-- least 1; the maximum value is system-dependent (usually 5).
+listen :: Socket  -- Connected & Bound Socket
+       -> Int     -- Queue Length
+       -> IO ()
+listen (MkSocket s _family _stype _protocol socketStatus) backlog = do
+ modifyMVar_ socketStatus $ \ status -> do
+ if | Bound sockAddr <- status -> do
+      withSockAddr sockAddr $ \saddr -> c_listen s saddr (fromIntegral backlog)
+      return Listening
+    | otherwise ->
+      ioError $ userError $
+        "Network.Socket.listen: can't listen on socket with non-bound status."
+
+-----------------------------------------------------------------------------
+-- Accept
+--
+-- A call to `accept' only returns when data is available on the given
+-- socket, unless the socket has been set to non-blocking.  It will
+-- return a new socket which should be used to read the incoming data and
+-- should then be closed. Using the socket returned by `accept' allows
+-- incoming requests to be queued on the original socket.
+
+-- | Accept a connection.  The socket must be bound to an address and
+-- listening for connections.  The return value is a pair @(conn,
+-- address)@ where @conn@ is a new socket object usable to send and
+-- receive data on the connection, and @address@ is the address bound
+-- to the socket on the other end of the connection.
+accept :: Socket                        -- Queue Socket
+       -> IO (Socket,                   -- Readable Socket
+              SockAddr)                 -- Peer details
+
+accept sock@(MkSocket s family stype protocol status) = do
+ currentStatus <- readMVar status
+ okay <- isAcceptable sock
+ if not okay
+   then
+     ioError $ userError $
+       "Network.Socket.accept: can't accept socket (" ++
+         show (family, stype, protocol) ++ ") with status not in position to accept" ++
+         "connections."
+   else do
+     new_sock <- onNothingRetry $ c_accept s
+     addr <- newSockAddr new_sock
+     setNonBlockIfNeeded new_sock
+     new_status <- newMVar Connected
+     return ((MkSocket new_sock family (toStype stype) protocol new_status), addr)
+  where onNothingRetry io = do
+          mResult <- io
+          case mResult of
+            Nothing -> threadWaitAccept s >> onNothingRetry io
+            Just ch -> return ch
+        toStype (ServerSocket s) = s
+
+-----------------------------------------------------------------------------
+-- ** Sending and receiving data
+
+-- $sendrecv
+--
+-- Do not use the @send@ and @recv@ functions defined in this section
+-- in new code, as they incorrectly represent binary data as a Unicode
+-- string.  As a result, these functions are inefficient and may lead
+-- to bugs in the program.  Instead use the @send@ and @recv@
+-- functions defined in the "Network.Socket.ByteString" module.
+
+-----------------------------------------------------------------------------
+-- sendTo & recvFrom
+
+-- | Send data to the socket.  The recipient can be specified
+-- explicitly, so the socket need not be in a connected state.
+-- Returns the number of bytes sent.  Applications are responsible for
+-- ensuring that all data has been sent.
+--
+-- NOTE: blocking on Windows unless you compile with -threaded (see
+-- GHC ticket #1129)
+{-# WARNING sendTo "Use sendTo defined in \"Network.Socket.ByteString\"" #-}
+sendTo :: Socket        -- (possibly) bound/connected Socket
+       -> String        -- Data to send
+       -> SockAddr
+       -> IO Int        -- Number of Bytes sent
+sendTo sock xs addr = do
+ withCStringLen xs $ \(str, len) -> do
+   sendBufTo sock str len addr
+
+-- | Send data to the socket.  The recipient can be specified
+-- explicitly, so the socket need not be in a connected state.
+-- Returns the number of bytes sent.  Applications are responsible for
+-- ensuring that all data has been sent.
+sendBufTo :: Socket            -- (possibly) bound/connected Socket
+          -> Ptr a -> Int  -- Data to send
+          -> SockAddr
+          -> IO Int            -- Number of Bytes sent
+sendBufTo sock@(MkSocket s _family _stype _protocol _status) ptr nbytes addr = do
+ withSockAddr addr $ \p_addr -> do
+   liftM fromIntegral $
+     throwSocketErrorWaitWrite sock "Network.Socket.sendTo" $
+        c_sendto s ptr (fromIntegral $ nbytes) p_addr
+
+-- | Receive data from the socket. The socket need not be in a
+-- connected state. Returns @(bytes, nbytes, address)@ where @bytes@
+-- is a @String@ of length @nbytes@ representing the data received and
+-- @address@ is a 'SockAddr' representing the address of the sending
+-- socket.
+--
+-- NOTE: blocking on Windows unless you compile with -threaded (see
+-- GHC ticket #1129)
+{-# WARNING recvFrom "Use recvFrom defined in \"Network.Socket.ByteString\"" #-}
+recvFrom :: Socket -> Int -> IO (String, Int, SockAddr)
+recvFrom sock nbytes =
+  allocaBytes nbytes $ \ptr -> do
+    (len, sockaddr) <- recvBufFrom sock ptr nbytes
+    str <- peekCStringLen (ptr, len)
+    return (str, len, sockaddr)
+
+-- | Receive data from the socket, writing it into buffer instead of
+-- creating a new string.  The socket need not be in a connected
+-- state. Returns @(nbytes, address)@ where @nbytes@ is the number of
+-- bytes received and @address@ is a 'SockAddr' representing the
+-- address of the sending socket.
+--
+-- NOTE: blocking on Windows unless you compile with -threaded (see
+-- GHC ticket #1129)
+recvBufFrom :: Socket -> Ptr a -> Int -> IO (Int, SockAddr)
+recvBufFrom sock@(MkSocket s family _stype _protocol _status) ptr nbytes
+ | nbytes <= 0 = ioError (mkInvalidRecvArgError "Network.Socket.recvFrom")
+ | otherwise   = error "recvBufFrom: Not implemented yet"
+    -- withNewSockAddr family $ \ptr_addr sz -> do
+    --   alloca $ \ptr_len -> do
+    --     poke ptr_len (fromIntegral sz)
+    --     len <- throwSocketErrorWaitRead sock "Network.Socket.recvFrom" $
+    --                c_recvfrom s ptr (fromIntegral nbytes) 0{-flags-}
+    --                             ptr_addr ptr_len
+    --     let len' = fromIntegral len
+    --     if len' == 0
+    --      then ioError (mkEOFError "Network.Socket.recvFrom")
+    --      else do
+    --        flg <- isConnected sock
+    --          -- For at least one implementation (WinSock 2), recvfrom() ignores
+    --          -- filling in the sockaddr for connected TCP sockets. Cope with
+    --          -- this by using getPeerName instead.
+    --        sockaddr <-
+    --             if flg then
+    --                getPeerName sock
+    --             else
+    --                peekSockAddr ptr_addr
+    --        return (len', sockaddr)
+
+-----------------------------------------------------------------------------
+-- send & recv
+
+-- | Send data to the socket. The socket must be connected to a remote
+-- socket. Returns the number of bytes sent.  Applications are
+-- responsible for ensuring that all data has been sent.
+--
+-- Sending data to closed socket may lead to undefined behaviour.
+{-# WARNING send "Use send defined in \"Network.Socket.ByteString\"" #-}
+send :: Socket  -- Bound/Connected Socket
+     -> String  -- Data to send
+     -> IO Int  -- Number of Bytes sent
+send sock xs = withCStringLen xs $ \(str, len) ->
+    sendBuf sock (castPtr str) len
+
+-- | Send data to the socket. The socket must be connected to a remote
+-- socket. Returns the number of bytes sent.  Applications are
+-- responsible for ensuring that all data has been sent.
+--
+-- Sending data to closed socket may lead to undefined behaviour.
+sendBuf :: Socket     -- Bound/Connected Socket
+        -> Ptr Word8  -- Pointer to the data to send
+        -> Int        -- Length of the buffer
+        -> IO Int     -- Number of Bytes sent
+sendBuf sock@(MkSocket s _family _stype _protocol _status) str len = do
+   fd <- socket2FD sock
+   liftM fromIntegral $
+-- writeRawBufferPtr is supposed to handle checking for errors, but it's broken
+-- on x86_64 because of GHC bug #12010 so we duplicate the check here. The call
+-- to throwSocketErrorIfMinus1Retry can be removed when no GHC version with the
+-- bug is supported.
+    throwSocketErrorIfMinus1Retry "Network.Socket.sendBuf" $ writeRawBufferPtr
+      "Network.Socket.sendBuf"
+      fd
+      (castPtr str)
+      0
+      (fromIntegral len)
+
+-- | Receive data from the socket.  The socket must be in a connected
+-- state. This function may return fewer bytes than specified.  If the
+-- message is longer than the specified length, it may be discarded
+-- depending on the type of socket.  This function may block until a
+-- message arrives.
+--
+-- Considering hardware and network realities, the maximum number of
+-- bytes to receive should be a small power of 2, e.g., 4096.
+--
+-- For TCP sockets, a zero length return value means the peer has
+-- closed its half side of the connection.
+--
+-- Receiving data from closed socket may lead to undefined behaviour.
+{-# WARNING recv "Use recv defined in \"Network.Socket.ByteString\"" #-}
+recv :: Socket -> Int -> IO String
+recv sock l = fst <$> recvLen sock l
+
+{-# WARNING recvLen "Use recvLen defined in \"Network.Socket.ByteString\"" #-}
+recvLen :: Socket -> Int -> IO (String, Int)
+recvLen sock nbytes =
+     allocaBytes nbytes $ \ptr -> do
+        len <- recvBuf sock ptr nbytes
+        s <- peekCStringLen (castPtr ptr,len)
+        return (s, len)
+
+-- | Receive data from the socket.  The socket must be in a connected
+-- state. This function may return fewer bytes than specified.  If the
+-- message is longer than the specified length, it may be discarded
+-- depending on the type of socket.  This function may block until a
+-- message arrives.
+--
+-- Considering hardware and network realities, the maximum number of
+-- bytes to receive should be a small power of 2, e.g., 4096.
+--
+-- For TCP sockets, a zero length return value means the peer has
+-- closed its half side of the connection.
+--
+-- Receiving data from closed socket may lead to undefined behaviour.
+recvBuf :: Socket -> Ptr Word8 -> Int -> IO Int
+recvBuf sock@(MkSocket s _family _stype _protocol _status) ptr nbytes
+ | nbytes <= 0 = ioError (mkInvalidRecvArgError "Network.Socket.recvBuf")
+ | otherwise   = do
+        fd <- socket2FD sock
+        len <-
+-- see comment in sendBuf above.
+            throwSocketErrorIfMinus1Retry "Network.Socket.recvBuf" $
+                readRawBufferPtr "Network.Socket.recvBuf"
+                fd ptr 0 (fromIntegral nbytes)
+        let len' = fromIntegral len
+        if len' == 0
+         then ioError (mkEOFError "Network.Socket.recvBuf")
+         else return len'
+
+
+-- ---------------------------------------------------------------------------
+-- socketPort
+--
+-- The port number the given socket is currently connected to can be
+-- determined by calling $port$, is generally only useful when bind
+-- was given $aNY\_PORT$.
+
+socketPort :: Socket            -- Connected & Bound Socket
+           -> IO PortNumber     -- Port Number of Socket
+socketPort sock@(MkSocket _ AF_INET _ _ _) = do
+    (SockAddrInet port _) <- getSocketName sock
+    return port
+#if defined(IPV6_SOCKET_SUPPORT)
+socketPort sock@(MkSocket _ AF_INET6 _ _ _) = do
+    (SockAddrInet6 port _ _ _) <- getSocketName sock
+    return port
+#endif
+socketPort (MkSocket _ family _ _ _) =
+    ioError $ userError $
+      "Network.Socket.socketPort: address family '" ++ show family ++
+      "' not supported."
+
+
+-- ---------------------------------------------------------------------------
+-- getPeerName
+
+-- Calling $getPeerName$ returns the address details of the machine,
+-- other than the local one, which is connected to the socket. This is
+-- used in programs such as FTP to determine where to send the
+-- returning data.  The corresponding call to get the details of the
+-- local machine is $getSocketName$.
+
+getPeerName   :: Socket -> IO SockAddr
+getPeerName (MkSocket s family _ _ _) =
+  error $ "Network.Socket.getPeerName: Not implemented yet."
+
+getSocketName :: Socket -> IO SockAddr
+getSocketName (MkSocket s family _ _ _) =
+  error $ "Network.Socket.getSocketName: Not implemented yet."
+
+-----------------------------------------------------------------------------
+-- Socket Properties
+
+-- | Socket options for use with 'setSocketOption' and 'getSocketOption'.
+--
+-- The existence of a constructor does not imply that the relevant option
+-- is supported on your system: see 'isSupportedSocketOption'
+data SocketOption
+    = Debug         -- ^ SO_DEBUG
+    | ReuseAddr     -- ^ SO_REUSEADDR
+    | Type          -- ^ SO_TYPE
+    | SoError       -- ^ SO_ERROR
+    | DontRoute     -- ^ SO_DONTROUTE
+    | Broadcast     -- ^ SO_BROADCAST
+    | SendBuffer    -- ^ SO_SNDBUF
+    | RecvBuffer    -- ^ SO_RCVBUF
+    | KeepAlive     -- ^ SO_KEEPALIVE
+    | OOBInline     -- ^ SO_OOBINLINE
+    | TimeToLive    -- ^ IP_TTL
+    | MaxSegment    -- ^ TCP_MAXSEG
+    | NoDelay       -- ^ TCP_NODELAY
+    | Cork          -- ^ TCP_CORK
+    | Linger        -- ^ SO_LINGER
+    | ReusePort     -- ^ SO_REUSEPORT
+    | RecvLowWater  -- ^ SO_RCVLOWAT
+    | SendLowWater  -- ^ SO_SNDLOWAT
+    | RecvTimeOut   -- ^ SO_RCVTIMEO
+    | SendTimeOut   -- ^ SO_SNDTIMEO
+    | UseLoopBack   -- ^ SO_USELOOPBACK
+    | UserTimeout   -- ^ TCP_USER_TIMEOUT
+    | IPv6Only      -- ^ IPV6_V6ONLY
+    | CustomSockOpt (CInt, CInt)
+    deriving (Show, Typeable)
+
+-- | Does the 'SocketOption' exist on this system?
+isSupportedSocketOption :: SocketOption -> Bool
+isSupportedSocketOption = isJust . packSocketOption
+
+-- | For a socket option, return Just (level, value) where level is the
+-- corresponding C option level constant (e.g. SOL_SOCKET) and value is
+-- the option constant itself (e.g. SO_DEBUG)
+-- If either constant does not exist, return Nothing.
+packSocketOption :: SocketOption -> Maybe SOption
+packSocketOption so =
+  -- The Just here is a hack to disable GHC's overlapping pattern detection:
+  -- the problem is if all constants are present, the fallback pattern is
+  -- redundant, but if they aren't then it isn't. Hence we introduce an
+  -- extra pattern (Nothing) that can't possibly happen, so that the
+  -- fallback is always (in principle) necessary.
+  -- I feel a little bad for including this, but such are the sacrifices we
+  -- make while working with CPP - excluding the fallback pattern correctly
+  -- would be a serious nuisance.
+  -- (NB: comments elsewhere in this file refer to this one)
+  case Just so of
+    Just ReuseAddr     -> Just sO_REUSEADDR
+    Just Broadcast     -> Just sO_BROADCAST
+    Just SendBuffer    -> Just sO_SNDBUF
+    Just RecvBuffer    -> Just sO_RCVBUF
+    Just KeepAlive     -> Just sO_KEEPALIVE
+    Just Linger        -> Just sO_LINGER
+    Just NoDelay       -> Just tCP_NODELAY
+    _                  -> Nothing
+
+-- | Return the option level and option value if they exist,
+-- otherwise throw an error that begins "Network.Socket." ++ the String
+-- parameter
+packSocketOption' :: String -> SocketOption -> IO SOption
+packSocketOption' caller so = maybe err return (packSocketOption so)
+ where
+  err = ioError . userError . concat $ ["Network.Socket.", caller,
+    ": socket option ", show so, " unsupported on this system"]
+
+-- | Set a socket option that expects an Int value.
+-- There is currently no API to set e.g. the timeval socket options
+setSocketOption :: Socket
+                -> SocketOption -- Option Name
+                -> Int          -- Option Value
+                -> IO ()
+setSocketOption (MkSocket s _ _ _ _) so v = do
+   opt <- packSocketOption' "setSocketOption" so
+   c_setsockopt s opt (fromIntegral v)
+
+-- | Get a socket option that gives an Int value.
+-- There is currently no API to get e.g. the timeval socket options
+getSocketOption :: Socket
+                -> SocketOption  -- Option Name
+                -> IO Int        -- Option Value
+getSocketOption (MkSocket s _ _ _ _) so = do
+   opt <- packSocketOption' "getSocketOption" so
+   fmap fromIntegral $ c_getsockopt s opt
+
+#if defined(HAVE_STRUCT_UCRED) || defined(HAVE_GETPEEREID)
+-- | Returns the processID, userID and groupID of the socket's peer.
+--
+-- Only available on platforms that support SO_PEERCRED or GETPEEREID(3)
+-- on domain sockets.
+-- GETPEEREID(3) returns userID and groupID. processID is always 0.
+getPeerCred :: Socket -> IO (CUInt, CUInt, CUInt)
+getPeerCred sock = do
+#ifdef HAVE_STRUCT_UCRED
+  let fd = fdSocket sock
+  let sz = (#const sizeof(struct ucred))
+  allocaBytes sz $ \ ptr_cr ->
+   with (fromIntegral sz) $ \ ptr_sz -> do
+     _ <- ($) throwSocketErrorIfMinus1Retry "Network.Socket.getPeerCred" $
+       c_getsockopt fd (#const SOL_SOCKET) (#const SO_PEERCRED) ptr_cr ptr_sz
+     pid <- (#peek struct ucred, pid) ptr_cr
+     uid <- (#peek struct ucred, uid) ptr_cr
+     gid <- (#peek struct ucred, gid) ptr_cr
+     return (pid, uid, gid)
+#else
+  (uid,gid) <- getPeerEid sock
+  return (0,uid,gid)
+#endif
+
+#ifdef HAVE_GETPEEREID
+-- | The getpeereid() function returns the effective user and group IDs of the
+-- peer connected to a UNIX-domain socket
+getPeerEid :: Socket -> IO (CUInt, CUInt)
+getPeerEid sock = do
+  let fd = fdSocket sock
+  alloca $ \ ptr_uid ->
+    alloca $ \ ptr_gid -> do
+      throwSocketErrorIfMinus1Retry_ "Network.Socket.getPeerEid" $
+        c_getpeereid fd ptr_uid ptr_gid
+      uid <- peek ptr_uid
+      gid <- peek ptr_gid
+      return (uid, gid)
+#endif
+#endif
+
+#if defined(DOMAIN_SOCKET_SUPPORT)
+-- sending/receiving ancillary socket data; low-level mechanism
+-- for transmitting file descriptors, mainly.
+sendFd :: Socket -> CInt -> IO ()
+sendFd sock outfd = do
+  _ <- ($) throwSocketErrorWaitWrite sock "Network.Socket.sendFd" $
+     c_sendFd (fdSocket sock) outfd
+   -- Note: If Winsock supported FD-passing, thi would have been
+   -- incorrect (since socket FDs need to be closed via closesocket().)
+  closeFd outfd
+
+-- | Receive a file descriptor over a domain socket. Note that the resulting
+-- file descriptor may have to be put into non-blocking mode in order to be
+-- used safely. See 'setNonBlockIfNeeded'.
+recvFd :: Socket -> IO CInt
+recvFd sock = do
+  theFd <- throwSocketErrorWaitRead sock "Network.Socket.recvFd" $
+               c_recvFd (fdSocket sock)
+  return theFd
+
+foreign import ccall SAFE_ON_WIN "sendFd" c_sendFd :: CInt -> CInt -> IO CInt
+foreign import ccall SAFE_ON_WIN "recvFd" c_recvFd :: CInt -> IO CInt
+
+#endif
+
+-- ---------------------------------------------------------------------------
+-- Utility Functions
+
+aNY_PORT :: PortNumber
+aNY_PORT = 0
+
+-- | The IPv4 wild card address.
+
+iNADDR_ANY :: HostAddress
+iNADDR_ANY = 0
+
+-- | Converts the from host byte order to network byte order.
+-- foreign import CALLCONV unsafe "htonl" htonl :: Word32 -> Word32
+-- -- | Converts the from network byte order to host byte order.
+-- foreign import CALLCONV unsafe "ntohl" ntohl :: Word32 -> Word32
+
+#if defined(IPV6_SOCKET_SUPPORT)
+-- | The IPv6 wild card address.
+
+iN6ADDR_ANY :: HostAddress6
+iN6ADDR_ANY = (0, 0, 0, 0)
+#endif
+
+sOMAXCONN :: Int
+sOMAXCONN = 50
+
+sOL_SOCKET :: Int
+sOL_SOCKET = 0
+
+#ifdef SCM_RIGHTS
+sCM_RIGHTS :: Int
+sCM_RIGHTS = #const SCM_RIGHTS
+#endif
+
+-- | This is the value of SOMAXCONN, typically 128.
+-- 128 is good enough for normal network servers but
+-- is too small for high performance servers.
+maxListenQueue :: Int
+maxListenQueue = sOMAXCONN
+
+-- -----------------------------------------------------------------------------
+
+data ShutdownCmd
+ = ShutdownReceive
+ | ShutdownSend
+ | ShutdownBoth
+ deriving Typeable
+
+sdownCmdToInt :: ShutdownCmd -> CInt
+sdownCmdToInt ShutdownReceive = 0
+sdownCmdToInt ShutdownSend    = 1
+sdownCmdToInt ShutdownBoth    = 2
+
+-- | Shut down one or both halves of the connection, depending on the
+-- second argument to the function.  If the second argument is
+-- 'ShutdownReceive', further receives are disallowed.  If it is
+-- 'ShutdownSend', further sends are disallowed.  If it is
+-- 'ShutdownBoth', further sends and receives are disallowed.
+shutdown :: Socket -> ShutdownCmd -> IO ()
+shutdown (MkSocket s _ _ _ _) stype = do
+  throwSocketErrorIfMinus1Retry_ "Network.Socket.shutdown" $
+    c_shutdown s (sdownCmdToInt stype)
+  return ()
+
+-- -----------------------------------------------------------------------------
+
+-- | Close the socket. Sending data to or receiving data from closed socket
+-- may lead to undefined behaviour.
+close :: Socket -> IO ()
+close (MkSocket s _ _ _ socketStatus) = do
+ modifyMVar_ socketStatus $ \ status ->
+   case status of
+     ConvertedToHandle ->
+         ioError (userError ("close: converted to a Handle, use hClose instead"))
+     Closed ->
+         return status
+     _ -> closeFdWith closeFd s >> return Closed
+
+-- -----------------------------------------------------------------------------
+
+-- | Determines whether 'close' has been used on the 'Socket'. This
+-- does /not/ indicate any status about the socket beyond this. If the
+-- socket has been closed remotely, this function can still return
+-- 'True'.
+isConnected :: Socket -> IO Bool
+isConnected (MkSocket _ _ _ _ status) = do
+    value <- readMVar status
+    return (value == Connected)
+
+-- -----------------------------------------------------------------------------
+-- Socket Predicates
+
+isBound :: Socket -> IO Bool
+isBound (MkSocket _ _ _ _ status) = do
+    value <- readMVar status
+    return $ case value of
+      Bound _ -> True
+      _ -> False
+
+isListening :: Socket -> IO Bool
+isListening (MkSocket _ _ _  _ status) = do
+    value <- readMVar status
+    return (value == Listening)
+
+isReadable  :: Socket -> IO Bool
+isReadable (MkSocket _ _ _ _ status) = do
+    value <- readMVar status
+    return (value == Listening || value == Connected)
+
+isWritable  :: Socket -> IO Bool
+isWritable = isReadable -- sort of.
+
+isAcceptable :: Socket -> IO Bool
+#if defined(DOMAIN_SOCKET_SUPPORT)
+isAcceptable (MkSocket _ AF_UNIX x _ status)
+    | x == Stream || x == SeqPacket = do
+        value <- readMVar status
+        return (value == Connected || value == Bound || value == Listening)
+isAcceptable (MkSocket _ AF_UNIX _ _ _) = return False
+#endif
+isAcceptable (MkSocket _ _ _ _ status) = do
+    value <- readMVar status
+    return (value == Connected || value == Listening)
+
+-- -----------------------------------------------------------------------------
+-- Internet address manipulation routines:
+
+inet_addr :: String -> IO HostAddress
+inet_addr ipstr = withSocketsDo $ do
+   had <- c_inet_addr ipstr
+   if had == -1
+    then ioError $ userError $
+      "Network.Socket.inet_addr: Malformed address: " ++ ipstr
+    else return had  -- network byte order
+
+inet_ntoa :: HostAddress -> IO String
+inet_ntoa haddr = withSocketsDo $ c_inet_ntoa haddr
+
+-- | Turns a Socket into an 'Handle'. By default, the new handle is
+-- unbuffered. Use 'System.IO.hSetBuffering' to change the buffering.
+--
+-- Note that since a 'Handle' is automatically closed by a finalizer
+-- when it is no longer referenced, you should avoid doing any more
+-- operations on the 'Socket' after calling 'socketToHandle'.  To
+-- close the 'Socket' after 'socketToHandle', call 'System.IO.hClose'
+-- on the 'Handle'.
+
+socketToHandle :: Socket -> IOMode -> IO Handle
+socketToHandle s@(MkSocket fd _ _ _ socketStatus) mode = do
+ modifyMVar socketStatus $ \ status ->
+    if status == ConvertedToHandle
+        then ioError (userError ("socketToHandle: already a Handle"))
+        else do
+    h <- fdToHandle' fd (Just GHC.IO.Device.Stream) True Nothing mode True{-bin-}
+    hSetBuffering h NoBuffering
+    return (ConvertedToHandle, h)
+
+-- | Pack a list of values into a bitmask.  The possible mappings from
+-- value to bit-to-set are given as the first argument.  We assume
+-- that each value can cause exactly one bit to be set; unpackBits will
+-- break if this property is not true.
+
+packBits :: (Eq a, Num b, Bits b) => [(a, b)] -> [a] -> b
+
+packBits mapping xs = foldl' pack 0 mapping
+    where pack acc (k, v) | k `elem` xs = acc .|. v
+                          | otherwise   = acc
+
+-- | Unpack a bitmask into a list of values.
+
+unpackBits :: (Num b, Bits b) => [(a, b)] -> b -> [a]
+
+-- Be permissive and ignore unknown bit values. At least on OS X,
+-- getaddrinfo returns an ai_flags field with bits set that have no
+-- entry in <netdb.h>.
+unpackBits [] _    = []
+unpackBits ((k,v):xs) r
+    | r .&. v /= 0 = k : unpackBits xs (r .&. complement v)
+    | otherwise    = unpackBits xs r
+
+-----------------------------------------------------------------------------
+-- Address and service lookups
+
+#if defined(IPV6_SOCKET_SUPPORT)
+
+-- | Flags that control the querying behaviour of 'getAddrInfo'.
+--   For more information, see <https://tools.ietf.org/html/rfc3493#page-25>
+data AddrInfoFlag =
+    -- | The list of returned 'AddrInfo' values will
+    --   only contain IPv4 addresses if the local system has at least
+    --   one IPv4 interface configured, and likewise for IPv6.
+    --   (Only some platforms support this.)
+      AI_ADDRCONFIG
+    -- | If 'AI_ALL' is specified, return all matching IPv6 and
+    --   IPv4 addresses.  Otherwise, this flag has no effect.
+    --   (Only some platforms support this.)
+    | AI_ALL
+    -- | The 'addrCanonName' field of the first returned
+    --   'AddrInfo' will contain the "canonical name" of the host.
+    | AI_CANONNAME
+    -- | The 'HostName' argument /must/ be a numeric
+    --   address in string form, and network name lookups will not be
+    --   attempted.
+    | AI_NUMERICHOST
+    -- | The 'ServiceName' argument /must/ be a port
+    --   number in string form, and service name lookups will not be
+    --   attempted. (Only some platforms support this.)
+    | AI_NUMERICSERV
+    -- | If no 'HostName' value is provided, the network
+    --   address in each 'SockAddr'
+    --   will be left as a "wild card", i.e. as either 'iNADDR_ANY'
+    --   or 'iN6ADDR_ANY'.  This is useful for server applications that
+    --   will accept connections from any client.
+    | AI_PASSIVE
+    -- | If an IPv6 lookup is performed, and no IPv6
+    --   addresses are found, IPv6-mapped IPv4 addresses will be
+    --   returned. (Only some platforms support this.)
+    | AI_V4MAPPED
+    deriving (Eq, Read, Show, Typeable)
+
+aiFlagMapping :: [(AddrInfoFlag, CInt)]
+
+aiFlagMapping =
+    [
+#if HAVE_DECL_AI_ADDRCONFIG
+     (AI_ADDRCONFIG, #const AI_ADDRCONFIG),
+#else
+     (AI_ADDRCONFIG, 0),
+#endif
+#if HAVE_DECL_AI_ALL
+     (AI_ALL, #const AI_ALL),
+#else
+     (AI_ALL, 0),
+#endif
+     (AI_CANONNAME, 0),
+     (AI_NUMERICHOST, 0),
+#if HAVE_DECL_AI_NUMERICSERV
+     (AI_NUMERICSERV, #const AI_NUMERICSERV),
+#else
+     (AI_NUMERICSERV, 0),
+#endif
+     (AI_PASSIVE, 0),
+#if HAVE_DECL_AI_V4MAPPED
+     (AI_V4MAPPED, #const AI_V4MAPPED)
+#else
+     (AI_V4MAPPED, 0)
+#endif
+    ]
+
+-- | Indicate whether the given 'AddrInfoFlag' will have any effect on
+-- this system.
+addrInfoFlagImplemented :: AddrInfoFlag -> Bool
+addrInfoFlagImplemented f = packBits aiFlagMapping [f] /= 0
+
+data AddrInfo =
+    AddrInfo {
+        addrFlags :: [AddrInfoFlag],
+        addrFamily :: Family,
+        addrSocketType :: SocketType,
+        addrProtocol :: ProtocolNumber,
+        addrAddress :: SockAddr,
+        addrCanonName :: Maybe String
+        }
+    deriving (Eq, Show, Typeable)
+
+-- | Flags that control the querying behaviour of 'getNameInfo'.
+--   For more information, see <https://tools.ietf.org/html/rfc3493#page-30>
+data NameInfoFlag =
+    -- | Resolve a datagram-based service name.  This is
+    --   required only for the few protocols that have different port
+    --   numbers for their datagram-based versions than for their
+    --   stream-based versions.
+      NI_DGRAM
+    -- | If the hostname cannot be looked up, an IO error is thrown.
+    | NI_NAMEREQD
+    -- | If a host is local, return only the hostname part of the FQDN.
+    | NI_NOFQDN
+    -- | The name of the host is not looked up.
+    --   Instead, a numeric representation of the host's
+    --   address is returned.  For an IPv4 address, this will be a
+    --   dotted-quad string.  For IPv6, it will be colon-separated
+    --   hexadecimal.
+    | NI_NUMERICHOST
+    -- | The name of the service is not
+    --   looked up.  Instead, a numeric representation of the
+    --   service is returned.
+    | NI_NUMERICSERV
+    deriving (Eq, Read, Show, Typeable)
+
+niFlagMapping :: [(NameInfoFlag, CInt)]
+
+niFlagMapping = [(NI_DGRAM, 0),
+                 (NI_NAMEREQD, 1),
+                 (NI_NOFQDN, 2),
+                 (NI_NUMERICHOST, 3),
+                 (NI_NUMERICSERV, 4)]
+
+-- | Default hints for address lookup with 'getAddrInfo'.  The values
+-- of the 'addrAddress' and 'addrCanonName' fields are 'undefined',
+-- and are never inspected by 'getAddrInfo'.
+--
+-- >>> addrFlags defaultHints
+-- []
+-- >>> addrFamily defaultHints
+-- AF_UNSPEC
+-- >>> addrSocketType defaultHints
+-- NoSocketType
+-- >>> addrProtocol defaultHints
+-- 0
+
+defaultHints :: AddrInfo
+defaultHints = AddrInfo {
+                         addrFlags = [],
+                         addrFamily = AF_UNSPEC,
+                         addrSocketType = NoSocketType,
+                         addrProtocol = defaultProtocol,
+                         addrAddress = undefined,
+                         addrCanonName = undefined
+                        }
+
+-- | Resolve a host or service name to one or more addresses.
+-- The 'AddrInfo' values that this function returns contain 'SockAddr'
+-- values that you can pass directly to 'connect' or
+-- 'bind'.
+--
+-- This function is protocol independent.  It can return both IPv4 and
+-- IPv6 address information.
+--
+-- The 'AddrInfo' argument specifies the preferred query behaviour,
+-- socket options, or protocol.  You can override these conveniently
+-- using Haskell's record update syntax on 'defaultHints', for example
+-- as follows:
+--
+-- >>> let hints = defaultHints { addrFlags = [AI_NUMERICHOST], addrSocketType = Stream }
+--
+-- You must provide a 'Just' value for at least one of the 'HostName'
+-- or 'ServiceName' arguments.  'HostName' can be either a numeric
+-- network address (dotted quad for IPv4, colon-separated hex for
+-- IPv6) or a hostname.  In the latter case, its addresses will be
+-- looked up unless 'AI_NUMERICHOST' is specified as a hint.  If you
+-- do not provide a 'HostName' value /and/ do not set 'AI_PASSIVE' as
+-- a hint, network addresses in the result will contain the address of
+-- the loopback interface.
+--
+-- If the query fails, this function throws an IO exception instead of
+-- returning an empty list.  Otherwise, it returns a non-empty list
+-- of 'AddrInfo' values.
+--
+-- There are several reasons why a query might result in several
+-- values.  For example, the queried-for host could be multihomed, or
+-- the service might be available via several protocols.
+--
+-- Note: the order of arguments is slightly different to that defined
+-- for @getaddrinfo@ in RFC 2553.  The 'AddrInfo' parameter comes first
+-- to make partial application easier.
+--
+-- >>> addr:_ <- getAddrInfo (Just hints) (Just "127.0.0.1") (Just "http")
+-- >>> addrAddress addr
+-- 127.0.0.1:80
+
+getAddrInfo :: Maybe AddrInfo -- ^ preferred socket type or protocol
+            -> Maybe HostName -- ^ host name to look up
+            -> Maybe ServiceName -- ^ service name to look up
+            -> IO [AddrInfo] -- ^ resolved addresses, with "best" first
+
+getAddrInfo mHints node service = withSocketsDo $ do
+  addresses <- c_getaddrinfo (fromMaybe "0.0.0.0" node)
+  return $ map toAddrInfo $ filter filterFun $ fromJava addresses
+  where toAddrInfo inetAddr = defaultHints {
+          addrAddress    = SockAddrInet port (inetAddrInt inetAddr),
+          addrSocketType = maybe (addrSocketType defaultHints) addrSocketType mHints,
+          addrFamily     = if isIPv6 inetAddr then AF_INET6 else AF_INET
+          }
+        filterFun  =
+          case addrFamilySelect of
+            AF_INET  -> not . isIPv6
+            AF_INET6 -> isIPv6
+            _        -> const True
+        addrFamilySelect = maybe (addrFamily defaultHints) addrFamily mHints
+        port
+          | Just port' <- service
+          = read port'
+          | otherwise = 0
+
+foreign import CALLCONV unsafe "@static java.net.InetAddress.getAllByName"
+  c_getaddrinfo :: String -> IO InetAddressArray
+
+foreign import CALLCONV unsafe "@static eta.network.Utils.isIPv6"
+  isIPv6 :: InetAddress -> Bool
+
+withCStringIf :: Bool -> Int -> (CSize -> CString -> IO a) -> IO a
+withCStringIf False _ f = f 0 nullPtr
+withCStringIf True n f = allocaBytes n (f (fromIntegral n))
+
+-- | Resolve an address to a host or service name.
+-- This function is protocol independent.
+-- The list of 'NameInfoFlag' values controls query behaviour.
+--
+-- If a host or service's name cannot be looked up, then the numeric
+-- form of the address or service will be returned.
+--
+-- If the query fails, this function throws an IO exception.
+--
+-- Example:
+-- @
+--   (hostName, _) <- getNameInfo [] True False myAddress
+-- @
+
+foreign import CALLCONV unsafe "@static eta.network.Utils.inet6_ntoa"
+  inet6_ntoa :: JIntArray -> String
+
+getNameInfo :: [NameInfoFlag] -- ^ flags to control lookup behaviour
+            -> Bool -- ^ whether to look up a hostname
+            -> Bool -- ^ whether to look up a service name
+            -> SockAddr -- ^ the address to look up
+            -> IO (Maybe HostName, Maybe ServiceName)
+
+getNameInfo _flags _doHost _doService addr =
+  case addr of
+    SockAddrInet6 _ _ addr _ -> do
+      let (ip1,ip2,ip3,ip4) = addr
+      hostName <- c_getnameinfo $ toJByteArray (concatMap word32to8 [ip1,ip2,ip3,ip4])
+      return (Just hostName, Nothing)
+    SockAddrInet _ addr -> do
+      hostName <- c_getnameinfo $ toJByteArray (word32to8 addr)
+      return (Just hostName, Nothing)
+  where word32to8 w32 = map fromIntegral [(w32 `shiftR` 24) .&. 0xFF
+                                         ,(w32 `shiftR` 16) .&. 0xFF
+                                         ,(w32 `shiftR` 8)  .&. 0xFF
+                                         ,w32 .&. 0xFF]
+
+foreign import CALLCONV unsafe "@static eta.network.Utils.getNameInfo"
+  c_getnameinfo :: JByteArray -> IO String
+#endif
+
+mkInvalidRecvArgError :: String -> IOError
+mkInvalidRecvArgError loc = ioeSetErrorString (mkIOError
+                                    InvalidArgument
+                                    loc Nothing Nothing) "non-positive length"
+
+mkEOFError :: String -> IOError
+mkEOFError loc = ioeSetErrorString (mkIOError EOF loc Nothing Nothing) "end of file"
+
+-- ---------------------------------------------------------------------------
+-- foreign imports from the C library
+
+foreign import CALLCONV unsafe "@static eta.network.Utils.inet_ntoa"
+  c_inet_ntoa :: HostAddress -> IO String
+
+foreign import CALLCONV unsafe "@static eta.network.Utils.inet_addr"
+  c_inet_addr :: String -> IO HostAddress
+
+foreign import CALLCONV unsafe "@static eta.network.Utils.shutdown"
+  c_shutdown :: Channel -> CInt -> IO CInt
+
+closeFd :: Channel -> IO ()
+closeFd fd = c_close fd
+
+foreign import CALLCONV unsafe "@static eta.network.Utils.socket"
+  c_socket :: CInt -> CInt -> CInt -> IO Channel
+foreign import CALLCONV unsafe "@static eta.network.Utils.bind"
+  c_bind :: Channel -> SocketAddress -> IO CInt
+foreign import CALLCONV SAFE_ON_WIN "@static eta.network.Utils.connect"
+  c_connect :: Channel -> SocketAddress -> IO Bool
+foreign import CALLCONV unsafe "@static eta.network.Utils.accept"
+  c_accept :: Channel -> IO (Maybe Channel)
+foreign import CALLCONV unsafe "@static eta.network.Utils.listen"
+  c_listen :: Channel -> SocketAddress -> CInt -> IO CInt
+
+-- foreign import CALLCONV unsafe "send"
+--   c_send :: CInt -> Ptr a -> CSize -> CInt -> IO CInt
+foreign import CALLCONV SAFE_ON_WIN "@static eta.network.Utils.sendto"
+  c_sendto :: Channel -> Ptr a -> CSize -> SocketAddress -> IO CInt
+-- foreign import CALLCONV unsafe "recv"
+--   c_recv :: CInt -> Ptr CChar -> CSize -> CInt -> IO CInt
+-- foreign import CALLCONV SAFE_ON_WIN "@static eta.network.Utils.sendto"
+--   c_recvfrom :: CInt -> Ptr a -> CSize -> CInt -> Ptr SockAddr -> IO CInt
+-- foreign import CALLCONV unsafe "getpeername"
+--   c_getpeername :: CInt -> Ptr SockAddr -> Ptr CInt -> IO CInt
+-- foreign import CALLCONV unsafe "getsockname"
+--   c_getsockname :: CInt -> Ptr SockAddr -> Ptr CInt -> IO CInt
+
+foreign import CALLCONV unsafe "@static eta.network.Utils.getsockopt"
+  c_getsockopt :: Channel -> SOption -> IO CInt
+foreign import CALLCONV unsafe "@static eta.network.Utils.setsockopt"
+  c_setsockopt :: Channel -> SOption -> CInt ->  IO ()
+
+#if defined(HAVE_GETPEEREID)
+foreign import CALLCONV unsafe "getpeereid"
+  c_getpeereid :: CInt -> Ptr CUInt -> Ptr CUInt -> IO CInt
+#endif
+
+foreign import CALLCONV unsafe "@static eta.network.Utils.isBlocking" isBlocking
+  :: Channel -> IO Bool
+
+data {-# CLASS "java.net.SocketOption" #-} SOption = SOption (Object# SOption)
+
+foreign import java unsafe
+  "@static @field java.net.StandardSocketOptions.IP_MULTICAST_IF"
+  iP_MULTICAST_IF :: SOption
+
+foreign import java unsafe
+  "@static @field java.net.StandardSocketOptions.IP_MULTICAST_LOOP"
+  iP_MULTICAST_LOOP :: SOption
+
+foreign import java unsafe
+  "@static @field java.net.StandardSocketOptions.IP_MULTICAST_TTL"
+  iP_MULTICAST_TTL :: SOption
+
+foreign import java unsafe
+  "@static @field java.net.StandardSocketOptions.IP_TOS"
+  iP_TOS :: SOption
+
+foreign import java unsafe
+  "@static @field java.net.StandardSocketOptions.SO_BROADCAST"
+  sO_BROADCAST :: SOption
+
+foreign import java unsafe
+  "@static @field java.net.StandardSocketOptions.SO_KEEPALIVE"
+  sO_KEEPALIVE :: SOption
+
+foreign import java unsafe
+  "@static @field java.net.StandardSocketOptions.SO_LINGER"
+  sO_LINGER :: SOption
+
+foreign import java unsafe
+  "@static @field java.net.StandardSocketOptions.SO_RCVBUF"
+  sO_RCVBUF :: SOption
+
+foreign import java unsafe
+  "@static @field java.net.StandardSocketOptions.SO_REUSEADDR"
+  sO_REUSEADDR :: SOption
+
+foreign import java unsafe
+  "@static @field java.net.StandardSocketOptions.SO_SNDBUF"
+  sO_SNDBUF :: SOption
+
+foreign import java unsafe
+  "@static @field java.net.StandardSocketOptions.TCP_NODELAY"
+  tCP_NODELAY :: SOption
+
+-- ---------------------------------------------------------------------------
+-- * Deprecated aliases
+
+-- $deprecated-aliases
+--
+-- These aliases are deprecated and should not be used in new code.
+-- They will be removed in some future version of the package.
+
+{-# DEPRECATED bindSocket "use 'bind'" #-}
+
+-- | Deprecated alias for 'bind'.
+bindSocket :: Socket    -- Unconnected Socket
+           -> SockAddr  -- Address to Bind to
+           -> IO ()
+bindSocket = bind
+
+{-# DEPRECATED sClose "use 'close'" #-}
+
+-- | Deprecated alias for 'close'.
+sClose :: Socket -> IO ()
+sClose = close
+
+{-# DEPRECATED sIsConnected "use 'isConnected'" #-}
+
+-- | Deprecated alias for 'isConnected'.
+sIsConnected :: Socket -> IO Bool
+sIsConnected = isConnected
+
+{-# DEPRECATED sIsBound "use 'isBound'" #-}
+
+-- | Deprecated alias for 'isBound'.
+sIsBound :: Socket -> IO Bool
+sIsBound = isBound
+
+{-# DEPRECATED sIsListening "use 'isListening'" #-}
+
+-- | Deprecated alias for 'isListening'.
+sIsListening :: Socket -> IO Bool
+sIsListening = isListening
+
+{-# DEPRECATED sIsReadable "use 'isReadable'" #-}
+
+-- | Deprecated alias for 'isReadable'.
+sIsReadable  :: Socket -> IO Bool
+sIsReadable = isReadable
+
+{-# DEPRECATED sIsWritable "use 'isWritable'" #-}
+
+-- | Deprecated alias for 'isWritable'.
+sIsWritable  :: Socket -> IO Bool
+sIsWritable = isWritable
diff --git a/Network/Socket.hsc b/Network/Socket.hsc
deleted file mode 100644
index 6a1ce6a..0000000
--- a/Network/Socket.hsc
+++ /dev/null
@@ -1,1683 +0,0 @@
-{-# LANGUAGE CPP, ScopedTypeVariables #-}
-{-# OPTIONS_GHC -fno-warn-orphans #-}
------------------------------------------------------------------------------
--- |
--- Module      :  Network.Socket
--- Copyright   :  (c) The University of Glasgow 2001
--- License     :  BSD-style (see the file libraries/network/LICENSE)
---
--- Maintainer  :  libraries@haskell.org
--- Stability   :  provisional
--- Portability :  portable
---
--- The "Network.Socket" module is for when you want full control over
--- sockets.  Essentially the entire C socket API is exposed through
--- this module; in general the operations follow the behaviour of the C
--- functions of the same name (consult your favourite Unix networking book).
---
--- A higher level interface to networking operations is provided
--- through the module "Network".
---
------------------------------------------------------------------------------
-
-#include "HsNet.h"
-
--- In order to process this file, you need to have CALLCONV defined.
-
-module Network.Socket
-    (
-    -- * Types
-      Socket(..)
-    , Family(..)
-    , isSupportedFamily
-    , SocketType(..)
-    , isSupportedSocketType
-    , SockAddr(..)
-    , isSupportedSockAddr
-    , SocketStatus(..)
-    , HostAddress
-    , hostAddressToTuple
-    , tupleToHostAddress
-#if defined(IPV6_SOCKET_SUPPORT)
-    , HostAddress6
-    , hostAddress6ToTuple
-    , tupleToHostAddress6
-    , FlowInfo
-    , ScopeID
-#endif
-    , htonl
-    , ntohl
-    , ShutdownCmd(..)
-    , ProtocolNumber
-    , defaultProtocol
-    , PortNumber(..)
-    -- PortNumber is used non-abstractly in Network.BSD.  ToDo: remove
-    -- this use and make the type abstract.
-
-    -- * Address operations
-
-    , HostName
-    , ServiceName
-
-#if defined(IPV6_SOCKET_SUPPORT)
-    , AddrInfo(..)
-
-    , AddrInfoFlag(..)
-    , addrInfoFlagImplemented
-
-    , defaultHints
-
-    , getAddrInfo
-
-    , NameInfoFlag(..)
-
-    , getNameInfo
-#endif
-
-    -- * Socket operations
-    , socket
-#if defined(DOMAIN_SOCKET_SUPPORT)
-    , socketPair
-#endif
-    , connect
-    , bind
-    , listen
-    , accept
-    , getPeerName
-    , getSocketName
-
-#if defined(HAVE_STRUCT_UCRED) || defined(HAVE_GETPEEREID)
-    -- get the credentials of our domain socket peer.
-    , getPeerCred
-#if defined(HAVE_GETPEEREID)
-    , getPeerEid
-#endif
-#endif
-
-    , socketPort
-
-    , socketToHandle
-
-    -- ** Sending and receiving data
-    -- *** Sending and receiving with String
-    -- $sendrecv
-    , send
-    , sendTo
-    , recv
-    , recvFrom
-    , recvLen
-
-    -- *** Sending and receiving with a buffer
-    , sendBuf
-    , recvBuf
-    , sendBufTo
-    , recvBufFrom
-
-    -- ** Misc
-    , inet_addr
-    , inet_ntoa
-
-    , shutdown
-    , close
-
-    -- ** Predicates on sockets
-    , isConnected
-    , isBound
-    , isListening
-    , isReadable
-    , isWritable
-
-    -- * Socket options
-    , SocketOption(..)
-    , isSupportedSocketOption
-    , getSocketOption
-    , setSocketOption
-
-    -- * File descriptor transmission
-#ifdef DOMAIN_SOCKET_SUPPORT
-    , sendFd
-    , recvFd
-
-#endif
-
-    -- * Special constants
-    , aNY_PORT
-    , iNADDR_ANY
-#if defined(IPV6_SOCKET_SUPPORT)
-    , iN6ADDR_ANY
-#endif
-    , sOMAXCONN
-    , sOL_SOCKET
-#ifdef SCM_RIGHTS
-    , sCM_RIGHTS
-#endif
-    , maxListenQueue
-
-    -- * Initialisation
-    , withSocketsDo
-
-    -- * Very low level operations
-    -- in case you ever want to get at the underlying file descriptor..
-    , fdSocket
-    , mkSocket
-    , setNonBlockIfNeeded
-
-    -- * Deprecated aliases
-    -- $deprecated-aliases
-    , bindSocket
-    , sClose
-    , sIsConnected
-    , sIsBound
-    , sIsListening
-    , sIsReadable
-    , sIsWritable
-
-    -- * Internal
-
-    -- | The following are exported ONLY for use in the BSD module and
-    -- should not be used anywhere else.
-
-    , packFamily
-    , unpackFamily
-    , packSocketType
-    ) where
-
-import Data.Bits
-import Data.Functor
-import Data.List (foldl')
-import Data.Maybe (isJust)
-import Data.Word (Word8, Word32)
-import Foreign.Ptr (Ptr, castPtr, nullPtr)
-import Foreign.Storable (Storable(..))
-import Foreign.C.Error
-import Foreign.C.String (CString, withCString, withCStringLen, peekCString, peekCStringLen)
-import Foreign.C.Types (CUInt, CChar)
-import Foreign.C.Types (CInt(..), CSize(..))
-import Foreign.Marshal.Alloc ( alloca, allocaBytes )
-import Foreign.Marshal.Array ( peekArray )
-import Foreign.Marshal.Utils ( maybeWith, with )
-
-import System.IO
-import Control.Monad (liftM, when)
-
-import Control.Concurrent.MVar
-import Data.Typeable
-import System.IO.Error
-
-import GHC.Conc (threadWaitRead, threadWaitWrite)
-##if MIN_VERSION_base(4,3,1)
-import GHC.Conc (closeFdWith)
-##endif
-# if defined(mingw32_HOST_OS)
-import qualified Control.Exception as E
-import GHC.Conc (asyncDoProc)
-import GHC.IO.FD (FD(..), readRawBufferPtr, writeRawBufferPtr)
-import Foreign (FunPtr)
-# endif
-# if defined(darwin_HOST_OS)
-import Data.List (delete)
-# endif
-import qualified GHC.IO.Device
-import GHC.IO.Handle.FD
-import GHC.IO.Exception
-import GHC.IO
-import qualified System.Posix.Internals
-
-import Network.Socket.Internal
-import Network.Socket.Types
-
-import Prelude -- Silence AMP warnings
-
--- | Either a host name e.g., @\"haskell.org\"@ or a numeric host
--- address string consisting of a dotted decimal IPv4 address or an
--- IPv6 address e.g., @\"192.168.0.1\"@.
-type HostName       = String
-type ServiceName    = String
-
--- ----------------------------------------------------------------------------
--- On Windows, our sockets are not put in non-blocking mode (non-blocking
--- is not supported for regular file descriptors on Windows, and it would
--- be a pain to support it only for sockets).  So there are two cases:
---
---  - the threaded RTS uses safe calls for socket operations to get
---    non-blocking I/O, just like the rest of the I/O library
---
---  - with the non-threaded RTS, only some operations on sockets will be
---    non-blocking.  Reads and writes go through the normal async I/O
---    system.  accept() uses asyncDoProc so is non-blocking.  A handful
---    of others (recvFrom, sendFd, recvFd) will block all threads - if this
---    is a problem, -threaded is the workaround.
---
-##if defined(mingw32_HOST_OS)
-##define SAFE_ON_WIN safe
-##else
-##define SAFE_ON_WIN unsafe
-##endif
-
------------------------------------------------------------------------------
--- Socket types
-
-#if defined(mingw32_HOST_OS)
-socket2FD  (MkSocket fd _ _ _ _) =
-  -- HACK, 1 means True
-  FD{fdFD = fd,fdIsSocket_ = 1}
-#endif
-
--- | Smart constructor for constructing a 'Socket'. It should only be
--- called once for every new file descriptor. The caller must make
--- sure that the socket is in non-blocking mode. See
--- 'setNonBlockIfNeeded'.
-mkSocket :: CInt
-         -> Family
-         -> SocketType
-         -> ProtocolNumber
-         -> SocketStatus
-         -> IO Socket
-mkSocket fd fam sType pNum stat = do
-   mStat <- newMVar stat
-   withSocketsDo $ return ()
-   return (MkSocket fd fam sType pNum mStat)
-
-
-fdSocket :: Socket -> CInt
-fdSocket (MkSocket fd _ _ _ _) = fd
-
--- | This is the default protocol for a given service.
-defaultProtocol :: ProtocolNumber
-defaultProtocol = 0
-
------------------------------------------------------------------------------
--- SockAddr
-
-instance Show SockAddr where
-#if defined(DOMAIN_SOCKET_SUPPORT)
-  showsPrec _ (SockAddrUnix str) = showString str
-#endif
-  showsPrec _ (SockAddrInet port ha)
-   = showString (unsafePerformIO (inet_ntoa ha))
-   . showString ":"
-   . shows port
-#if defined(IPV6_SOCKET_SUPPORT)
-  showsPrec _ addr@(SockAddrInet6 port _ _ _)
-   = showChar '['
-   . showString (unsafePerformIO $
-                 fst `liftM` getNameInfo [NI_NUMERICHOST] True False addr >>=
-                 maybe (fail "showsPrec: impossible internal error") return)
-   . showString "]:"
-   . shows port
-#endif
-#if defined(CAN_SOCKET_SUPPORT)
-  showsPrec _ (SockAddrCan ifidx) = shows ifidx
-#endif
-
------------------------------------------------------------------------------
--- Connection Functions
-
--- In the following connection and binding primitives.  The names of
--- the equivalent C functions have been preserved where possible. It
--- should be noted that some of these names used in the C library,
--- \tr{bind} in particular, have a different meaning to many Haskell
--- programmers and have thus been renamed by appending the prefix
--- Socket.
-
--- | Create a new socket using the given address family, socket type
--- and protocol number.  The address family is usually 'AF_INET',
--- 'AF_INET6', or 'AF_UNIX'.  The socket type is usually 'Stream' or
--- 'Datagram'.  The protocol number is usually 'defaultProtocol'.
--- If 'AF_INET6' is used and the socket type is 'Stream' or 'Datagram',
--- the 'IPv6Only' socket option is set to 0 so that both IPv4 and IPv6
--- can be handled with one socket.
---
--- >>> let hints = defaultHints { addrFlags = [AI_NUMERICHOST, AI_NUMERICSERV], addrSocketType = Stream }
--- >>> addr:_ <- getAddrInfo (Just hints) (Just "127.0.0.1") (Just "5000")
--- >>> sock@(MkSocket _ fam stype _ _) <- socket (addrFamily addr) (addrSocketType addr) (addrProtocol addr)
--- >>> fam
--- AF_INET
--- >>> stype
--- Stream
--- >>> bind sock (addrAddress addr)
--- >>> getSocketName sock
--- 127.0.0.1:5000
-socket :: Family         -- Family Name (usually AF_INET)
-       -> SocketType     -- Socket Type (usually Stream)
-       -> ProtocolNumber -- Protocol Number (getProtocolByName to find value)
-       -> IO Socket      -- Unconnected Socket
-socket family stype protocol = do
-    c_stype <- packSocketTypeOrThrow "socket" stype
-    fd <- throwSocketErrorIfMinus1Retry "Network.Socket.socket" $
-                c_socket (packFamily family) c_stype protocol
-    setNonBlockIfNeeded fd
-    socket_status <- newMVar NotConnected
-    withSocketsDo $ return ()
-    let sock = MkSocket fd family stype protocol socket_status
-#if HAVE_DECL_IPV6_V6ONLY
-    -- The default value of the IPv6Only option is platform specific,
-    -- so we explicitly set it to 0 to provide a common default.
-# if defined(mingw32_HOST_OS)
-    -- The IPv6Only option is only supported on Windows Vista and later,
-    -- so trying to change it might throw an error.
-    when (family == AF_INET6 && (stype == Stream || stype == Datagram)) $
-      E.catch (setSocketOption sock IPv6Only 0) $ (\(_ :: E.IOException) -> return ())
-# else
-    when (family == AF_INET6 && (stype == Stream || stype == Datagram)) $
-      setSocketOption sock IPv6Only 0 `onException` close sock
-# endif
-#endif
-    return sock
-
--- | Build a pair of connected socket objects using the given address
--- family, socket type, and protocol number.  Address family, socket
--- type, and protocol number are as for the 'socket' function above.
--- Availability: Unix.
-#if defined(DOMAIN_SOCKET_SUPPORT)
-socketPair :: Family              -- Family Name (usually AF_INET or AF_INET6)
-           -> SocketType          -- Socket Type (usually Stream)
-           -> ProtocolNumber      -- Protocol Number
-           -> IO (Socket, Socket) -- unnamed and connected.
-socketPair family stype protocol = do
-    allocaBytes (2 * sizeOf (1 :: CInt)) $ \ fdArr -> do
-    c_stype <- packSocketTypeOrThrow "socketPair" stype
-    _rc <- throwSocketErrorIfMinus1Retry "Network.Socket.socketpair" $
-                c_socketpair (packFamily family) c_stype protocol fdArr
-    [fd1,fd2] <- peekArray 2 fdArr
-    s1 <- mkNonBlockingSocket fd1
-    s2 <- mkNonBlockingSocket fd2
-    return (s1,s2)
-  where
-    mkNonBlockingSocket fd = do
-       setNonBlockIfNeeded fd
-       stat <- newMVar Connected
-       withSocketsDo $ return ()
-       return (MkSocket fd family stype protocol stat)
-
-foreign import ccall unsafe "socketpair"
-  c_socketpair :: CInt -> CInt -> CInt -> Ptr CInt -> IO CInt
-#endif
-
--- | Set the socket to nonblocking, if applicable to this platform.
---
--- Depending on the platform this is required when using sockets from file
--- descriptors that are passed in through 'recvFd' or other means.
-setNonBlockIfNeeded :: CInt -> IO ()
-setNonBlockIfNeeded fd =
-    System.Posix.Internals.setNonBlockingFD fd True
-
------------------------------------------------------------------------------
--- Binding a socket
-
--- | Bind the socket to an address. The socket must not already be
--- bound.  The 'Family' passed to @bind@ must be the
--- same as that passed to 'socket'.  If the special port number
--- 'aNY_PORT' is passed then the system assigns the next available
--- use port.
-bind :: Socket    -- Unconnected Socket
-           -> SockAddr  -- Address to Bind to
-           -> IO ()
-bind (MkSocket s _family _stype _protocol socketStatus) addr = do
- modifyMVar_ socketStatus $ \ status -> do
- if status /= NotConnected
-  then
-   ioError $ userError $
-     "Network.Socket.bind: can't bind to socket with status " ++ show status
-  else do
-   withSockAddr addr $ \p_addr sz -> do
-   _status <- throwSocketErrorIfMinus1Retry "Network.Socket.bind" $
-     c_bind s p_addr (fromIntegral sz)
-   return Bound
-
------------------------------------------------------------------------------
--- Connecting a socket
-
--- | Connect to a remote socket at address.
-connect :: Socket    -- Unconnected Socket
-        -> SockAddr  -- Socket address stuff
-        -> IO ()
-connect sock@(MkSocket s _family _stype _protocol socketStatus) addr = withSocketsDo $ do
- modifyMVar_ socketStatus $ \currentStatus -> do
- if currentStatus /= NotConnected && currentStatus /= Bound
-  then
-    ioError $ userError $
-      errLoc ++ ": can't connect to socket with status " ++ show currentStatus
-  else do
-    withSockAddr addr $ \p_addr sz -> do
-
-    let connectLoop = do
-           r <- c_connect s p_addr (fromIntegral sz)
-           if r == -1
-               then do
-#if !(defined(HAVE_WINSOCK2_H))
-                   err <- getErrno
-                   case () of
-                     _ | err == eINTR       -> connectLoop
-                     _ | err == eINPROGRESS -> connectBlocked
---                   _ | err == eAGAIN      -> connectBlocked
-                     _otherwise             -> throwSocketError errLoc
-#else
-                   throwSocketError errLoc
-#endif
-               else return ()
-
-        connectBlocked = do
-           threadWaitWrite (fromIntegral s)
-           err <- getSocketOption sock SoError
-           if (err == 0)
-                then return ()
-                else throwSocketErrorCode errLoc (fromIntegral err)
-
-    connectLoop
-    return Connected
- where
-   errLoc = "Network.Socket.connect: " ++ show sock
-
------------------------------------------------------------------------------
--- Listen
-
--- | Listen for connections made to the socket.  The second argument
--- specifies the maximum number of queued connections and should be at
--- least 1; the maximum value is system-dependent (usually 5).
-listen :: Socket  -- Connected & Bound Socket
-       -> Int     -- Queue Length
-       -> IO ()
-listen (MkSocket s _family _stype _protocol socketStatus) backlog = do
- modifyMVar_ socketStatus $ \ status -> do
- if status /= Bound
-   then
-     ioError $ userError $
-       "Network.Socket.listen: can't listen on socket with status " ++ show status
-   else do
-     throwSocketErrorIfMinus1Retry_ "Network.Socket.listen" $
-       c_listen s (fromIntegral backlog)
-     return Listening
-
------------------------------------------------------------------------------
--- Accept
---
--- A call to `accept' only returns when data is available on the given
--- socket, unless the socket has been set to non-blocking.  It will
--- return a new socket which should be used to read the incoming data and
--- should then be closed. Using the socket returned by `accept' allows
--- incoming requests to be queued on the original socket.
-
--- | Accept a connection.  The socket must be bound to an address and
--- listening for connections.  The return value is a pair @(conn,
--- address)@ where @conn@ is a new socket object usable to send and
--- receive data on the connection, and @address@ is the address bound
--- to the socket on the other end of the connection.
-accept :: Socket                        -- Queue Socket
-       -> IO (Socket,                   -- Readable Socket
-              SockAddr)                 -- Peer details
-
-accept sock@(MkSocket s family stype protocol status) = do
- currentStatus <- readMVar status
- okay <- isAcceptable sock
- if not okay
-   then
-     ioError $ userError $
-       "Network.Socket.accept: can't accept socket (" ++
-         show (family, stype, protocol) ++ ") with status " ++
-         show currentStatus
-   else do
-     let sz = sizeOfSockAddrByFamily family
-     allocaBytes sz $ \ sockaddr -> do
-#if defined(mingw32_HOST_OS)
-     new_sock <-
-        if threaded
-           then with (fromIntegral sz) $ \ ptr_len ->
-                  throwSocketErrorIfMinus1Retry "Network.Socket.accept" $
-                    c_accept_safe s sockaddr ptr_len
-           else do
-                paramData <- c_newAcceptParams s (fromIntegral sz) sockaddr
-                rc        <- asyncDoProc c_acceptDoProc paramData
-                new_sock  <- c_acceptNewSock    paramData
-                c_free paramData
-                when (rc /= 0) $
-                     throwSocketErrorCode "Network.Socket.accept" (fromIntegral rc)
-                return new_sock
-#else
-     with (fromIntegral sz) $ \ ptr_len -> do
-# ifdef HAVE_ACCEPT4
-     new_sock <- throwSocketErrorIfMinus1RetryMayBlock "Network.Socket.accept"
-                        (threadWaitRead (fromIntegral s))
-                        (c_accept4 s sockaddr ptr_len (#const SOCK_NONBLOCK))
-# else
-     new_sock <- throwSocketErrorWaitRead sock "Network.Socket.accept"
-                        (c_accept s sockaddr ptr_len)
-     setNonBlockIfNeeded new_sock
-# endif /* HAVE_ACCEPT4 */
-#endif
-     addr <- peekSockAddr sockaddr
-     new_status <- newMVar Connected
-     return ((MkSocket new_sock family stype protocol new_status), addr)
-
-#if defined(mingw32_HOST_OS)
-foreign import ccall unsafe "HsNet.h acceptNewSock"
-  c_acceptNewSock :: Ptr () -> IO CInt
-foreign import ccall unsafe "HsNet.h newAcceptParams"
-  c_newAcceptParams :: CInt -> CInt -> Ptr a -> IO (Ptr ())
-foreign import ccall unsafe "HsNet.h &acceptDoProc"
-  c_acceptDoProc :: FunPtr (Ptr () -> IO Int)
-foreign import ccall unsafe "free"
-  c_free:: Ptr a -> IO ()
-#endif
-
------------------------------------------------------------------------------
--- ** Sending and receiving data
-
--- $sendrecv
---
--- Do not use the @send@ and @recv@ functions defined in this section
--- in new code, as they incorrectly represent binary data as a Unicode
--- string.  As a result, these functions are inefficient and may lead
--- to bugs in the program.  Instead use the @send@ and @recv@
--- functions defined in the "Network.Socket.ByteString" module.
-
------------------------------------------------------------------------------
--- sendTo & recvFrom
-
--- | Send data to the socket.  The recipient can be specified
--- explicitly, so the socket need not be in a connected state.
--- Returns the number of bytes sent.  Applications are responsible for
--- ensuring that all data has been sent.
---
--- NOTE: blocking on Windows unless you compile with -threaded (see
--- GHC ticket #1129)
-{-# WARNING sendTo "Use sendTo defined in \"Network.Socket.ByteString\"" #-}
-sendTo :: Socket        -- (possibly) bound/connected Socket
-       -> String        -- Data to send
-       -> SockAddr
-       -> IO Int        -- Number of Bytes sent
-sendTo sock xs addr = do
- withCStringLen xs $ \(str, len) -> do
-   sendBufTo sock str len addr
-
--- | Send data to the socket.  The recipient can be specified
--- explicitly, so the socket need not be in a connected state.
--- Returns the number of bytes sent.  Applications are responsible for
--- ensuring that all data has been sent.
-sendBufTo :: Socket            -- (possibly) bound/connected Socket
-          -> Ptr a -> Int  -- Data to send
-          -> SockAddr
-          -> IO Int            -- Number of Bytes sent
-sendBufTo sock@(MkSocket s _family _stype _protocol _status) ptr nbytes addr = do
- withSockAddr addr $ \p_addr sz -> do
-   liftM fromIntegral $
-     throwSocketErrorWaitWrite sock "Network.Socket.sendTo" $
-        c_sendto s ptr (fromIntegral $ nbytes) 0{-flags-}
-                        p_addr (fromIntegral sz)
-
--- | Receive data from the socket. The socket need not be in a
--- connected state. Returns @(bytes, nbytes, address)@ where @bytes@
--- is a @String@ of length @nbytes@ representing the data received and
--- @address@ is a 'SockAddr' representing the address of the sending
--- socket.
---
--- NOTE: blocking on Windows unless you compile with -threaded (see
--- GHC ticket #1129)
-{-# WARNING recvFrom "Use recvFrom defined in \"Network.Socket.ByteString\"" #-}
-recvFrom :: Socket -> Int -> IO (String, Int, SockAddr)
-recvFrom sock nbytes =
-  allocaBytes nbytes $ \ptr -> do
-    (len, sockaddr) <- recvBufFrom sock ptr nbytes
-    str <- peekCStringLen (ptr, len)
-    return (str, len, sockaddr)
-
--- | Receive data from the socket, writing it into buffer instead of
--- creating a new string.  The socket need not be in a connected
--- state. Returns @(nbytes, address)@ where @nbytes@ is the number of
--- bytes received and @address@ is a 'SockAddr' representing the
--- address of the sending socket.
---
--- NOTE: blocking on Windows unless you compile with -threaded (see
--- GHC ticket #1129)
-recvBufFrom :: Socket -> Ptr a -> Int -> IO (Int, SockAddr)
-recvBufFrom sock@(MkSocket s family _stype _protocol _status) ptr nbytes
- | nbytes <= 0 = ioError (mkInvalidRecvArgError "Network.Socket.recvFrom")
- | otherwise   =
-    withNewSockAddr family $ \ptr_addr sz -> do
-      alloca $ \ptr_len -> do
-        poke ptr_len (fromIntegral sz)
-        len <- throwSocketErrorWaitRead sock "Network.Socket.recvFrom" $
-                   c_recvfrom s ptr (fromIntegral nbytes) 0{-flags-}
-                                ptr_addr ptr_len
-        let len' = fromIntegral len
-        if len' == 0
-         then ioError (mkEOFError "Network.Socket.recvFrom")
-         else do
-           flg <- isConnected sock
-             -- For at least one implementation (WinSock 2), recvfrom() ignores
-             -- filling in the sockaddr for connected TCP sockets. Cope with
-             -- this by using getPeerName instead.
-           sockaddr <-
-                if flg then
-                   getPeerName sock
-                else
-                   peekSockAddr ptr_addr
-           return (len', sockaddr)
-
------------------------------------------------------------------------------
--- send & recv
-
--- | Send data to the socket. The socket must be connected to a remote
--- socket. Returns the number of bytes sent.  Applications are
--- responsible for ensuring that all data has been sent.
---
--- Sending data to closed socket may lead to undefined behaviour.
-{-# WARNING send "Use send defined in \"Network.Socket.ByteString\"" #-}
-send :: Socket  -- Bound/Connected Socket
-     -> String  -- Data to send
-     -> IO Int  -- Number of Bytes sent
-send sock xs = withCStringLen xs $ \(str, len) ->
-    sendBuf sock (castPtr str) len
-
--- | Send data to the socket. The socket must be connected to a remote
--- socket. Returns the number of bytes sent.  Applications are
--- responsible for ensuring that all data has been sent.
---
--- Sending data to closed socket may lead to undefined behaviour.
-sendBuf :: Socket     -- Bound/Connected Socket
-        -> Ptr Word8  -- Pointer to the data to send
-        -> Int        -- Length of the buffer
-        -> IO Int     -- Number of Bytes sent
-sendBuf sock@(MkSocket s _family _stype _protocol _status) str len = do
-   liftM fromIntegral $
-#if defined(mingw32_HOST_OS)
--- writeRawBufferPtr is supposed to handle checking for errors, but it's broken
--- on x86_64 because of GHC bug #12010 so we duplicate the check here. The call
--- to throwSocketErrorIfMinus1Retry can be removed when no GHC version with the
--- bug is supported.
-    throwSocketErrorIfMinus1Retry "Network.Socket.sendBuf" $ writeRawBufferPtr
-      "Network.Socket.sendBuf"
-      (socket2FD sock)
-      (castPtr str)
-      0
-      (fromIntegral len)
-#else
-     throwSocketErrorWaitWrite sock "Network.Socket.sendBuf" $
-        c_send s str (fromIntegral len) 0{-flags-}
-#endif
-
-
--- | Receive data from the socket.  The socket must be in a connected
--- state. This function may return fewer bytes than specified.  If the
--- message is longer than the specified length, it may be discarded
--- depending on the type of socket.  This function may block until a
--- message arrives.
---
--- Considering hardware and network realities, the maximum number of
--- bytes to receive should be a small power of 2, e.g., 4096.
---
--- For TCP sockets, a zero length return value means the peer has
--- closed its half side of the connection.
---
--- Receiving data from closed socket may lead to undefined behaviour.
-{-# WARNING recv "Use recv defined in \"Network.Socket.ByteString\"" #-}
-recv :: Socket -> Int -> IO String
-recv sock l = fst <$> recvLen sock l
-
-{-# WARNING recvLen "Use recvLen defined in \"Network.Socket.ByteString\"" #-}
-recvLen :: Socket -> Int -> IO (String, Int)
-recvLen sock nbytes =
-     allocaBytes nbytes $ \ptr -> do
-        len <- recvBuf sock ptr nbytes
-        s <- peekCStringLen (castPtr ptr,len)
-        return (s, len)
-
--- | Receive data from the socket.  The socket must be in a connected
--- state. This function may return fewer bytes than specified.  If the
--- message is longer than the specified length, it may be discarded
--- depending on the type of socket.  This function may block until a
--- message arrives.
---
--- Considering hardware and network realities, the maximum number of
--- bytes to receive should be a small power of 2, e.g., 4096.
---
--- For TCP sockets, a zero length return value means the peer has
--- closed its half side of the connection.
---
--- Receiving data from closed socket may lead to undefined behaviour.
-recvBuf :: Socket -> Ptr Word8 -> Int -> IO Int
-recvBuf sock@(MkSocket s _family _stype _protocol _status) ptr nbytes
- | nbytes <= 0 = ioError (mkInvalidRecvArgError "Network.Socket.recvBuf")
- | otherwise   = do
-        len <-
-#if defined(mingw32_HOST_OS)
--- see comment in sendBuf above.
-            throwSocketErrorIfMinus1Retry "Network.Socket.recvBuf" $
-                readRawBufferPtr "Network.Socket.recvBuf"
-                (socket2FD sock) ptr 0 (fromIntegral nbytes)
-#else
-               throwSocketErrorWaitRead sock "Network.Socket.recvBuf" $
-                   c_recv s (castPtr ptr) (fromIntegral nbytes) 0{-flags-}
-#endif
-        let len' = fromIntegral len
-        if len' == 0
-         then ioError (mkEOFError "Network.Socket.recvBuf")
-         else return len'
-
-
--- ---------------------------------------------------------------------------
--- socketPort
---
--- The port number the given socket is currently connected to can be
--- determined by calling $port$, is generally only useful when bind
--- was given $aNY\_PORT$.
-
-socketPort :: Socket            -- Connected & Bound Socket
-           -> IO PortNumber     -- Port Number of Socket
-socketPort sock@(MkSocket _ AF_INET _ _ _) = do
-    (SockAddrInet port _) <- getSocketName sock
-    return port
-#if defined(IPV6_SOCKET_SUPPORT)
-socketPort sock@(MkSocket _ AF_INET6 _ _ _) = do
-    (SockAddrInet6 port _ _ _) <- getSocketName sock
-    return port
-#endif
-socketPort (MkSocket _ family _ _ _) =
-    ioError $ userError $
-      "Network.Socket.socketPort: address family '" ++ show family ++
-      "' not supported."
-
-
--- ---------------------------------------------------------------------------
--- getPeerName
-
--- Calling $getPeerName$ returns the address details of the machine,
--- other than the local one, which is connected to the socket. This is
--- used in programs such as FTP to determine where to send the
--- returning data.  The corresponding call to get the details of the
--- local machine is $getSocketName$.
-
-getPeerName   :: Socket -> IO SockAddr
-getPeerName (MkSocket s family _ _ _) = do
- withNewSockAddr family $ \ptr sz -> do
-   with (fromIntegral sz) $ \int_star -> do
-   throwSocketErrorIfMinus1Retry_ "Network.Socket.getPeerName" $
-     c_getpeername s ptr int_star
-   _sz <- peek int_star
-   peekSockAddr ptr
-
-getSocketName :: Socket -> IO SockAddr
-getSocketName (MkSocket s family _ _ _) = do
- withNewSockAddr family $ \ptr sz -> do
-   with (fromIntegral sz) $ \int_star -> do
-   throwSocketErrorIfMinus1Retry_ "Network.Socket.getSocketName" $
-     c_getsockname s ptr int_star
-   peekSockAddr ptr
-
------------------------------------------------------------------------------
--- Socket Properties
-
--- | Socket options for use with 'setSocketOption' and 'getSocketOption'.
---
--- The existence of a constructor does not imply that the relevant option
--- is supported on your system: see 'isSupportedSocketOption'
-data SocketOption
-    = Debug         -- ^ SO_DEBUG
-    | ReuseAddr     -- ^ SO_REUSEADDR
-    | Type          -- ^ SO_TYPE
-    | SoError       -- ^ SO_ERROR
-    | DontRoute     -- ^ SO_DONTROUTE
-    | Broadcast     -- ^ SO_BROADCAST
-    | SendBuffer    -- ^ SO_SNDBUF
-    | RecvBuffer    -- ^ SO_RCVBUF
-    | KeepAlive     -- ^ SO_KEEPALIVE
-    | OOBInline     -- ^ SO_OOBINLINE
-    | TimeToLive    -- ^ IP_TTL
-    | MaxSegment    -- ^ TCP_MAXSEG
-    | NoDelay       -- ^ TCP_NODELAY
-    | Cork          -- ^ TCP_CORK
-    | Linger        -- ^ SO_LINGER
-    | ReusePort     -- ^ SO_REUSEPORT
-    | RecvLowWater  -- ^ SO_RCVLOWAT
-    | SendLowWater  -- ^ SO_SNDLOWAT
-    | RecvTimeOut   -- ^ SO_RCVTIMEO
-    | SendTimeOut   -- ^ SO_SNDTIMEO
-    | UseLoopBack   -- ^ SO_USELOOPBACK
-    | UserTimeout   -- ^ TCP_USER_TIMEOUT
-    | IPv6Only      -- ^ IPV6_V6ONLY
-    | CustomSockOpt (CInt, CInt)
-    deriving (Show, Typeable)
-
--- | Does the 'SocketOption' exist on this system?
-isSupportedSocketOption :: SocketOption -> Bool
-isSupportedSocketOption = isJust . packSocketOption
-
--- | For a socket option, return Just (level, value) where level is the
--- corresponding C option level constant (e.g. SOL_SOCKET) and value is
--- the option constant itself (e.g. SO_DEBUG)
--- If either constant does not exist, return Nothing.
-packSocketOption :: SocketOption -> Maybe (CInt, CInt)
-packSocketOption so =
-  -- The Just here is a hack to disable GHC's overlapping pattern detection:
-  -- the problem is if all constants are present, the fallback pattern is
-  -- redundant, but if they aren't then it isn't. Hence we introduce an
-  -- extra pattern (Nothing) that can't possibly happen, so that the
-  -- fallback is always (in principle) necessary.
-  -- I feel a little bad for including this, but such are the sacrifices we
-  -- make while working with CPP - excluding the fallback pattern correctly
-  -- would be a serious nuisance.
-  -- (NB: comments elsewhere in this file refer to this one)
-  case Just so of
-#ifdef SOL_SOCKET
-#ifdef SO_DEBUG
-    Just Debug         -> Just ((#const SOL_SOCKET), (#const SO_DEBUG))
-#endif
-#ifdef SO_REUSEADDR
-    Just ReuseAddr     -> Just ((#const SOL_SOCKET), (#const SO_REUSEADDR))
-#endif
-#ifdef SO_TYPE
-    Just Type          -> Just ((#const SOL_SOCKET), (#const SO_TYPE))
-#endif
-#ifdef SO_ERROR
-    Just SoError       -> Just ((#const SOL_SOCKET), (#const SO_ERROR))
-#endif
-#ifdef SO_DONTROUTE
-    Just DontRoute     -> Just ((#const SOL_SOCKET), (#const SO_DONTROUTE))
-#endif
-#ifdef SO_BROADCAST
-    Just Broadcast     -> Just ((#const SOL_SOCKET), (#const SO_BROADCAST))
-#endif
-#ifdef SO_SNDBUF
-    Just SendBuffer    -> Just ((#const SOL_SOCKET), (#const SO_SNDBUF))
-#endif
-#ifdef SO_RCVBUF
-    Just RecvBuffer    -> Just ((#const SOL_SOCKET), (#const SO_RCVBUF))
-#endif
-#ifdef SO_KEEPALIVE
-    Just KeepAlive     -> Just ((#const SOL_SOCKET), (#const SO_KEEPALIVE))
-#endif
-#ifdef SO_OOBINLINE
-    Just OOBInline     -> Just ((#const SOL_SOCKET), (#const SO_OOBINLINE))
-#endif
-#ifdef SO_LINGER
-    Just Linger        -> Just ((#const SOL_SOCKET), (#const SO_LINGER))
-#endif
-#ifdef SO_REUSEPORT
-    Just ReusePort     -> Just ((#const SOL_SOCKET), (#const SO_REUSEPORT))
-#endif
-#ifdef SO_RCVLOWAT
-    Just RecvLowWater  -> Just ((#const SOL_SOCKET), (#const SO_RCVLOWAT))
-#endif
-#ifdef SO_SNDLOWAT
-    Just SendLowWater  -> Just ((#const SOL_SOCKET), (#const SO_SNDLOWAT))
-#endif
-#ifdef SO_RCVTIMEO
-    Just RecvTimeOut   -> Just ((#const SOL_SOCKET), (#const SO_RCVTIMEO))
-#endif
-#ifdef SO_SNDTIMEO
-    Just SendTimeOut   -> Just ((#const SOL_SOCKET), (#const SO_SNDTIMEO))
-#endif
-#ifdef SO_USELOOPBACK
-    Just UseLoopBack   -> Just ((#const SOL_SOCKET), (#const SO_USELOOPBACK))
-#endif
-#endif // SOL_SOCKET
-#if HAVE_DECL_IPPROTO_IP
-#ifdef IP_TTL
-    Just TimeToLive    -> Just ((#const IPPROTO_IP), (#const IP_TTL))
-#endif
-#endif // HAVE_DECL_IPPROTO_IP
-#if HAVE_DECL_IPPROTO_TCP
-#ifdef TCP_MAXSEG
-    Just MaxSegment    -> Just ((#const IPPROTO_TCP), (#const TCP_MAXSEG))
-#endif
-#ifdef TCP_NODELAY
-    Just NoDelay       -> Just ((#const IPPROTO_TCP), (#const TCP_NODELAY))
-#endif
-#ifdef TCP_USER_TIMEOUT
-    Just UserTimeout   -> Just ((#const IPPROTO_TCP), (#const TCP_USER_TIMEOUT))
-#endif
-#ifdef TCP_CORK
-    Just Cork          -> Just ((#const IPPROTO_TCP), (#const TCP_CORK))
-#endif
-#endif // HAVE_DECL_IPPROTO_TCP
-#if HAVE_DECL_IPPROTO_IPV6
-#if HAVE_DECL_IPV6_V6ONLY
-    Just IPv6Only      -> Just ((#const IPPROTO_IPV6), (#const IPV6_V6ONLY))
-#endif
-#endif // HAVE_DECL_IPPROTO_IPV6
-    Just (CustomSockOpt opt) -> Just opt
-    _             -> Nothing
-
--- | Return the option level and option value if they exist,
--- otherwise throw an error that begins "Network.Socket." ++ the String
--- parameter
-packSocketOption' :: String -> SocketOption -> IO (CInt, CInt)
-packSocketOption' caller so = maybe err return (packSocketOption so)
- where
-  err = ioError . userError . concat $ ["Network.Socket.", caller,
-    ": socket option ", show so, " unsupported on this system"]
-
--- | Set a socket option that expects an Int value.
--- There is currently no API to set e.g. the timeval socket options
-setSocketOption :: Socket
-                -> SocketOption -- Option Name
-                -> Int          -- Option Value
-                -> IO ()
-setSocketOption (MkSocket s _ _ _ _) so v = do
-   (level, opt) <- packSocketOption' "setSocketOption" so
-   with (fromIntegral v) $ \ptr_v -> do
-   throwSocketErrorIfMinus1_ "Network.Socket.setSocketOption" $
-       c_setsockopt s level opt ptr_v
-          (fromIntegral (sizeOf (undefined :: CInt)))
-   return ()
-
-
--- | Get a socket option that gives an Int value.
--- There is currently no API to get e.g. the timeval socket options
-getSocketOption :: Socket
-                -> SocketOption  -- Option Name
-                -> IO Int        -- Option Value
-getSocketOption (MkSocket s _ _ _ _) so = do
-   (level, opt) <- packSocketOption' "getSocketOption" so
-   alloca $ \ptr_v ->
-     with (fromIntegral (sizeOf (undefined :: CInt))) $ \ptr_sz -> do
-       throwSocketErrorIfMinus1Retry_ "Network.Socket.getSocketOption" $
-         c_getsockopt s level opt ptr_v ptr_sz
-       fromIntegral `liftM` peek ptr_v
-
-
-#if defined(HAVE_STRUCT_UCRED) || defined(HAVE_GETPEEREID)
--- | Returns the processID, userID and groupID of the socket's peer.
---
--- Only available on platforms that support SO_PEERCRED or GETPEEREID(3)
--- on domain sockets.
--- GETPEEREID(3) returns userID and groupID. processID is always 0.
-getPeerCred :: Socket -> IO (CUInt, CUInt, CUInt)
-getPeerCred sock = do
-#ifdef HAVE_STRUCT_UCRED
-  let fd = fdSocket sock
-  let sz = (#const sizeof(struct ucred))
-  allocaBytes sz $ \ ptr_cr ->
-   with (fromIntegral sz) $ \ ptr_sz -> do
-     _ <- ($) throwSocketErrorIfMinus1Retry "Network.Socket.getPeerCred" $
-       c_getsockopt fd (#const SOL_SOCKET) (#const SO_PEERCRED) ptr_cr ptr_sz
-     pid <- (#peek struct ucred, pid) ptr_cr
-     uid <- (#peek struct ucred, uid) ptr_cr
-     gid <- (#peek struct ucred, gid) ptr_cr
-     return (pid, uid, gid)
-#else
-  (uid,gid) <- getPeerEid sock
-  return (0,uid,gid)
-#endif
-
-#ifdef HAVE_GETPEEREID
--- | The getpeereid() function returns the effective user and group IDs of the
--- peer connected to a UNIX-domain socket
-getPeerEid :: Socket -> IO (CUInt, CUInt)
-getPeerEid sock = do
-  let fd = fdSocket sock
-  alloca $ \ ptr_uid ->
-    alloca $ \ ptr_gid -> do
-      throwSocketErrorIfMinus1Retry_ "Network.Socket.getPeerEid" $
-        c_getpeereid fd ptr_uid ptr_gid
-      uid <- peek ptr_uid
-      gid <- peek ptr_gid
-      return (uid, gid)
-#endif
-#endif
-
-##if !(MIN_VERSION_base(4,3,1))
-closeFdWith closer fd = closer fd
-##endif
-
-#if defined(DOMAIN_SOCKET_SUPPORT)
--- sending/receiving ancillary socket data; low-level mechanism
--- for transmitting file descriptors, mainly.
-sendFd :: Socket -> CInt -> IO ()
-sendFd sock outfd = do
-  _ <- ($) throwSocketErrorWaitWrite sock "Network.Socket.sendFd" $
-     c_sendFd (fdSocket sock) outfd
-   -- Note: If Winsock supported FD-passing, thi would have been
-   -- incorrect (since socket FDs need to be closed via closesocket().)
-  closeFd outfd
-
--- | Receive a file descriptor over a domain socket. Note that the resulting
--- file descriptor may have to be put into non-blocking mode in order to be
--- used safely. See 'setNonBlockIfNeeded'.
-recvFd :: Socket -> IO CInt
-recvFd sock = do
-  theFd <- throwSocketErrorWaitRead sock "Network.Socket.recvFd" $
-               c_recvFd (fdSocket sock)
-  return theFd
-
-foreign import ccall SAFE_ON_WIN "sendFd" c_sendFd :: CInt -> CInt -> IO CInt
-foreign import ccall SAFE_ON_WIN "recvFd" c_recvFd :: CInt -> IO CInt
-
-#endif
-
--- ---------------------------------------------------------------------------
--- Utility Functions
-
-aNY_PORT :: PortNumber
-aNY_PORT = 0
-
--- | The IPv4 wild card address.
-
-iNADDR_ANY :: HostAddress
-iNADDR_ANY = htonl (#const INADDR_ANY)
-
--- | Converts the from host byte order to network byte order.
-foreign import CALLCONV unsafe "htonl" htonl :: Word32 -> Word32
--- | Converts the from network byte order to host byte order.
-foreign import CALLCONV unsafe "ntohl" ntohl :: Word32 -> Word32
-
-#if defined(IPV6_SOCKET_SUPPORT)
--- | The IPv6 wild card address.
-
-iN6ADDR_ANY :: HostAddress6
-iN6ADDR_ANY = (0, 0, 0, 0)
-#endif
-
-sOMAXCONN :: Int
-sOMAXCONN = #const SOMAXCONN
-
-sOL_SOCKET :: Int
-sOL_SOCKET = #const SOL_SOCKET
-
-#ifdef SCM_RIGHTS
-sCM_RIGHTS :: Int
-sCM_RIGHTS = #const SCM_RIGHTS
-#endif
-
--- | This is the value of SOMAXCONN, typically 128.
--- 128 is good enough for normal network servers but
--- is too small for high performance servers.
-maxListenQueue :: Int
-maxListenQueue = sOMAXCONN
-
--- -----------------------------------------------------------------------------
-
-data ShutdownCmd
- = ShutdownReceive
- | ShutdownSend
- | ShutdownBoth
- deriving Typeable
-
-sdownCmdToInt :: ShutdownCmd -> CInt
-sdownCmdToInt ShutdownReceive = 0
-sdownCmdToInt ShutdownSend    = 1
-sdownCmdToInt ShutdownBoth    = 2
-
--- | Shut down one or both halves of the connection, depending on the
--- second argument to the function.  If the second argument is
--- 'ShutdownReceive', further receives are disallowed.  If it is
--- 'ShutdownSend', further sends are disallowed.  If it is
--- 'ShutdownBoth', further sends and receives are disallowed.
-shutdown :: Socket -> ShutdownCmd -> IO ()
-shutdown (MkSocket s _ _ _ _) stype = do
-  throwSocketErrorIfMinus1Retry_ "Network.Socket.shutdown" $
-    c_shutdown s (sdownCmdToInt stype)
-  return ()
-
--- -----------------------------------------------------------------------------
-
--- | Close the socket. Sending data to or receiving data from closed socket
--- may lead to undefined behaviour.
-close :: Socket -> IO ()
-close (MkSocket s _ _ _ socketStatus) = do
- modifyMVar_ socketStatus $ \ status ->
-   case status of
-     ConvertedToHandle ->
-         ioError (userError ("close: converted to a Handle, use hClose instead"))
-     Closed ->
-         return status
-     _ -> closeFdWith (closeFd . fromIntegral) (fromIntegral s) >> return Closed
-
--- -----------------------------------------------------------------------------
-
--- | Determines whether 'close' has been used on the 'Socket'. This
--- does /not/ indicate any status about the socket beyond this. If the
--- socket has been closed remotely, this function can still return
--- 'True'.
-isConnected :: Socket -> IO Bool
-isConnected (MkSocket _ _ _ _ status) = do
-    value <- readMVar status
-    return (value == Connected)
-
--- -----------------------------------------------------------------------------
--- Socket Predicates
-
-isBound :: Socket -> IO Bool
-isBound (MkSocket _ _ _ _ status) = do
-    value <- readMVar status
-    return (value == Bound)
-
-isListening :: Socket -> IO Bool
-isListening (MkSocket _ _ _  _ status) = do
-    value <- readMVar status
-    return (value == Listening)
-
-isReadable  :: Socket -> IO Bool
-isReadable (MkSocket _ _ _ _ status) = do
-    value <- readMVar status
-    return (value == Listening || value == Connected)
-
-isWritable  :: Socket -> IO Bool
-isWritable = isReadable -- sort of.
-
-isAcceptable :: Socket -> IO Bool
-#if defined(DOMAIN_SOCKET_SUPPORT)
-isAcceptable (MkSocket _ AF_UNIX x _ status)
-    | x == Stream || x == SeqPacket = do
-        value <- readMVar status
-        return (value == Connected || value == Bound || value == Listening)
-isAcceptable (MkSocket _ AF_UNIX _ _ _) = return False
-#endif
-isAcceptable (MkSocket _ _ _ _ status) = do
-    value <- readMVar status
-    return (value == Connected || value == Listening)
-
--- -----------------------------------------------------------------------------
--- Internet address manipulation routines:
-
-inet_addr :: String -> IO HostAddress
-inet_addr ipstr = withSocketsDo $ do
-   withCString ipstr $ \str -> do
-   had <- c_inet_addr str
-   if had == -1
-    then ioError $ userError $
-      "Network.Socket.inet_addr: Malformed address: " ++ ipstr
-    else return had  -- network byte order
-
-inet_ntoa :: HostAddress -> IO String
-inet_ntoa haddr = withSocketsDo $ do
-  pstr <- c_inet_ntoa haddr
-  peekCString pstr
-
--- | Turns a Socket into an 'Handle'. By default, the new handle is
--- unbuffered. Use 'System.IO.hSetBuffering' to change the buffering.
---
--- Note that since a 'Handle' is automatically closed by a finalizer
--- when it is no longer referenced, you should avoid doing any more
--- operations on the 'Socket' after calling 'socketToHandle'.  To
--- close the 'Socket' after 'socketToHandle', call 'System.IO.hClose'
--- on the 'Handle'.
-
-socketToHandle :: Socket -> IOMode -> IO Handle
-socketToHandle s@(MkSocket fd _ _ _ socketStatus) mode = do
- modifyMVar socketStatus $ \ status ->
-    if status == ConvertedToHandle
-        then ioError (userError ("socketToHandle: already a Handle"))
-        else do
-    h <- fdToHandle' (fromIntegral fd) (Just GHC.IO.Device.Stream) True (show s) mode True{-bin-}
-    hSetBuffering h NoBuffering
-    return (ConvertedToHandle, h)
-
--- | Pack a list of values into a bitmask.  The possible mappings from
--- value to bit-to-set are given as the first argument.  We assume
--- that each value can cause exactly one bit to be set; unpackBits will
--- break if this property is not true.
-
-packBits :: (Eq a, Num b, Bits b) => [(a, b)] -> [a] -> b
-
-packBits mapping xs = foldl' pack 0 mapping
-    where pack acc (k, v) | k `elem` xs = acc .|. v
-                          | otherwise   = acc
-
--- | Unpack a bitmask into a list of values.
-
-unpackBits :: (Num b, Bits b) => [(a, b)] -> b -> [a]
-
--- Be permissive and ignore unknown bit values. At least on OS X,
--- getaddrinfo returns an ai_flags field with bits set that have no
--- entry in <netdb.h>.
-unpackBits [] _    = []
-unpackBits ((k,v):xs) r
-    | r .&. v /= 0 = k : unpackBits xs (r .&. complement v)
-    | otherwise    = unpackBits xs r
-
------------------------------------------------------------------------------
--- Address and service lookups
-
-#if defined(IPV6_SOCKET_SUPPORT)
-
--- | Flags that control the querying behaviour of 'getAddrInfo'.
---   For more information, see <https://tools.ietf.org/html/rfc3493#page-25>
-data AddrInfoFlag =
-    -- | The list of returned 'AddrInfo' values will
-    --   only contain IPv4 addresses if the local system has at least
-    --   one IPv4 interface configured, and likewise for IPv6.
-    --   (Only some platforms support this.)
-      AI_ADDRCONFIG
-    -- | If 'AI_ALL' is specified, return all matching IPv6 and
-    --   IPv4 addresses.  Otherwise, this flag has no effect.
-    --   (Only some platforms support this.)
-    | AI_ALL
-    -- | The 'addrCanonName' field of the first returned
-    --   'AddrInfo' will contain the "canonical name" of the host.
-    | AI_CANONNAME
-    -- | The 'HostName' argument /must/ be a numeric
-    --   address in string form, and network name lookups will not be
-    --   attempted.
-    | AI_NUMERICHOST
-    -- | The 'ServiceName' argument /must/ be a port
-    --   number in string form, and service name lookups will not be
-    --   attempted. (Only some platforms support this.)
-    | AI_NUMERICSERV
-    -- | If no 'HostName' value is provided, the network
-    --   address in each 'SockAddr'
-    --   will be left as a "wild card", i.e. as either 'iNADDR_ANY'
-    --   or 'iN6ADDR_ANY'.  This is useful for server applications that
-    --   will accept connections from any client.
-    | AI_PASSIVE
-    -- | If an IPv6 lookup is performed, and no IPv6
-    --   addresses are found, IPv6-mapped IPv4 addresses will be
-    --   returned. (Only some platforms support this.)
-    | AI_V4MAPPED
-    deriving (Eq, Read, Show, Typeable)
-
-aiFlagMapping :: [(AddrInfoFlag, CInt)]
-
-aiFlagMapping =
-    [
-#if HAVE_DECL_AI_ADDRCONFIG
-     (AI_ADDRCONFIG, #const AI_ADDRCONFIG),
-#else
-     (AI_ADDRCONFIG, 0),
-#endif
-#if HAVE_DECL_AI_ALL
-     (AI_ALL, #const AI_ALL),
-#else
-     (AI_ALL, 0),
-#endif
-     (AI_CANONNAME, #const AI_CANONNAME),
-     (AI_NUMERICHOST, #const AI_NUMERICHOST),
-#if HAVE_DECL_AI_NUMERICSERV
-     (AI_NUMERICSERV, #const AI_NUMERICSERV),
-#else
-     (AI_NUMERICSERV, 0),
-#endif
-     (AI_PASSIVE, #const AI_PASSIVE),
-#if HAVE_DECL_AI_V4MAPPED
-     (AI_V4MAPPED, #const AI_V4MAPPED)
-#else
-     (AI_V4MAPPED, 0)
-#endif
-    ]
-
--- | Indicate whether the given 'AddrInfoFlag' will have any effect on
--- this system.
-addrInfoFlagImplemented :: AddrInfoFlag -> Bool
-addrInfoFlagImplemented f = packBits aiFlagMapping [f] /= 0
-
-data AddrInfo =
-    AddrInfo {
-        addrFlags :: [AddrInfoFlag],
-        addrFamily :: Family,
-        addrSocketType :: SocketType,
-        addrProtocol :: ProtocolNumber,
-        addrAddress :: SockAddr,
-        addrCanonName :: Maybe String
-        }
-    deriving (Eq, Show, Typeable)
-
-instance Storable AddrInfo where
-    sizeOf    _ = #const sizeof(struct addrinfo)
-    alignment _ = alignment (undefined :: CInt)
-
-    peek p = do
-        ai_flags <- (#peek struct addrinfo, ai_flags) p
-        ai_family <- (#peek struct addrinfo, ai_family) p
-        ai_socktype <- (#peek struct addrinfo, ai_socktype) p
-        ai_protocol <- (#peek struct addrinfo, ai_protocol) p
-        ai_addr <- (#peek struct addrinfo, ai_addr) p >>= peekSockAddr
-        ai_canonname_ptr <- (#peek struct addrinfo, ai_canonname) p
-
-        ai_canonname <- if ai_canonname_ptr == nullPtr
-                        then return Nothing
-                        else liftM Just $ peekCString ai_canonname_ptr
-
-        socktype <- unpackSocketType' "AddrInfo.peek" ai_socktype
-        return (AddrInfo
-                {
-                 addrFlags = unpackBits aiFlagMapping ai_flags,
-                 addrFamily = unpackFamily ai_family,
-                 addrSocketType = socktype,
-                 addrProtocol = ai_protocol,
-                 addrAddress = ai_addr,
-                 addrCanonName = ai_canonname
-                })
-
-    poke p (AddrInfo flags family socketType protocol _ _) = do
-        c_stype <- packSocketTypeOrThrow "AddrInfo.poke" socketType
-
-        (#poke struct addrinfo, ai_flags) p (packBits aiFlagMapping flags)
-        (#poke struct addrinfo, ai_family) p (packFamily family)
-        (#poke struct addrinfo, ai_socktype) p c_stype
-        (#poke struct addrinfo, ai_protocol) p protocol
-
-        -- stuff below is probably not needed, but let's zero it for safety
-
-        (#poke struct addrinfo, ai_addrlen) p (0::CSize)
-        (#poke struct addrinfo, ai_addr) p nullPtr
-        (#poke struct addrinfo, ai_canonname) p nullPtr
-        (#poke struct addrinfo, ai_next) p nullPtr
-
--- | Flags that control the querying behaviour of 'getNameInfo'.
---   For more information, see <https://tools.ietf.org/html/rfc3493#page-30>
-data NameInfoFlag =
-    -- | Resolve a datagram-based service name.  This is
-    --   required only for the few protocols that have different port
-    --   numbers for their datagram-based versions than for their
-    --   stream-based versions.
-      NI_DGRAM
-    -- | If the hostname cannot be looked up, an IO error is thrown.
-    | NI_NAMEREQD
-    -- | If a host is local, return only the hostname part of the FQDN.
-    | NI_NOFQDN
-    -- | The name of the host is not looked up.
-    --   Instead, a numeric representation of the host's
-    --   address is returned.  For an IPv4 address, this will be a
-    --   dotted-quad string.  For IPv6, it will be colon-separated
-    --   hexadecimal.
-    | NI_NUMERICHOST
-    -- | The name of the service is not
-    --   looked up.  Instead, a numeric representation of the
-    --   service is returned.
-    | NI_NUMERICSERV
-    deriving (Eq, Read, Show, Typeable)
-
-niFlagMapping :: [(NameInfoFlag, CInt)]
-
-niFlagMapping = [(NI_DGRAM, #const NI_DGRAM),
-                 (NI_NAMEREQD, #const NI_NAMEREQD),
-                 (NI_NOFQDN, #const NI_NOFQDN),
-                 (NI_NUMERICHOST, #const NI_NUMERICHOST),
-                 (NI_NUMERICSERV, #const NI_NUMERICSERV)]
-
--- | Default hints for address lookup with 'getAddrInfo'.  The values
--- of the 'addrAddress' and 'addrCanonName' fields are 'undefined',
--- and are never inspected by 'getAddrInfo'.
---
--- >>> addrFlags defaultHints
--- []
--- >>> addrFamily defaultHints
--- AF_UNSPEC
--- >>> addrSocketType defaultHints
--- NoSocketType
--- >>> addrProtocol defaultHints
--- 0
-
-defaultHints :: AddrInfo
-defaultHints = AddrInfo {
-                         addrFlags = [],
-                         addrFamily = AF_UNSPEC,
-                         addrSocketType = NoSocketType,
-                         addrProtocol = defaultProtocol,
-                         addrAddress = undefined,
-                         addrCanonName = undefined
-                        }
-
--- | Resolve a host or service name to one or more addresses.
--- The 'AddrInfo' values that this function returns contain 'SockAddr'
--- values that you can pass directly to 'connect' or
--- 'bind'.
---
--- This function is protocol independent.  It can return both IPv4 and
--- IPv6 address information.
---
--- The 'AddrInfo' argument specifies the preferred query behaviour,
--- socket options, or protocol.  You can override these conveniently
--- using Haskell's record update syntax on 'defaultHints', for example
--- as follows:
---
--- >>> let hints = defaultHints { addrFlags = [AI_NUMERICHOST], addrSocketType = Stream }
---
--- You must provide a 'Just' value for at least one of the 'HostName'
--- or 'ServiceName' arguments.  'HostName' can be either a numeric
--- network address (dotted quad for IPv4, colon-separated hex for
--- IPv6) or a hostname.  In the latter case, its addresses will be
--- looked up unless 'AI_NUMERICHOST' is specified as a hint.  If you
--- do not provide a 'HostName' value /and/ do not set 'AI_PASSIVE' as
--- a hint, network addresses in the result will contain the address of
--- the loopback interface.
---
--- If the query fails, this function throws an IO exception instead of
--- returning an empty list.  Otherwise, it returns a non-empty list
--- of 'AddrInfo' values.
---
--- There are several reasons why a query might result in several
--- values.  For example, the queried-for host could be multihomed, or
--- the service might be available via several protocols.
---
--- Note: the order of arguments is slightly different to that defined
--- for @getaddrinfo@ in RFC 2553.  The 'AddrInfo' parameter comes first
--- to make partial application easier.
---
--- >>> addr:_ <- getAddrInfo (Just hints) (Just "127.0.0.1") (Just "http")
--- >>> addrAddress addr
--- 127.0.0.1:80
-
-getAddrInfo :: Maybe AddrInfo -- ^ preferred socket type or protocol
-            -> Maybe HostName -- ^ host name to look up
-            -> Maybe ServiceName -- ^ service name to look up
-            -> IO [AddrInfo] -- ^ resolved addresses, with "best" first
-
-getAddrInfo hints node service = withSocketsDo $
-  maybeWith withCString node $ \c_node ->
-    maybeWith withCString service $ \c_service ->
-      maybeWith with filteredHints $ \c_hints ->
-        alloca $ \ptr_ptr_addrs -> do
-          ret <- c_getaddrinfo c_node c_service c_hints ptr_ptr_addrs
-          case ret of
-            0 -> do ptr_addrs <- peek ptr_ptr_addrs
-                    ais <- followAddrInfo ptr_addrs
-                    c_freeaddrinfo ptr_addrs
-                    return ais
-            _ -> do err <- gai_strerror ret
-                    ioError (ioeSetErrorString
-                             (mkIOError NoSuchThing "Network.Socket.getAddrInfo" Nothing
-                              Nothing) err)
-    -- Leaving out the service and using AI_NUMERICSERV causes a
-    -- segfault on OS X 10.8.2. This code removes AI_NUMERICSERV
-    -- (which has no effect) in that case.
-  where
-#if defined(darwin_HOST_OS)
-    filteredHints = case service of
-        Nothing -> fmap (\ h -> h { addrFlags = delete AI_NUMERICSERV (addrFlags h) }) hints
-        _       -> hints
-#else
-    filteredHints = hints
-#endif
-
-followAddrInfo :: Ptr AddrInfo -> IO [AddrInfo]
-
-followAddrInfo ptr_ai | ptr_ai == nullPtr = return []
-                      | otherwise = do
-    a <- peek ptr_ai
-    as <- (#peek struct addrinfo, ai_next) ptr_ai >>= followAddrInfo
-    return (a:as)
-
-foreign import ccall safe "hsnet_getaddrinfo"
-    c_getaddrinfo :: CString -> CString -> Ptr AddrInfo -> Ptr (Ptr AddrInfo)
-                  -> IO CInt
-
-foreign import ccall safe "hsnet_freeaddrinfo"
-    c_freeaddrinfo :: Ptr AddrInfo -> IO ()
-
-gai_strerror :: CInt -> IO String
-
-#ifdef HAVE_GAI_STRERROR
-gai_strerror n = c_gai_strerror n >>= peekCString
-
-foreign import ccall safe "gai_strerror"
-    c_gai_strerror :: CInt -> IO CString
-#else
-gai_strerror n = ioError $ userError $ "Network.Socket.gai_strerror not supported: " ++ show n
-#endif
-
-withCStringIf :: Bool -> Int -> (CSize -> CString -> IO a) -> IO a
-withCStringIf False _ f = f 0 nullPtr
-withCStringIf True n f = allocaBytes n (f (fromIntegral n))
-
--- | Resolve an address to a host or service name.
--- This function is protocol independent.
--- The list of 'NameInfoFlag' values controls query behaviour.
---
--- If a host or service's name cannot be looked up, then the numeric
--- form of the address or service will be returned.
---
--- If the query fails, this function throws an IO exception.
---
--- Example:
--- @
---   (hostName, _) <- getNameInfo [] True False myAddress
--- @
-
-getNameInfo :: [NameInfoFlag] -- ^ flags to control lookup behaviour
-            -> Bool -- ^ whether to look up a hostname
-            -> Bool -- ^ whether to look up a service name
-            -> SockAddr -- ^ the address to look up
-            -> IO (Maybe HostName, Maybe ServiceName)
-
-getNameInfo flags doHost doService addr = withSocketsDo $
-  withCStringIf doHost (#const NI_MAXHOST) $ \c_hostlen c_host ->
-    withCStringIf doService (#const NI_MAXSERV) $ \c_servlen c_serv -> do
-      withSockAddr addr $ \ptr_addr sz -> do
-        ret <- c_getnameinfo ptr_addr (fromIntegral sz) c_host c_hostlen
-                             c_serv c_servlen (packBits niFlagMapping flags)
-        case ret of
-          0 -> do
-            let peekIf doIf c_val = if doIf
-                                     then liftM Just $ peekCString c_val
-                                     else return Nothing
-            host <- peekIf doHost c_host
-            serv <- peekIf doService c_serv
-            return (host, serv)
-          _ -> do err <- gai_strerror ret
-                  ioError (ioeSetErrorString
-                           (mkIOError NoSuchThing "Network.Socket.getNameInfo" Nothing
-                            Nothing) err)
-
-foreign import ccall safe "hsnet_getnameinfo"
-    c_getnameinfo :: Ptr SockAddr -> CInt{-CSockLen???-} -> CString -> CSize -> CString
-                  -> CSize -> CInt -> IO CInt
-#endif
-
-mkInvalidRecvArgError :: String -> IOError
-mkInvalidRecvArgError loc = ioeSetErrorString (mkIOError
-                                    InvalidArgument
-                                    loc Nothing Nothing) "non-positive length"
-
-mkEOFError :: String -> IOError
-mkEOFError loc = ioeSetErrorString (mkIOError EOF loc Nothing Nothing) "end of file"
-
--- ---------------------------------------------------------------------------
--- foreign imports from the C library
-
-foreign import ccall unsafe "hsnet_inet_ntoa"
-  c_inet_ntoa :: HostAddress -> IO (Ptr CChar)
-
-foreign import CALLCONV unsafe "inet_addr"
-  c_inet_addr :: Ptr CChar -> IO HostAddress
-
-foreign import CALLCONV unsafe "shutdown"
-  c_shutdown :: CInt -> CInt -> IO CInt
-
-closeFd :: CInt -> IO ()
-closeFd fd = throwSocketErrorIfMinus1_ "Network.Socket.close" $ c_close fd
-
-#if !defined(WITH_WINSOCK)
-foreign import ccall unsafe "close"
-  c_close :: CInt -> IO CInt
-#else
-foreign import stdcall unsafe "closesocket"
-  c_close :: CInt -> IO CInt
-#endif
-
-foreign import CALLCONV unsafe "socket"
-  c_socket :: CInt -> CInt -> CInt -> IO CInt
-foreign import CALLCONV unsafe "bind"
-  c_bind :: CInt -> Ptr SockAddr -> CInt{-CSockLen???-} -> IO CInt
-foreign import CALLCONV SAFE_ON_WIN "connect"
-  c_connect :: CInt -> Ptr SockAddr -> CInt{-CSockLen???-} -> IO CInt
-#ifdef HAVE_ACCEPT4
-foreign import CALLCONV unsafe "accept4"
-  c_accept4 :: CInt -> Ptr SockAddr -> Ptr CInt{-CSockLen???-} -> CInt -> IO CInt
-#else
-foreign import CALLCONV unsafe "accept"
-  c_accept :: CInt -> Ptr SockAddr -> Ptr CInt{-CSockLen???-} -> IO CInt
-#endif
-foreign import CALLCONV unsafe "listen"
-  c_listen :: CInt -> CInt -> IO CInt
-
-#if defined(mingw32_HOST_OS)
-foreign import CALLCONV safe "accept"
-  c_accept_safe :: CInt -> Ptr SockAddr -> Ptr CInt{-CSockLen???-} -> IO CInt
-
-foreign import ccall unsafe "rtsSupportsBoundThreads" threaded :: Bool
-#endif
-
-foreign import CALLCONV unsafe "send"
-  c_send :: CInt -> Ptr a -> CSize -> CInt -> IO CInt
-foreign import CALLCONV SAFE_ON_WIN "sendto"
-  c_sendto :: CInt -> Ptr a -> CSize -> CInt -> Ptr SockAddr -> CInt -> IO CInt
-foreign import CALLCONV unsafe "recv"
-  c_recv :: CInt -> Ptr CChar -> CSize -> CInt -> IO CInt
-foreign import CALLCONV SAFE_ON_WIN "recvfrom"
-  c_recvfrom :: CInt -> Ptr a -> CSize -> CInt -> Ptr SockAddr -> Ptr CInt -> IO CInt
-foreign import CALLCONV unsafe "getpeername"
-  c_getpeername :: CInt -> Ptr SockAddr -> Ptr CInt -> IO CInt
-foreign import CALLCONV unsafe "getsockname"
-  c_getsockname :: CInt -> Ptr SockAddr -> Ptr CInt -> IO CInt
-
-foreign import CALLCONV unsafe "getsockopt"
-  c_getsockopt :: CInt -> CInt -> CInt -> Ptr CInt -> Ptr CInt -> IO CInt
-foreign import CALLCONV unsafe "setsockopt"
-  c_setsockopt :: CInt -> CInt -> CInt -> Ptr CInt -> CInt -> IO CInt
-
-#if defined(HAVE_GETPEEREID)
-foreign import CALLCONV unsafe "getpeereid"
-  c_getpeereid :: CInt -> Ptr CUInt -> Ptr CUInt -> IO CInt
-#endif
--- ---------------------------------------------------------------------------
--- * Deprecated aliases
-
--- $deprecated-aliases
---
--- These aliases are deprecated and should not be used in new code.
--- They will be removed in some future version of the package.
-
-{-# DEPRECATED bindSocket "use 'bind'" #-}
-
--- | Deprecated alias for 'bind'.
-bindSocket :: Socket    -- Unconnected Socket
-           -> SockAddr  -- Address to Bind to
-           -> IO ()
-bindSocket = bind
-
-{-# DEPRECATED sClose "use 'close'" #-}
-
--- | Deprecated alias for 'close'.
-sClose :: Socket -> IO ()
-sClose = close
-
-{-# DEPRECATED sIsConnected "use 'isConnected'" #-}
-
--- | Deprecated alias for 'isConnected'.
-sIsConnected :: Socket -> IO Bool
-sIsConnected = isConnected
-
-{-# DEPRECATED sIsBound "use 'isBound'" #-}
-
--- | Deprecated alias for 'isBound'.
-sIsBound :: Socket -> IO Bool
-sIsBound = isBound
-
-{-# DEPRECATED sIsListening "use 'isListening'" #-}
-
--- | Deprecated alias for 'isListening'.
-sIsListening :: Socket -> IO Bool
-sIsListening = isListening
-
-{-# DEPRECATED sIsReadable "use 'isReadable'" #-}
-
--- | Deprecated alias for 'isReadable'.
-sIsReadable  :: Socket -> IO Bool
-sIsReadable = isReadable
-
-{-# DEPRECATED sIsWritable "use 'isWritable'" #-}
-
--- | Deprecated alias for 'isWritable'.
-sIsWritable  :: Socket -> IO Bool
-sIsWritable = isWritable
diff --git a/Network/Socket/ByteString.hs b/Network/Socket/ByteString.hs
new file mode 100644
index 0000000..dcc7a21
--- /dev/null
+++ b/Network/Socket/ByteString.hs
@@ -0,0 +1,263 @@
+{-# LANGUAGE CPP, ForeignFunctionInterface #-}
+
+#include "HsNet.h"
+
+-- |
+-- Module      : Network.Socket.ByteString
+-- Copyright   : (c) Johan Tibell 2007-2010
+-- License     : BSD-style
+--
+-- Maintainer  : johan.tibell@gmail.com
+-- Stability   : stable
+-- Portability : portable
+--
+-- This module provides access to the BSD /socket/ interface.  This
+-- module is generally more efficient than the 'String' based network
+-- functions in 'Network.Socket'.  For detailed documentation, consult
+-- your favorite POSIX socket reference. All functions communicate
+-- failures by converting the error number to 'System.IO.IOError'.
+--
+-- This module is made to be imported with 'Network.Socket' like so:
+--
+-- > import Network.Socket hiding (send, sendTo, recv, recvFrom)
+-- > import Network.Socket.ByteString
+--
+module Network.Socket.ByteString
+    (
+    -- * Send data to a socket
+      send
+    , sendAll
+    , sendTo
+    , sendAllTo
+
+    -- ** Vectored I/O
+    -- $vectored
+    , sendMany
+    , sendManyTo
+
+    -- * Receive data from a socket
+    , recv
+    , recvFrom
+
+    -- * Example
+    -- $example
+    ) where
+
+import Control.Exception (catch, throwIO)
+import Control.Monad (when)
+import Data.ByteString (ByteString)
+import Data.ByteString.Internal (createAndTrim)
+import Data.ByteString.Unsafe (unsafeUseAsCStringLen)
+import Foreign.Marshal.Alloc (allocaBytes)
+import Foreign.Ptr (castPtr)
+import Network.Socket (sendBuf, sendBufTo, recvBuf, recvBufFrom)
+import System.IO.Error (isEOFError)
+
+import qualified Data.ByteString as B
+
+import Network.Socket.ByteString.Internal
+import Network.Socket.Internal
+import Network.Socket.Types
+
+-- ----------------------------------------------------------------------------
+-- Sending
+
+-- | Send data to the socket.  The socket must be connected to a
+-- remote socket.  Returns the number of bytes sent. Applications are
+-- responsible for ensuring that all data has been sent.
+--
+-- Sending data to closed socket may lead to undefined behaviour.
+send :: Socket      -- ^ Connected socket
+     -> ByteString  -- ^ Data to send
+     -> IO Int      -- ^ Number of bytes sent
+send sock xs = unsafeUseAsCStringLen xs $ \(str, len) ->
+    sendBuf sock (castPtr str) len
+
+-- | Send data to the socket.  The socket must be connected to a
+-- remote socket.  Unlike 'send', this function continues to send data
+-- until either all data has been sent or an error occurs.  On error,
+-- an exception is raised, and there is no way to determine how much
+-- data, if any, was successfully sent.
+--
+-- Sending data to closed socket may lead to undefined behaviour.
+sendAll :: Socket      -- ^ Connected socket
+        -> ByteString  -- ^ Data to send
+        -> IO ()
+sendAll sock bs = do
+    sent <- send sock bs
+    when (sent < B.length bs) $ sendAll sock (B.drop sent bs)
+
+-- | Send data to the socket.  The recipient can be specified
+-- explicitly, so the socket need not be in a connected state.
+-- Returns the number of bytes sent. Applications are responsible for
+-- ensuring that all data has been sent.
+--
+-- Sending data to closed socket may lead to undefined behaviour.
+sendTo :: Socket      -- ^ Socket
+       -> ByteString  -- ^ Data to send
+       -> SockAddr    -- ^ Recipient address
+       -> IO Int      -- ^ Number of bytes sent
+sendTo sock xs addr =
+    unsafeUseAsCStringLen xs $ \(str, len) -> sendBufTo sock str len addr
+
+-- | Send data to the socket. The recipient can be specified
+-- explicitly, so the socket need not be in a connected state.  Unlike
+-- 'sendTo', this function continues to send data until either all
+-- data has been sent or an error occurs.  On error, an exception is
+-- raised, and there is no way to determine how much data, if any, was
+-- successfully sent.
+--
+-- Sending data to closed socket may lead to undefined behaviour.
+sendAllTo :: Socket      -- ^ Socket
+          -> ByteString  -- ^ Data to send
+          -> SockAddr    -- ^ Recipient address
+          -> IO ()
+sendAllTo sock xs addr = do
+    sent <- sendTo sock xs addr
+    when (sent < B.length xs) $ sendAllTo sock (B.drop sent xs) addr
+
+-- ----------------------------------------------------------------------------
+-- ** Vectored I/O
+
+-- $vectored
+--
+-- Vectored I\/O, also known as scatter\/gather I\/O, allows multiple
+-- data segments to be sent using a single system call, without first
+-- concatenating the segments.  For example, given a list of
+-- @ByteString@s, @xs@,
+--
+-- > sendMany sock xs
+--
+-- is equivalent to
+--
+-- > sendAll sock (concat xs)
+--
+-- but potentially more efficient.
+--
+-- Vectored I\/O are often useful when implementing network protocols
+-- that, for example, group data into segments consisting of one or
+-- more fixed-length headers followed by a variable-length body.
+
+-- | Send data to the socket.  The socket must be in a connected
+-- state.  The data is sent as if the parts have been concatenated.
+-- This function continues to send data until either all data has been
+-- sent or an error occurs.  On error, an exception is raised, and
+-- there is no way to determine how much data, if any, was
+-- successfully sent.
+--
+-- Sending data to closed socket may lead to undefined behaviour.
+sendMany :: Socket        -- ^ Connected socket
+         -> [ByteString]  -- ^ Data to send
+         -> IO ()
+sendMany sock = sendAll sock . B.concat
+
+-- | Send data to the socket.  The recipient can be specified
+-- explicitly, so the socket need not be in a connected state.  The
+-- data is sent as if the parts have been concatenated.  This function
+-- continues to send data until either all data has been sent or an
+-- error occurs.  On error, an exception is raised, and there is no
+-- way to determine how much data, if any, was successfully sent.
+--
+-- Sending data to closed socket may lead to undefined behaviour.
+sendManyTo :: Socket        -- ^ Socket
+           -> [ByteString]  -- ^ Data to send
+           -> SockAddr      -- ^ Recipient address
+           -> IO ()
+sendManyTo sock cs = sendAllTo sock (B.concat cs)
+
+-- ----------------------------------------------------------------------------
+-- Receiving
+
+-- | Receive data from the socket.  The socket must be in a connected
+-- state.  This function may return fewer bytes than specified.  If
+-- the message is longer than the specified length, it may be
+-- discarded depending on the type of socket.  This function may block
+-- until a message arrives.
+--
+-- Considering hardware and network realities, the maximum number of bytes to
+-- receive should be a small power of 2, e.g., 4096.
+--
+-- For TCP sockets, a zero length return value means the peer has
+-- closed its half side of the connection.
+--
+-- Receiving data from closed socket may lead to undefined behaviour.
+recv :: Socket         -- ^ Connected socket
+     -> Int            -- ^ Maximum number of bytes to receive
+     -> IO ByteString  -- ^ Data received
+recv sock nbytes
+    | nbytes < 0 = ioError (mkInvalidRecvArgError "Network.Socket.ByteString.recv")
+    | otherwise  = createAndTrim nbytes $ \ptr ->
+        catch
+          (recvBuf sock ptr nbytes)
+          (\e -> if isEOFError e then return 0 else throwIO e)
+
+-- | Receive data from the socket.  The socket need not be in a
+-- connected state.  Returns @(bytes, address)@ where @bytes@ is a
+-- 'ByteString' representing the data received and @address@ is a
+-- 'SockAddr' representing the address of the sending socket.
+--
+-- Receiving data from closed socket may lead to undefined behaviour.
+recvFrom :: Socket                     -- ^ Socket
+         -> Int                        -- ^ Maximum number of bytes to receive
+         -> IO (ByteString, SockAddr)  -- ^ Data received and sender address
+recvFrom sock nbytes =
+    allocaBytes nbytes $ \ptr -> do
+        (len, sockaddr) <- recvBufFrom sock ptr nbytes
+        str <- B.packCStringLen (ptr, len)
+        return (str, sockaddr)
+
+-- ---------------------------------------------------------------------
+-- Example
+
+-- $example
+--
+-- Here are two minimal example programs using the TCP/IP protocol: a
+-- server that echoes all data that it receives back (servicing only
+-- one client) and a client using it.
+--
+-- > -- Echo server program
+-- > module Main where
+-- >
+-- > import Control.Monad (unless)
+-- > import Network.Socket hiding (recv)
+-- > import qualified Data.ByteString as S
+-- > import Network.Socket.ByteString (recv, sendAll)
+-- >
+-- > main :: IO ()
+-- > main = withSocketsDo $
+-- >     do addrinfos <- getAddrInfo
+-- >                     (Just (defaultHints {addrFlags = [AI_PASSIVE]}))
+-- >                     Nothing (Just "3000")
+-- >        let serveraddr = head addrinfos
+-- >        sock <- socket (addrFamily serveraddr) Stream defaultProtocol
+-- >        bind sock (addrAddress serveraddr)
+-- >        listen sock 1
+-- >        (conn, _) <- accept sock
+-- >        talk conn
+-- >        close conn
+-- >        close sock
+-- >
+-- >     where
+-- >       talk :: Socket -> IO ()
+-- >       talk conn =
+-- >           do msg <- recv conn 1024
+-- >              unless (S.null msg) $ sendAll conn msg >> talk conn
+--
+-- > -- Echo client program
+-- > module Main where
+-- >
+-- > import Network.Socket hiding (recv)
+-- > import Network.Socket.ByteString (recv, sendAll)
+-- > import qualified Data.ByteString.Char8 as C
+-- >
+-- > main :: IO ()
+-- > main = withSocketsDo $
+-- >     do addrinfos <- getAddrInfo Nothing (Just "") (Just "3000")
+-- >        let serveraddr = head addrinfos
+-- >        sock <- socket (addrFamily serveraddr) Stream defaultProtocol
+-- >        connect sock (addrAddress serveraddr)
+-- >        sendAll sock $ C.pack "Hello, world!"
+-- >        msg <- recv sock 1024
+-- >        close sock
+-- >        putStr "Received "
+-- >        C.putStrLn msg
diff --git a/Network/Socket/ByteString.hsc b/Network/Socket/ByteString.hsc
deleted file mode 100644
index 2745bfd..0000000
--- a/Network/Socket/ByteString.hsc
+++ /dev/null
@@ -1,338 +0,0 @@
-{-# LANGUAGE CPP, ForeignFunctionInterface #-}
-
-#include "HsNet.h"
-
--- |
--- Module      : Network.Socket.ByteString
--- Copyright   : (c) Johan Tibell 2007-2010
--- License     : BSD-style
---
--- Maintainer  : johan.tibell@gmail.com
--- Stability   : stable
--- Portability : portable
---
--- This module provides access to the BSD /socket/ interface.  This
--- module is generally more efficient than the 'String' based network
--- functions in 'Network.Socket'.  For detailed documentation, consult
--- your favorite POSIX socket reference. All functions communicate
--- failures by converting the error number to 'System.IO.IOError'.
---
--- This module is made to be imported with 'Network.Socket' like so:
---
--- > import Network.Socket hiding (send, sendTo, recv, recvFrom)
--- > import Network.Socket.ByteString
---
-module Network.Socket.ByteString
-    (
-    -- * Send data to a socket
-      send
-    , sendAll
-    , sendTo
-    , sendAllTo
-
-    -- ** Vectored I/O
-    -- $vectored
-    , sendMany
-    , sendManyTo
-
-    -- * Receive data from a socket
-    , recv
-    , recvFrom
-
-    -- * Example
-    -- $example
-    ) where
-
-import Control.Exception (catch, throwIO)
-import Control.Monad (when)
-import Data.ByteString (ByteString)
-import Data.ByteString.Internal (createAndTrim)
-import Data.ByteString.Unsafe (unsafeUseAsCStringLen)
-import Foreign.Marshal.Alloc (allocaBytes)
-import Foreign.Ptr (castPtr)
-import Network.Socket (sendBuf, sendBufTo, recvBuf, recvBufFrom)
-import System.IO.Error (isEOFError)
-
-import qualified Data.ByteString as B
-
-import Network.Socket.ByteString.Internal
-import Network.Socket.Internal
-import Network.Socket.Types
-
-#if !defined(mingw32_HOST_OS)
-import Control.Monad (liftM, zipWithM_)
-import Foreign.Marshal.Array (allocaArray)
-import Foreign.Marshal.Utils (with)
-import Foreign.Ptr (Ptr, plusPtr)
-import Foreign.Storable (Storable(..))
-
-import Network.Socket.ByteString.IOVec (IOVec(..))
-import Network.Socket.ByteString.MsgHdr (MsgHdr(..))
-#endif
-
--- ----------------------------------------------------------------------------
--- Sending
-
--- | Send data to the socket.  The socket must be connected to a
--- remote socket.  Returns the number of bytes sent. Applications are
--- responsible for ensuring that all data has been sent.
---
--- Sending data to closed socket may lead to undefined behaviour.
-send :: Socket      -- ^ Connected socket
-     -> ByteString  -- ^ Data to send
-     -> IO Int      -- ^ Number of bytes sent
-send sock xs = unsafeUseAsCStringLen xs $ \(str, len) ->
-    sendBuf sock (castPtr str) len
-
--- | Send data to the socket.  The socket must be connected to a
--- remote socket.  Unlike 'send', this function continues to send data
--- until either all data has been sent or an error occurs.  On error,
--- an exception is raised, and there is no way to determine how much
--- data, if any, was successfully sent.
---
--- Sending data to closed socket may lead to undefined behaviour.
-sendAll :: Socket      -- ^ Connected socket
-        -> ByteString  -- ^ Data to send
-        -> IO ()
-sendAll sock bs = do
-    sent <- send sock bs
-    when (sent < B.length bs) $ sendAll sock (B.drop sent bs)
-
--- | Send data to the socket.  The recipient can be specified
--- explicitly, so the socket need not be in a connected state.
--- Returns the number of bytes sent. Applications are responsible for
--- ensuring that all data has been sent.
---
--- Sending data to closed socket may lead to undefined behaviour.
-sendTo :: Socket      -- ^ Socket
-       -> ByteString  -- ^ Data to send
-       -> SockAddr    -- ^ Recipient address
-       -> IO Int      -- ^ Number of bytes sent
-sendTo sock xs addr =
-    unsafeUseAsCStringLen xs $ \(str, len) -> sendBufTo sock str len addr
-
--- | Send data to the socket. The recipient can be specified
--- explicitly, so the socket need not be in a connected state.  Unlike
--- 'sendTo', this function continues to send data until either all
--- data has been sent or an error occurs.  On error, an exception is
--- raised, and there is no way to determine how much data, if any, was
--- successfully sent.
---
--- Sending data to closed socket may lead to undefined behaviour.
-sendAllTo :: Socket      -- ^ Socket
-          -> ByteString  -- ^ Data to send
-          -> SockAddr    -- ^ Recipient address
-          -> IO ()
-sendAllTo sock xs addr = do
-    sent <- sendTo sock xs addr
-    when (sent < B.length xs) $ sendAllTo sock (B.drop sent xs) addr
-
--- ----------------------------------------------------------------------------
--- ** Vectored I/O
-
--- $vectored
---
--- Vectored I\/O, also known as scatter\/gather I\/O, allows multiple
--- data segments to be sent using a single system call, without first
--- concatenating the segments.  For example, given a list of
--- @ByteString@s, @xs@,
---
--- > sendMany sock xs
---
--- is equivalent to
---
--- > sendAll sock (concat xs)
---
--- but potentially more efficient.
---
--- Vectored I\/O are often useful when implementing network protocols
--- that, for example, group data into segments consisting of one or
--- more fixed-length headers followed by a variable-length body.
-
--- | Send data to the socket.  The socket must be in a connected
--- state.  The data is sent as if the parts have been concatenated.
--- This function continues to send data until either all data has been
--- sent or an error occurs.  On error, an exception is raised, and
--- there is no way to determine how much data, if any, was
--- successfully sent.
---
--- Sending data to closed socket may lead to undefined behaviour.
-sendMany :: Socket        -- ^ Connected socket
-         -> [ByteString]  -- ^ Data to send
-         -> IO ()
-#if !defined(mingw32_HOST_OS)
-sendMany sock@(MkSocket fd _ _ _ _) cs = do
-    sent <- sendManyInner
-    when (sent < totalLength cs) $ sendMany sock (remainingChunks sent cs)
-  where
-    sendManyInner =
-      liftM fromIntegral . withIOVec cs $ \(iovsPtr, iovsLen) ->
-          throwSocketErrorWaitWrite sock "Network.Socket.ByteString.sendMany" $
-              c_writev (fromIntegral fd) iovsPtr
-              (fromIntegral (min iovsLen (#const IOV_MAX)))
-#else
-sendMany sock = sendAll sock . B.concat
-#endif
-
--- | Send data to the socket.  The recipient can be specified
--- explicitly, so the socket need not be in a connected state.  The
--- data is sent as if the parts have been concatenated.  This function
--- continues to send data until either all data has been sent or an
--- error occurs.  On error, an exception is raised, and there is no
--- way to determine how much data, if any, was successfully sent.
---
--- Sending data to closed socket may lead to undefined behaviour.
-sendManyTo :: Socket        -- ^ Socket
-           -> [ByteString]  -- ^ Data to send
-           -> SockAddr      -- ^ Recipient address
-           -> IO ()
-#if !defined(mingw32_HOST_OS)
-sendManyTo sock@(MkSocket fd _ _ _ _) cs addr = do
-    sent <- liftM fromIntegral sendManyToInner
-    when (sent < totalLength cs) $ sendManyTo sock (remainingChunks sent cs) addr
-  where
-    sendManyToInner =
-      withSockAddr addr $ \addrPtr addrSize ->
-        withIOVec cs $ \(iovsPtr, iovsLen) -> do
-          let msgHdr = MsgHdr
-                addrPtr (fromIntegral addrSize)
-                iovsPtr (fromIntegral iovsLen)
-          with msgHdr $ \msgHdrPtr ->
-            throwSocketErrorWaitWrite sock "Network.Socket.ByteString.sendManyTo" $
-              c_sendmsg (fromIntegral fd) msgHdrPtr 0
-#else
-sendManyTo sock cs = sendAllTo sock (B.concat cs)
-#endif
-
--- ----------------------------------------------------------------------------
--- Receiving
-
--- | Receive data from the socket.  The socket must be in a connected
--- state.  This function may return fewer bytes than specified.  If
--- the message is longer than the specified length, it may be
--- discarded depending on the type of socket.  This function may block
--- until a message arrives.
---
--- Considering hardware and network realities, the maximum number of bytes to
--- receive should be a small power of 2, e.g., 4096.
---
--- For TCP sockets, a zero length return value means the peer has
--- closed its half side of the connection.
---
--- Receiving data from closed socket may lead to undefined behaviour.
-recv :: Socket         -- ^ Connected socket
-     -> Int            -- ^ Maximum number of bytes to receive
-     -> IO ByteString  -- ^ Data received
-recv sock nbytes
-    | nbytes < 0 = ioError (mkInvalidRecvArgError "Network.Socket.ByteString.recv")
-    | otherwise  = createAndTrim nbytes $ \ptr ->
-        catch
-          (recvBuf sock ptr nbytes)
-          (\e -> if isEOFError e then return 0 else throwIO e)
-
--- | Receive data from the socket.  The socket need not be in a
--- connected state.  Returns @(bytes, address)@ where @bytes@ is a
--- 'ByteString' representing the data received and @address@ is a
--- 'SockAddr' representing the address of the sending socket.
---
--- Receiving data from closed socket may lead to undefined behaviour.
-recvFrom :: Socket                     -- ^ Socket
-         -> Int                        -- ^ Maximum number of bytes to receive
-         -> IO (ByteString, SockAddr)  -- ^ Data received and sender address
-recvFrom sock nbytes =
-    allocaBytes nbytes $ \ptr -> do
-        (len, sockaddr) <- recvBufFrom sock ptr nbytes
-        str <- B.packCStringLen (ptr, len)
-        return (str, sockaddr)
-
--- ----------------------------------------------------------------------------
--- Not exported
-
-#if !defined(mingw32_HOST_OS)
--- | Suppose we try to transmit a list of chunks @cs@ via a gathering write
--- operation and find that @n@ bytes were sent. Then @remainingChunks n cs@ is
--- list of chunks remaining to be sent.
-remainingChunks :: Int -> [ByteString] -> [ByteString]
-remainingChunks _ [] = []
-remainingChunks i (x:xs)
-    | i < len        = B.drop i x : xs
-    | otherwise      = let i' = i - len in i' `seq` remainingChunks i' xs
-  where
-    len = B.length x
-
--- | @totalLength cs@ is the sum of the lengths of the chunks in the list @cs@.
-totalLength :: [ByteString] -> Int
-totalLength = sum . map B.length
-
--- | @withIOVec cs f@ executes the computation @f@, passing as argument a pair
--- consisting of a pointer to a temporarily allocated array of pointers to
--- 'IOVec' made from @cs@ and the number of pointers (@length cs@).
--- /Unix only/.
-withIOVec :: [ByteString] -> ((Ptr IOVec, Int) -> IO a) -> IO a
-withIOVec cs f =
-    allocaArray csLen $ \aPtr -> do
-        zipWithM_ pokeIov (ptrs aPtr) cs
-        f (aPtr, csLen)
-  where
-    csLen = length cs
-    ptrs = iterate (`plusPtr` sizeOf (undefined :: IOVec))
-    pokeIov ptr s =
-        unsafeUseAsCStringLen s $ \(sPtr, sLen) ->
-        poke ptr $ IOVec sPtr (fromIntegral sLen)
-#endif
-
--- ---------------------------------------------------------------------
--- Example
-
--- $example
---
--- Here are two minimal example programs using the TCP/IP protocol: a
--- server that echoes all data that it receives back (servicing only
--- one client) and a client using it.
---
--- > -- Echo server program
--- > module Main where
--- >
--- > import Control.Monad (unless)
--- > import Network.Socket hiding (recv)
--- > import qualified Data.ByteString as S
--- > import Network.Socket.ByteString (recv, sendAll)
--- >
--- > main :: IO ()
--- > main = withSocketsDo $
--- >     do addrinfos <- getAddrInfo
--- >                     (Just (defaultHints {addrFlags = [AI_PASSIVE]}))
--- >                     Nothing (Just "3000")
--- >        let serveraddr = head addrinfos
--- >        sock <- socket (addrFamily serveraddr) Stream defaultProtocol
--- >        bind sock (addrAddress serveraddr)
--- >        listen sock 1
--- >        (conn, _) <- accept sock
--- >        talk conn
--- >        close conn
--- >        close sock
--- >
--- >     where
--- >       talk :: Socket -> IO ()
--- >       talk conn =
--- >           do msg <- recv conn 1024
--- >              unless (S.null msg) $ sendAll conn msg >> talk conn
---
--- > -- Echo client program
--- > module Main where
--- >
--- > import Network.Socket hiding (recv)
--- > import Network.Socket.ByteString (recv, sendAll)
--- > import qualified Data.ByteString.Char8 as C
--- >
--- > main :: IO ()
--- > main = withSocketsDo $
--- >     do addrinfos <- getAddrInfo Nothing (Just "") (Just "3000")
--- >        let serveraddr = head addrinfos
--- >        sock <- socket (addrFamily serveraddr) Stream defaultProtocol
--- >        connect sock (addrAddress serveraddr)
--- >        sendAll sock $ C.pack "Hello, world!"
--- >        msg <- recv sock 1024
--- >        close sock
--- >        putStr "Received "
--- >        C.putStrLn msg
diff --git a/Network/Socket/ByteString/Internal.hs b/Network/Socket/ByteString/Internal.hs
index 7aad1a6..2eea992 100644
--- a/Network/Socket/ByteString/Internal.hs
+++ b/Network/Socket/ByteString/Internal.hs
@@ -12,34 +12,13 @@
 module Network.Socket.ByteString.Internal
     (
       mkInvalidRecvArgError
-#if !defined(mingw32_HOST_OS)
-    , c_writev
-    , c_sendmsg
-#endif
     ) where
 
 import System.IO.Error (ioeSetErrorString, mkIOError)
 
-#if !defined(mingw32_HOST_OS)
-import Foreign.C.Types (CInt(..))
-import System.Posix.Types (CSsize(..))
-import Foreign.Ptr (Ptr)
-
-import Network.Socket.ByteString.IOVec (IOVec)
-import Network.Socket.ByteString.MsgHdr (MsgHdr)
-#endif
-
 import GHC.IO.Exception (IOErrorType(..))
 
 mkInvalidRecvArgError :: String -> IOError
 mkInvalidRecvArgError loc = ioeSetErrorString (mkIOError
                                     InvalidArgument
                                     loc Nothing Nothing) "non-positive length"
-
-#if !defined(mingw32_HOST_OS)
-foreign import ccall unsafe "writev"
-  c_writev :: CInt -> Ptr IOVec -> CInt -> IO CSsize
-
-foreign import ccall unsafe "sendmsg"
-  c_sendmsg :: CInt -> Ptr MsgHdr -> CInt -> IO CSsize
-#endif
diff --git a/Network/Socket/ByteString/Lazy.hs b/Network/Socket/ByteString/Lazy.hs
index e586943..01fd253 100644
--- a/Network/Socket/ByteString/Lazy.hs
+++ b/Network/Socket/ByteString/Lazy.hs
@@ -43,11 +43,7 @@ import System.IO.Unsafe (unsafeInterleaveIO)
 import qualified Data.ByteString as S
 import qualified Network.Socket.ByteString as N
 
-#if defined(mingw32_HOST_OS)
 import Network.Socket.ByteString.Lazy.Windows (send, sendAll)
-#else
-import Network.Socket.ByteString.Lazy.Posix (send, sendAll)
-#endif
 
 -- -----------------------------------------------------------------------------
 -- Receiving
diff --git a/Network/Socket/Internal.hs b/Network/Socket/Internal.hs
new file mode 100644
index 0000000..43be9db
--- /dev/null
+++ b/Network/Socket/Internal.hs
@@ -0,0 +1,268 @@
+{-# LANGUAGE CPP #-}
+{-# LANGUAGE ForeignFunctionInterface #-}
+{-# OPTIONS_GHC -fno-warn-orphans #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Network.Socket.Internal
+-- Copyright   :  (c) The University of Glasgow 2001
+-- License     :  BSD-style (see the file libraries/network/LICENSE)
+--
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  provisional
+-- Portability :  portable
+--
+-- A module containing semi-public 'Network.Socket' internals.
+-- Modules which extend the 'Network.Socket' module will need to use
+-- this module while ideally most users will be able to make do with
+-- the public interface.
+--
+-----------------------------------------------------------------------------
+
+#include "HsNet.h"
+
+module Network.Socket.Internal
+    (
+    -- * Socket addresses
+      HostAddress
+#if defined(IPV6_SOCKET_SUPPORT)
+    , HostAddress6
+    , FlowInfo
+    , ScopeID
+#endif
+    , PortNumber(..)
+    , SockAddr(..)
+
+    -- , peekSockAddr
+    -- , pokeSockAddr
+    -- , sizeOfSockAddr
+    -- , sizeOfSockAddrByFamily
+    , withSockAddr
+    -- , withNewSockAddr
+
+    -- * Protocol families
+    , Family(..)
+
+    -- * Socket error functions
+#if defined(HAVE_WINSOCK2_H)
+    , c_getLastError
+#endif
+    , throwSocketError
+    , throwSocketErrorCode
+
+    -- * Guards for socket operations that may fail
+    , throwSocketErrorIfMinus1_
+    , throwSocketErrorIfMinus1Retry
+    , throwSocketErrorIfMinus1Retry_
+    , throwSocketErrorIfMinus1RetryMayBlock
+
+    -- ** Guards that wait and retry if the operation would block
+    -- | These guards are based on 'throwSocketErrorIfMinus1RetryMayBlock'.
+    -- They wait for socket readiness if the action fails with @EWOULDBLOCK@
+    -- or similar.
+    , throwSocketErrorWaitRead
+    , throwSocketErrorWaitWrite
+
+    -- * Initialization
+    , withSocketsDo
+
+    -- * Low-level helpers
+    , zeroMemory
+    ) where
+
+import Foreign.C.Error (throwErrno, throwErrnoIfMinus1Retry,
+                        throwErrnoIfMinus1RetryMayBlock, throwErrnoIfMinus1_,
+                        Errno(..), errnoToIOError)
+#if defined(HAVE_WINSOCK2_H)
+import Foreign.C.String (peekCString)
+import Foreign.Ptr (Ptr)
+#endif
+import Foreign.C.Types (CInt(..))
+import GHC.Conc (threadWaitRead, threadWaitWrite)
+
+#if defined(HAVE_WINSOCK2_H)
+import Control.Exception ( evaluate )
+import System.IO.Unsafe ( unsafePerformIO )
+import Control.Monad ( when )
+#  if __GLASGOW_HASKELL__ >= 707
+import GHC.IO.Exception ( IOErrorType(..) )
+#  else
+import GHC.IOBase ( IOErrorType(..) )
+#  endif
+import Foreign.C.Types ( CChar )
+import System.IO.Error ( ioeSetErrorString, mkIOError )
+#endif
+
+import Network.Socket.Types
+
+-- ---------------------------------------------------------------------
+-- Guards for socket operations that may fail
+
+-- | Throw an 'IOError' corresponding to the current socket error.
+throwSocketError :: String  -- ^ textual description of the error location
+                 -> IO a
+
+-- | Like 'throwSocketError', but the error code is supplied as an argument.
+--
+-- On Windows, do not use errno.  Use a system error code instead.
+throwSocketErrorCode :: String -> CInt -> IO a
+
+-- | Throw an 'IOError' corresponding to the current socket error if
+-- the IO action returns a result of @-1@.  Discards the result of the
+-- IO action after error handling.
+throwSocketErrorIfMinus1_
+    :: (Eq a, Num a)
+    => String  -- ^ textual description of the location
+    -> IO a    -- ^ the 'IO' operation to be executed
+    -> IO ()
+
+{-# SPECIALIZE throwSocketErrorIfMinus1_ :: String -> IO CInt -> IO () #-}
+
+-- | Throw an 'IOError' corresponding to the current socket error if
+-- the IO action returns a result of @-1@, but retries in case of an
+-- interrupted operation.
+throwSocketErrorIfMinus1Retry
+    :: (Eq a, Num a)
+    => String  -- ^ textual description of the location
+    -> IO a    -- ^ the 'IO' operation to be executed
+    -> IO a
+
+{-# SPECIALIZE throwSocketErrorIfMinus1Retry :: String -> IO CInt -> IO CInt #-}
+
+-- | Throw an 'IOError' corresponding to the current socket error if
+-- the IO action returns a result of @-1@, but retries in case of an
+-- interrupted operation. Discards the result of the IO action after
+-- error handling.
+throwSocketErrorIfMinus1Retry_
+    :: (Eq a, Num a)
+    => String  -- ^ textual description of the location
+    -> IO a    -- ^ the 'IO' operation to be executed
+    -> IO ()
+throwSocketErrorIfMinus1Retry_ loc m =
+    throwSocketErrorIfMinus1Retry loc m >> return ()
+{-# SPECIALIZE throwSocketErrorIfMinus1Retry_ :: String -> IO CInt -> IO () #-}
+
+-- | Throw an 'IOError' corresponding to the current socket error if
+-- the IO action returns a result of @-1@, but retries in case of an
+-- interrupted operation.  Checks for operations that would block and
+-- executes an alternative action before retrying in that case.
+throwSocketErrorIfMinus1RetryMayBlock
+    :: (Eq a, Num a)
+    => String  -- ^ textual description of the location
+    -> IO b    -- ^ action to execute before retrying if an
+               --   immediate retry would block
+    -> IO a    -- ^ the 'IO' operation to be executed
+    -> IO a
+
+{-# SPECIALIZE throwSocketErrorIfMinus1RetryMayBlock
+        :: String -> IO b -> IO CInt -> IO CInt #-}
+
+#if (!defined(HAVE_WINSOCK2_H))
+
+throwSocketErrorIfMinus1RetryMayBlock name on_block act =
+    throwErrnoIfMinus1RetryMayBlock name act on_block
+
+throwSocketErrorIfMinus1Retry = throwErrnoIfMinus1Retry
+
+throwSocketErrorIfMinus1_ = throwErrnoIfMinus1_
+
+throwSocketError = throwErrno
+
+throwSocketErrorCode loc errno =
+    ioError (errnoToIOError loc (Errno errno) Nothing Nothing)
+
+#else
+
+throwSocketErrorIfMinus1RetryMayBlock name _ act
+  = throwSocketErrorIfMinus1Retry name act
+
+throwSocketErrorIfMinus1_ name act = do
+  throwSocketErrorIfMinus1Retry name act
+  return ()
+
+# if defined(HAVE_WINSOCK2_H)
+throwSocketErrorIfMinus1Retry name act = do
+  r <- act
+  if (r == -1)
+   then do
+    rc   <- c_getLastError
+    case rc of
+      #{const WSANOTINITIALISED} -> do
+        withSocketsDo (return ())
+        r <- act
+        if (r == -1)
+           then throwSocketError name
+           else return r
+      _ -> throwSocketError name
+   else return r
+
+throwSocketErrorCode name rc = do
+    pstr <- c_getWSError rc
+    str  <- peekCString pstr
+    ioError (ioeSetErrorString (mkIOError OtherError name Nothing Nothing) str)
+
+throwSocketError name =
+    c_getLastError >>= throwSocketErrorCode name
+
+foreign import CALLCONV unsafe "WSAGetLastError"
+  c_getLastError :: IO CInt
+
+foreign import ccall unsafe "getWSErrorDescr"
+  c_getWSError :: CInt -> IO (Ptr CChar)
+
+
+# else
+throwSocketErrorIfMinus1Retry = throwErrnoIfMinus1Retry
+throwSocketError = throwErrno
+throwSocketErrorCode loc errno =
+    ioError (errnoToIOError loc (Errno errno) Nothing Nothing)
+# endif
+#endif
+
+-- | Like 'throwSocketErrorIfMinus1Retry', but if the action fails with
+-- @EWOULDBLOCK@ or similar, wait for the socket to be read-ready,
+-- and try again.
+throwSocketErrorWaitRead :: (Eq a, Num a) => Socket -> String -> IO a -> IO a
+throwSocketErrorWaitRead _sock _name io = io
+
+-- | Like 'throwSocketErrorIfMinus1Retry', but if the action fails with
+-- @EWOULDBLOCK@ or similar, wait for the socket to be write-ready,
+-- and try again.
+throwSocketErrorWaitWrite :: (Eq a, Num a) => Socket -> String -> IO a -> IO a
+throwSocketErrorWaitWrite _sock _name io = io
+
+-- ---------------------------------------------------------------------------
+-- WinSock support
+
+{-| With older versions of the @network@ library on Windows operating systems,
+the networking subsystem must be initialised using 'withSocketsDo' before
+any networking operations can be used. eg.
+
+> main = withSocketsDo $ do {...}
+
+It is fine to nest calls to 'withSocketsDo', and to perform networking operations
+after 'withSocketsDo' has returned.
+
+In newer versions of the @network@ library it is only necessary to call
+'withSocketsDo' if you are calling the 'MkSocket' constructor directly.
+However, for compatibility with older versions on Windows, it is good practice
+to always call 'withSocketsDo' (it's very cheap).
+-}
+{-# INLINE withSocketsDo #-}
+withSocketsDo :: IO a -> IO a
+#if !defined(WITH_WINSOCK)
+withSocketsDo x = x
+#else
+withSocketsDo act = evaluate withSocketsInit >> act
+
+
+{-# NOINLINE withSocketsInit #-}
+withSocketsInit :: ()
+-- Use a CAF to make forcing it do initialisation once, but subsequent forces will be cheap
+withSocketsInit = unsafePerformIO $ do
+    x <- initWinSock
+    when (x /= 0) $ ioError $
+      userError "Network.Socket.Internal.withSocketsDo: Failed to initialise WinSock"
+
+foreign import ccall unsafe "initWinSock" initWinSock :: IO Int
+
+#endif
diff --git a/Network/Socket/Internal.hsc b/Network/Socket/Internal.hsc
deleted file mode 100644
index 1372b25..0000000
--- a/Network/Socket/Internal.hsc
+++ /dev/null
@@ -1,274 +0,0 @@
-{-# LANGUAGE CPP #-}
-{-# LANGUAGE ForeignFunctionInterface #-}
-{-# OPTIONS_GHC -fno-warn-orphans #-}
------------------------------------------------------------------------------
--- |
--- Module      :  Network.Socket.Internal
--- Copyright   :  (c) The University of Glasgow 2001
--- License     :  BSD-style (see the file libraries/network/LICENSE)
---
--- Maintainer  :  libraries@haskell.org
--- Stability   :  provisional
--- Portability :  portable
---
--- A module containing semi-public 'Network.Socket' internals.
--- Modules which extend the 'Network.Socket' module will need to use
--- this module while ideally most users will be able to make do with
--- the public interface.
---
------------------------------------------------------------------------------
-
-#include "HsNet.h"
-
-module Network.Socket.Internal
-    (
-    -- * Socket addresses
-      HostAddress
-#if defined(IPV6_SOCKET_SUPPORT)
-    , HostAddress6
-    , FlowInfo
-    , ScopeID
-#endif
-    , PortNumber(..)
-    , SockAddr(..)
-
-    , peekSockAddr
-    , pokeSockAddr
-    , sizeOfSockAddr
-    , sizeOfSockAddrByFamily
-    , withSockAddr
-    , withNewSockAddr
-
-    -- * Protocol families
-    , Family(..)
-
-    -- * Socket error functions
-#if defined(HAVE_WINSOCK2_H)
-    , c_getLastError
-#endif
-    , throwSocketError
-    , throwSocketErrorCode
-
-    -- * Guards for socket operations that may fail
-    , throwSocketErrorIfMinus1_
-    , throwSocketErrorIfMinus1Retry
-    , throwSocketErrorIfMinus1Retry_
-    , throwSocketErrorIfMinus1RetryMayBlock
-
-    -- ** Guards that wait and retry if the operation would block
-    -- | These guards are based on 'throwSocketErrorIfMinus1RetryMayBlock'.
-    -- They wait for socket readiness if the action fails with @EWOULDBLOCK@
-    -- or similar.
-    , throwSocketErrorWaitRead
-    , throwSocketErrorWaitWrite
-
-    -- * Initialization
-    , withSocketsDo
-
-    -- * Low-level helpers
-    , zeroMemory
-    ) where
-
-import Foreign.C.Error (throwErrno, throwErrnoIfMinus1Retry,
-                        throwErrnoIfMinus1RetryMayBlock, throwErrnoIfMinus1_,
-                        Errno(..), errnoToIOError)
-#if defined(HAVE_WINSOCK2_H)
-import Foreign.C.String (peekCString)
-import Foreign.Ptr (Ptr)
-#endif
-import Foreign.C.Types (CInt(..))
-import GHC.Conc (threadWaitRead, threadWaitWrite)
-
-#if defined(HAVE_WINSOCK2_H)
-import Control.Exception ( evaluate )
-import System.IO.Unsafe ( unsafePerformIO )
-import Control.Monad ( when )
-#  if __GLASGOW_HASKELL__ >= 707
-import GHC.IO.Exception ( IOErrorType(..) )
-#  else
-import GHC.IOBase ( IOErrorType(..) )
-#  endif
-import Foreign.C.Types ( CChar )
-import System.IO.Error ( ioeSetErrorString, mkIOError )
-#endif
-
-import Network.Socket.Types
-
--- ---------------------------------------------------------------------
--- Guards for socket operations that may fail
-
--- | Throw an 'IOError' corresponding to the current socket error.
-throwSocketError :: String  -- ^ textual description of the error location
-                 -> IO a
-
--- | Like 'throwSocketError', but the error code is supplied as an argument.
---
--- On Windows, do not use errno.  Use a system error code instead.
-throwSocketErrorCode :: String -> CInt -> IO a
-
--- | Throw an 'IOError' corresponding to the current socket error if
--- the IO action returns a result of @-1@.  Discards the result of the
--- IO action after error handling.
-throwSocketErrorIfMinus1_
-    :: (Eq a, Num a)
-    => String  -- ^ textual description of the location
-    -> IO a    -- ^ the 'IO' operation to be executed
-    -> IO ()
-
-{-# SPECIALIZE throwSocketErrorIfMinus1_ :: String -> IO CInt -> IO () #-}
-
--- | Throw an 'IOError' corresponding to the current socket error if
--- the IO action returns a result of @-1@, but retries in case of an
--- interrupted operation.
-throwSocketErrorIfMinus1Retry
-    :: (Eq a, Num a)
-    => String  -- ^ textual description of the location
-    -> IO a    -- ^ the 'IO' operation to be executed
-    -> IO a
-
-{-# SPECIALIZE throwSocketErrorIfMinus1Retry :: String -> IO CInt -> IO CInt #-}
-
--- | Throw an 'IOError' corresponding to the current socket error if
--- the IO action returns a result of @-1@, but retries in case of an
--- interrupted operation. Discards the result of the IO action after
--- error handling.
-throwSocketErrorIfMinus1Retry_
-    :: (Eq a, Num a)
-    => String  -- ^ textual description of the location
-    -> IO a    -- ^ the 'IO' operation to be executed
-    -> IO ()
-throwSocketErrorIfMinus1Retry_ loc m =
-    throwSocketErrorIfMinus1Retry loc m >> return ()
-{-# SPECIALIZE throwSocketErrorIfMinus1Retry_ :: String -> IO CInt -> IO () #-}
-
--- | Throw an 'IOError' corresponding to the current socket error if
--- the IO action returns a result of @-1@, but retries in case of an
--- interrupted operation.  Checks for operations that would block and
--- executes an alternative action before retrying in that case.
-throwSocketErrorIfMinus1RetryMayBlock
-    :: (Eq a, Num a)
-    => String  -- ^ textual description of the location
-    -> IO b    -- ^ action to execute before retrying if an
-               --   immediate retry would block
-    -> IO a    -- ^ the 'IO' operation to be executed
-    -> IO a
-
-{-# SPECIALIZE throwSocketErrorIfMinus1RetryMayBlock
-        :: String -> IO b -> IO CInt -> IO CInt #-}
-
-#if (!defined(HAVE_WINSOCK2_H))
-
-throwSocketErrorIfMinus1RetryMayBlock name on_block act =
-    throwErrnoIfMinus1RetryMayBlock name act on_block
-
-throwSocketErrorIfMinus1Retry = throwErrnoIfMinus1Retry
-
-throwSocketErrorIfMinus1_ = throwErrnoIfMinus1_
-
-throwSocketError = throwErrno
-
-throwSocketErrorCode loc errno =
-    ioError (errnoToIOError loc (Errno errno) Nothing Nothing)
-
-#else
-
-throwSocketErrorIfMinus1RetryMayBlock name _ act
-  = throwSocketErrorIfMinus1Retry name act
-
-throwSocketErrorIfMinus1_ name act = do
-  throwSocketErrorIfMinus1Retry name act
-  return ()
-
-# if defined(HAVE_WINSOCK2_H)
-throwSocketErrorIfMinus1Retry name act = do
-  r <- act
-  if (r == -1)
-   then do
-    rc   <- c_getLastError
-    case rc of
-      #{const WSANOTINITIALISED} -> do
-        withSocketsDo (return ())
-        r <- act
-        if (r == -1)
-           then throwSocketError name
-           else return r
-      _ -> throwSocketError name
-   else return r
-
-throwSocketErrorCode name rc = do
-    pstr <- c_getWSError rc
-    str  <- peekCString pstr
-    ioError (ioeSetErrorString (mkIOError OtherError name Nothing Nothing) str)
-
-throwSocketError name =
-    c_getLastError >>= throwSocketErrorCode name
-
-foreign import CALLCONV unsafe "WSAGetLastError"
-  c_getLastError :: IO CInt
-
-foreign import ccall unsafe "getWSErrorDescr"
-  c_getWSError :: CInt -> IO (Ptr CChar)
-
-
-# else
-throwSocketErrorIfMinus1Retry = throwErrnoIfMinus1Retry
-throwSocketError = throwErrno
-throwSocketErrorCode loc errno =
-    ioError (errnoToIOError loc (Errno errno) Nothing Nothing)
-# endif
-#endif
-
--- | Like 'throwSocketErrorIfMinus1Retry', but if the action fails with
--- @EWOULDBLOCK@ or similar, wait for the socket to be read-ready,
--- and try again.
-throwSocketErrorWaitRead :: (Eq a, Num a) => Socket -> String -> IO a -> IO a
-throwSocketErrorWaitRead sock name io =
-    throwSocketErrorIfMinus1RetryMayBlock name
-        (threadWaitRead $ fromIntegral $ sockFd sock)
-        io
-
--- | Like 'throwSocketErrorIfMinus1Retry', but if the action fails with
--- @EWOULDBLOCK@ or similar, wait for the socket to be write-ready,
--- and try again.
-throwSocketErrorWaitWrite :: (Eq a, Num a) => Socket -> String -> IO a -> IO a
-throwSocketErrorWaitWrite sock name io =
-    throwSocketErrorIfMinus1RetryMayBlock name
-        (threadWaitWrite $ fromIntegral $ sockFd sock)
-        io
-
--- ---------------------------------------------------------------------------
--- WinSock support
-
-{-| With older versions of the @network@ library on Windows operating systems,
-the networking subsystem must be initialised using 'withSocketsDo' before
-any networking operations can be used. eg.
-
-> main = withSocketsDo $ do {...}
-
-It is fine to nest calls to 'withSocketsDo', and to perform networking operations
-after 'withSocketsDo' has returned.
-
-In newer versions of the @network@ library it is only necessary to call
-'withSocketsDo' if you are calling the 'MkSocket' constructor directly.
-However, for compatibility with older versions on Windows, it is good practice
-to always call 'withSocketsDo' (it's very cheap).
--}
-{-# INLINE withSocketsDo #-}
-withSocketsDo :: IO a -> IO a
-#if !defined(WITH_WINSOCK)
-withSocketsDo x = x
-#else
-withSocketsDo act = evaluate withSocketsInit >> act
-
-
-{-# NOINLINE withSocketsInit #-}
-withSocketsInit :: ()
--- Use a CAF to make forcing it do initialisation once, but subsequent forces will be cheap
-withSocketsInit = unsafePerformIO $ do
-    x <- initWinSock
-    when (x /= 0) $ ioError $
-      userError "Network.Socket.Internal.withSocketsDo: Failed to initialise WinSock"
-
-foreign import ccall unsafe "initWinSock" initWinSock :: IO Int
-
-#endif
diff --git a/Network/Socket/Types.hs b/Network/Socket/Types.hs
new file mode 100644
index 0000000..4fc6f89
--- /dev/null
+++ b/Network/Socket/Types.hs
@@ -0,0 +1,1001 @@
+{-# LANGUAGE DeriveDataTypeable #-}
+{-# LANGUAGE FlexibleInstances #-}
+{-# LANGUAGE ForeignFunctionInterface #-}
+
+#include "HsNet.h"
+
+module Network.Socket.Types
+    (
+    -- * Socket
+      Socket(..)
+    , sockFd
+    , sockFamily
+    , sockType
+    , sockProtocol
+    , sockStatus
+    , SocketStatus(..)
+
+    -- * Socket types
+    , SocketType(..)
+    , isSupportedSocketType
+    , packSocketType
+    , packSocketType'
+    , packSocketTypeOrThrow
+    , unpackSocketType
+    , unpackSocketType'
+
+    -- * Family
+    , Family(..)
+    , isSupportedFamily
+    , packFamily
+    , unpackFamily
+
+    -- * Socket addresses
+    , SockAddr(..)
+    , isSupportedSockAddr
+    , newSockAddr
+    , withSockAddr
+    , HostAddress
+    , hostAddressToTuple
+    , tupleToHostAddress
+#if defined(IPV6_SOCKET_SUPPORT)
+    , HostAddress6
+    , hostAddress6ToTuple
+    , tupleToHostAddress6
+    , FlowInfo
+    , ScopeID
+#endif
+    , SocketAddress
+    , InetSocketAddress
+    , InetAddress
+    , InetAddressArray
+    , Inet4Address
+    , Inet6Address
+    , getByAddress
+    , mkInetSocketAddress
+    , inetAddrInt
+    , toJByteArray
+
+    -- * Unsorted
+    , ProtocolNumber
+    , PortNumber(..)
+
+    -- * Low-level helpers
+    , zeroMemory
+    ) where
+
+import Control.Concurrent.MVar
+import Control.Monad
+import Data.Bits
+import Data.Maybe
+import Data.Ratio
+import Data.Typeable
+import Data.Word
+import Data.Int
+import Foreign.C
+import Foreign.Ptr
+import Foreign.Storable
+import System.Posix.Types (Channel)
+
+import Java
+
+-- | Represents a socket.  The fields are, respectively:
+--
+--   * File descriptor
+--   * Socket family
+--   * Socket type
+--   * Protocol number
+--   * Status flag
+--
+--   If you are calling the 'MkSocket' constructor directly you should ensure
+--   you have called 'Network.withSocketsDo' and that the file descriptor is
+--   in non-blocking mode. See 'Network.Socket.setNonBlockIfNeeded'.
+data Socket
+  = MkSocket
+            Channel              -- File Descriptor
+            Family
+            SocketType
+            ProtocolNumber       -- Protocol Number
+            (MVar SocketStatus)  -- Status Flag
+  deriving Typeable
+
+sockFd :: Socket -> Channel
+sockFd       (MkSocket n _ _ _ _) = n
+
+sockFamily :: Socket -> Family
+sockFamily   (MkSocket _ f _ _ _) = f
+
+sockType :: Socket -> SocketType
+sockType     (MkSocket _ _ t _ _) = t
+
+sockProtocol :: Socket -> ProtocolNumber
+sockProtocol (MkSocket _ _ _ p _) = p
+
+sockStatus :: Socket -> MVar SocketStatus
+sockStatus   (MkSocket _ _ _ _ s) = s
+
+instance Eq Socket where
+  (MkSocket _ _ _ _ m1) == (MkSocket _ _ _ _ m2) = m1 == m2
+
+instance Show Socket where
+  showsPrec _n (MkSocket fd _ _ _ _) =
+#if ((ETA_VERSION == 9) && (ETA_BUILD_NUMBER >= 2)) || (ETA_VERSION > 9)
+        showString "<socket: " . shows fd . showString ">"
+#else
+        showString "<socket" . showString ">"
+#endif
+
+
+type ProtocolNumber = CInt
+
+-- | The status of the socket as /determined by this library/, not
+-- necessarily reflecting the state of the connection itself.
+--
+-- For example, the 'Closed' status is applied when the 'close'
+-- function is called.
+data SocketStatus
+  -- Returned Status    Function called
+  = NotConnected        -- ^ Newly created, unconnected socket
+  | Bound SockAddr      -- ^ Bound, via 'bind'
+  | Listening           -- ^ Listening, via 'listen'
+  | Connected           -- ^ Connected or accepted, via 'connect' or 'accept'
+  | ConvertedToHandle   -- ^ Is now a 'Handle' (via 'socketToHandle'), don't touch
+  | Closed              -- ^ Closed was closed by 'close'
+    deriving (Eq, Typeable)
+
+-----------------------------------------------------------------------------
+-- Socket types
+
+-- There are a few possible ways to do this.  The first is convert the
+-- structs used in the C library into an equivalent Haskell type. An
+-- other possible implementation is to keep all the internals in the C
+-- code and use an Int## and a status flag. The second method is used
+-- here since a lot of the C structures are not required to be
+-- manipulated.
+
+-- Originally the status was non-mutable so we had to return a new
+-- socket each time we changed the status.  This version now uses
+-- mutable variables to avoid the need to do this.  The result is a
+-- cleaner interface and better security since the application
+-- programmer now can't circumvent the status information to perform
+-- invalid operations on sockets.
+
+-- | Socket Types.
+--
+-- The existence of a constructor does not necessarily imply that that
+-- socket type is supported on your system: see 'isSupportedSocketType'.
+data SocketType
+        = NoSocketType -- ^ 0, used in getAddrInfo hints, for example
+        | Stream -- ^ SOCK_STREAM
+        | Datagram -- ^ SOCK_DGRAM
+        | Raw -- ^ SOCK_RAW
+        | RDM -- ^ SOCK_RDM
+        | SeqPacket -- ^ SOCK_SEQPACKET
+        | ServerSocket SocketType -- ^ ServerSocket
+        deriving (Eq, Ord, Read, Show, Typeable)
+
+-- | Does the SOCK_ constant corresponding to the given SocketType exist on
+-- this system?
+isSupportedSocketType :: SocketType -> Bool
+isSupportedSocketType = isJust . packSocketType'
+
+-- | Find the SOCK_ constant corresponding to the SocketType value.
+packSocketType' :: SocketType -> Maybe CInt
+packSocketType' stype = case Just stype of
+    -- the Just above is to disable GHC's overlapping pattern
+    -- detection: see comments for packSocketOption
+    Just NoSocketType     -> Just 0
+    Just Stream           -> Just 1
+    Just Datagram         -> Just 2
+    Just (ServerSocket _) -> Just 3
+    _                     -> Nothing
+
+packSocketType :: SocketType -> CInt
+packSocketType stype = fromMaybe (error errMsg) (packSocketType' stype)
+  where
+    errMsg = concat ["Network.Socket.packSocketType: ",
+                     "socket type ", show stype, " unsupported on this system"]
+
+-- | Try packSocketType' on the SocketType, if it fails throw an error with
+-- message starting "Network.Socket." ++ the String parameter
+packSocketTypeOrThrow :: String -> SocketType -> IO CInt
+packSocketTypeOrThrow caller stype = maybe err return (packSocketType' stype)
+ where
+  err = ioError . userError . concat $ ["Network.Socket.", caller, ": ",
+    "socket type ", show stype, " unsupported on this system"]
+
+
+unpackSocketType:: CInt -> Maybe SocketType
+unpackSocketType t = case t of
+        0 -> Just NoSocketType
+#ifdef SOCK_STREAM
+        1 -> Just Stream
+#endif
+#ifdef SOCK_DGRAM
+        2 -> Just Datagram
+#endif
+#ifdef SOCK_STREAM
+        3 -> Just (ServerSocket Stream)
+#endif
+#ifdef SOCK_RAW
+        (#const SOCK_RAW) -> Just Raw
+#endif
+#ifdef SOCK_RDM
+        (#const SOCK_RDM) -> Just RDM
+#endif
+#ifdef SOCK_SEQPACKET
+        (#const SOCK_SEQPACKET) -> Just SeqPacket
+#endif
+        _ -> Nothing
+
+-- | Try unpackSocketType on the CInt, if it fails throw an error with
+-- message starting "Network.Socket." ++ the String parameter
+unpackSocketType' :: String -> CInt -> IO SocketType
+unpackSocketType' caller ty = maybe err return (unpackSocketType ty)
+ where
+  err = ioError . userError . concat $ ["Network.Socket.", caller, ": ",
+    "socket type ", show ty, " unsupported on this system"]
+
+------------------------------------------------------------------------
+-- Protocol Families.
+
+-- | Address families.
+--
+-- A constructor being present here does not mean it is supported by the
+-- operating system: see 'isSupportedFamily'.
+data Family
+    = AF_UNSPEC           -- unspecified
+    | AF_UNIX             -- local to host (pipes, portals
+    | AF_INET             -- internetwork: UDP, TCP, etc
+    | AF_INET6            -- Internet Protocol version 6
+    | AF_IMPLINK          -- arpanet imp addresses
+    | AF_PUP              -- pup protocols: e.g. BSP
+    | AF_CHAOS            -- mit CHAOS protocols
+    | AF_NS               -- XEROX NS protocols
+    | AF_NBS              -- nbs protocols
+    | AF_ECMA             -- european computer manufacturers
+    | AF_DATAKIT          -- datakit protocols
+    | AF_CCITT            -- CCITT protocols, X.25 etc
+    | AF_SNA              -- IBM SNA
+    | AF_DECnet           -- DECnet
+    | AF_DLI              -- Direct data link interface
+    | AF_LAT              -- LAT
+    | AF_HYLINK           -- NSC Hyperchannel
+    | AF_APPLETALK        -- Apple Talk
+    | AF_ROUTE            -- Internal Routing Protocol
+    | AF_NETBIOS          -- NetBios-style addresses
+    | AF_NIT              -- Network Interface Tap
+    | AF_802              -- IEEE 802.2, also ISO 8802
+    | AF_ISO              -- ISO protocols
+    | AF_OSI              -- umbrella of all families used by OSI
+    | AF_NETMAN           -- DNA Network Management
+    | AF_X25              -- CCITT X.25
+    | AF_AX25
+    | AF_OSINET           -- AFI
+    | AF_GOSSIP           -- US Government OSI
+    | AF_IPX              -- Novell Internet Protocol
+    | Pseudo_AF_XTP       -- eXpress Transfer Protocol (no AF)
+    | AF_CTF              -- Common Trace Facility
+    | AF_WAN              -- Wide Area Network protocols
+    | AF_SDL              -- SGI Data Link for DLPI
+    | AF_NETWARE
+    | AF_NDD
+    | AF_INTF             -- Debugging use only
+    | AF_COIP             -- connection-oriented IP, aka ST II
+    | AF_CNT              -- Computer Network Technology
+    | Pseudo_AF_RTIP      -- Help Identify RTIP packets
+    | Pseudo_AF_PIP       -- Help Identify PIP packets
+    | AF_SIP              -- Simple Internet Protocol
+    | AF_ISDN             -- Integrated Services Digital Network
+    | Pseudo_AF_KEY       -- Internal key-management function
+    | AF_NATM             -- native ATM access
+    | AF_ARP              -- (rev.) addr. res. prot. (RFC 826)
+    | Pseudo_AF_HDRCMPLT  -- Used by BPF to not rewrite hdrs in iface output
+    | AF_ENCAP
+    | AF_LINK             -- Link layer interface
+    | AF_RAW              -- Link layer interface
+    | AF_RIF              -- raw interface
+    | AF_NETROM           -- Amateur radio NetROM
+    | AF_BRIDGE           -- multiprotocol bridge
+    | AF_ATMPVC           -- ATM PVCs
+    | AF_ROSE             -- Amateur Radio X.25 PLP
+    | AF_NETBEUI          -- 802.2LLC
+    | AF_SECURITY         -- Security callback pseudo AF
+    | AF_PACKET           -- Packet family
+    | AF_ASH              -- Ash
+    | AF_ECONET           -- Acorn Econet
+    | AF_ATMSVC           -- ATM SVCs
+    | AF_IRDA             -- IRDA sockets
+    | AF_PPPOX            -- PPPoX sockets
+    | AF_WANPIPE          -- Wanpipe API sockets
+    | AF_BLUETOOTH        -- bluetooth sockets
+    | AF_CAN              -- Controller Area Network
+      deriving (Eq, Ord, Read, Show)
+
+packFamily :: Family -> CInt
+packFamily f = case packFamily' f of
+    Just fam -> fam
+    Nothing -> error $
+               "Network.Socket.packFamily: unsupported address family: " ++
+               show f
+
+-- | Does the AF_ constant corresponding to the given family exist on this
+-- system?
+isSupportedFamily :: Family -> Bool
+isSupportedFamily = isJust . packFamily'
+
+packFamily' :: Family -> Maybe CInt
+packFamily' f = case Just f of
+    -- the Just above is to disable GHC's overlapping pattern
+    -- detection: see comments for packSocketOption
+    Just AF_UNSPEC -> Just 0
+#ifdef AF_UNIX
+    Just AF_UNIX -> Just #const AF_UNIX
+#endif
+#ifdef DEF_AF_INET
+    Just AF_INET -> Just 1
+#endif
+#ifdef DEF_AF_INET6
+    Just AF_INET6 -> Just 2
+#endif
+#ifdef AF_IMPLINK
+    Just AF_IMPLINK -> Just #const AF_IMPLINK
+#endif
+#ifdef AF_PUP
+    Just AF_PUP -> Just #const AF_PUP
+#endif
+#ifdef AF_CHAOS
+    Just AF_CHAOS -> Just #const AF_CHAOS
+#endif
+#ifdef AF_NS
+    Just AF_NS -> Just #const AF_NS
+#endif
+#ifdef AF_NBS
+    Just AF_NBS -> Just #const AF_NBS
+#endif
+#ifdef AF_ECMA
+    Just AF_ECMA -> Just #const AF_ECMA
+#endif
+#ifdef AF_DATAKIT
+    Just AF_DATAKIT -> Just #const AF_DATAKIT
+#endif
+#ifdef AF_CCITT
+    Just AF_CCITT -> Just #const AF_CCITT
+#endif
+#ifdef AF_SNA
+    Just AF_SNA -> Just #const AF_SNA
+#endif
+#ifdef AF_DECnet
+    Just AF_DECnet -> Just #const AF_DECnet
+#endif
+#ifdef AF_DLI
+    Just AF_DLI -> Just #const AF_DLI
+#endif
+#ifdef AF_LAT
+    Just AF_LAT -> Just #const AF_LAT
+#endif
+#ifdef AF_HYLINK
+    Just AF_HYLINK -> Just #const AF_HYLINK
+#endif
+#ifdef AF_APPLETALK
+    Just AF_APPLETALK -> Just #const AF_APPLETALK
+#endif
+#ifdef AF_ROUTE
+    Just AF_ROUTE -> Just #const AF_ROUTE
+#endif
+#ifdef AF_NETBIOS
+    Just AF_NETBIOS -> Just #const AF_NETBIOS
+#endif
+#ifdef AF_NIT
+    Just AF_NIT -> Just #const AF_NIT
+#endif
+#ifdef AF_802
+    Just AF_802 -> Just #const AF_802
+#endif
+#ifdef AF_ISO
+    Just AF_ISO -> Just #const AF_ISO
+#endif
+#ifdef AF_OSI
+    Just AF_OSI -> Just #const AF_OSI
+#endif
+#ifdef AF_NETMAN
+    Just AF_NETMAN -> Just #const AF_NETMAN
+#endif
+#ifdef AF_X25
+    Just AF_X25 -> Just #const AF_X25
+#endif
+#ifdef AF_AX25
+    Just AF_AX25 -> Just #const AF_AX25
+#endif
+#ifdef AF_OSINET
+    Just AF_OSINET -> Just #const AF_OSINET
+#endif
+#ifdef AF_GOSSIP
+    Just AF_GOSSIP -> Just #const AF_GOSSIP
+#endif
+#ifdef AF_IPX
+    Just AF_IPX -> Just #const AF_IPX
+#endif
+#ifdef Pseudo_AF_XTP
+    Just Pseudo_AF_XTP -> Just #const Pseudo_AF_XTP
+#endif
+#ifdef AF_CTF
+    Just AF_CTF -> Just #const AF_CTF
+#endif
+#ifdef AF_WAN
+    Just AF_WAN -> Just #const AF_WAN
+#endif
+#ifdef AF_SDL
+    Just AF_SDL -> Just #const AF_SDL
+#endif
+#ifdef AF_NETWARE
+    Just AF_NETWARE -> Just #const AF_NETWARE
+#endif
+#ifdef AF_NDD
+    Just AF_NDD -> Just #const AF_NDD
+#endif
+#ifdef AF_INTF
+    Just AF_INTF -> Just #const AF_INTF
+#endif
+#ifdef AF_COIP
+    Just AF_COIP -> Just #const AF_COIP
+#endif
+#ifdef AF_CNT
+    Just AF_CNT -> Just #const AF_CNT
+#endif
+#ifdef Pseudo_AF_RTIP
+    Just Pseudo_AF_RTIP -> Just #const Pseudo_AF_RTIP
+#endif
+#ifdef Pseudo_AF_PIP
+    Just Pseudo_AF_PIP -> Just #const Pseudo_AF_PIP
+#endif
+#ifdef AF_SIP
+    Just AF_SIP -> Just #const AF_SIP
+#endif
+#ifdef AF_ISDN
+    Just AF_ISDN -> Just #const AF_ISDN
+#endif
+#ifdef Pseudo_AF_KEY
+    Just Pseudo_AF_KEY -> Just #const Pseudo_AF_KEY
+#endif
+#ifdef AF_NATM
+    Just AF_NATM -> Just #const AF_NATM
+#endif
+#ifdef AF_ARP
+    Just AF_ARP -> Just #const AF_ARP
+#endif
+#ifdef Pseudo_AF_HDRCMPLT
+    Just Pseudo_AF_HDRCMPLT -> Just #const Pseudo_AF_HDRCMPLT
+#endif
+#ifdef AF_ENCAP
+    Just AF_ENCAP -> Just #const AF_ENCAP
+#endif
+#ifdef AF_LINK
+    Just AF_LINK -> Just #const AF_LINK
+#endif
+#ifdef AF_RAW
+    Just AF_RAW -> Just #const AF_RAW
+#endif
+#ifdef AF_RIF
+    Just AF_RIF -> Just #const AF_RIF
+#endif
+#ifdef AF_NETROM
+    Just AF_NETROM -> Just #const AF_NETROM
+#endif
+#ifdef AF_BRIDGE
+    Just AF_BRIDGE -> Just #const AF_BRIDGE
+#endif
+#ifdef AF_ATMPVC
+    Just AF_ATMPVC -> Just #const AF_ATMPVC
+#endif
+#ifdef AF_ROSE
+    Just AF_ROSE -> Just #const AF_ROSE
+#endif
+#ifdef AF_NETBEUI
+    Just AF_NETBEUI -> Just #const AF_NETBEUI
+#endif
+#ifdef AF_SECURITY
+    Just AF_SECURITY -> Just #const AF_SECURITY
+#endif
+#ifdef AF_PACKET
+    Just AF_PACKET -> Just #const AF_PACKET
+#endif
+#ifdef AF_ASH
+    Just AF_ASH -> Just #const AF_ASH
+#endif
+#ifdef AF_ECONET
+    Just AF_ECONET -> Just #const AF_ECONET
+#endif
+#ifdef AF_ATMSVC
+    Just AF_ATMSVC -> Just #const AF_ATMSVC
+#endif
+#ifdef AF_IRDA
+    Just AF_IRDA -> Just #const AF_IRDA
+#endif
+#ifdef AF_PPPOX
+    Just AF_PPPOX -> Just #const AF_PPPOX
+#endif
+#ifdef AF_WANPIPE
+    Just AF_WANPIPE -> Just #const AF_WANPIPE
+#endif
+#ifdef AF_BLUETOOTH
+    Just AF_BLUETOOTH -> Just #const AF_BLUETOOTH
+#endif
+#ifdef AF_CAN
+    Just AF_CAN -> Just #const AF_CAN
+#endif
+    _ -> Nothing
+
+--------- ----------
+
+unpackFamily :: CInt -> Family
+unpackFamily f = case f of
+        0 -> AF_UNSPEC
+#ifdef AF_UNIX
+        (#const AF_UNIX) -> AF_UNIX
+#endif
+#ifdef DEF_AF_INET
+        1 -> AF_INET
+#endif
+#ifdef DEF_AF_INET6
+        2 -> AF_INET6
+#endif
+#ifdef AF_IMPLINK
+        (#const AF_IMPLINK) -> AF_IMPLINK
+#endif
+#ifdef AF_PUP
+        (#const AF_PUP) -> AF_PUP
+#endif
+#ifdef AF_CHAOS
+        (#const AF_CHAOS) -> AF_CHAOS
+#endif
+#ifdef AF_NS
+        (#const AF_NS) -> AF_NS
+#endif
+#ifdef AF_NBS
+        (#const AF_NBS) -> AF_NBS
+#endif
+#ifdef AF_ECMA
+        (#const AF_ECMA) -> AF_ECMA
+#endif
+#ifdef AF_DATAKIT
+        (#const AF_DATAKIT) -> AF_DATAKIT
+#endif
+#ifdef AF_CCITT
+        (#const AF_CCITT) -> AF_CCITT
+#endif
+#ifdef AF_SNA
+        (#const AF_SNA) -> AF_SNA
+#endif
+#ifdef AF_DECnet
+        (#const AF_DECnet) -> AF_DECnet
+#endif
+#ifdef AF_DLI
+        (#const AF_DLI) -> AF_DLI
+#endif
+#ifdef AF_LAT
+        (#const AF_LAT) -> AF_LAT
+#endif
+#ifdef AF_HYLINK
+        (#const AF_HYLINK) -> AF_HYLINK
+#endif
+#ifdef AF_APPLETALK
+        (#const AF_APPLETALK) -> AF_APPLETALK
+#endif
+#ifdef AF_ROUTE
+        (#const AF_ROUTE) -> AF_ROUTE
+#endif
+#ifdef AF_NETBIOS
+        (#const AF_NETBIOS) -> AF_NETBIOS
+#endif
+#ifdef AF_NIT
+        (#const AF_NIT) -> AF_NIT
+#endif
+#ifdef AF_802
+        (#const AF_802) -> AF_802
+#endif
+#ifdef AF_ISO
+        (#const AF_ISO) -> AF_ISO
+#endif
+#ifdef AF_OSI
+# if (!defined(AF_ISO)) || (defined(AF_ISO) && (AF_ISO != AF_OSI))
+        (#const AF_OSI) -> AF_OSI
+# endif
+#endif
+#ifdef AF_NETMAN
+        (#const AF_NETMAN) -> AF_NETMAN
+#endif
+#ifdef AF_X25
+        (#const AF_X25) -> AF_X25
+#endif
+#ifdef AF_AX25
+        (#const AF_AX25) -> AF_AX25
+#endif
+#ifdef AF_OSINET
+        (#const AF_OSINET) -> AF_OSINET
+#endif
+#ifdef AF_GOSSIP
+        (#const AF_GOSSIP) -> AF_GOSSIP
+#endif
+#if defined(AF_IPX) && (!defined(AF_NS) || AF_NS != AF_IPX)
+        (#const AF_IPX) -> AF_IPX
+#endif
+#ifdef Pseudo_AF_XTP
+        (#const Pseudo_AF_XTP) -> Pseudo_AF_XTP
+#endif
+#ifdef AF_CTF
+        (#const AF_CTF) -> AF_CTF
+#endif
+#ifdef AF_WAN
+        (#const AF_WAN) -> AF_WAN
+#endif
+#ifdef AF_SDL
+        (#const AF_SDL) -> AF_SDL
+#endif
+#ifdef AF_NETWARE
+        (#const AF_NETWARE) -> AF_NETWARE
+#endif
+#ifdef AF_NDD
+        (#const AF_NDD) -> AF_NDD
+#endif
+#ifdef AF_INTF
+        (#const AF_INTF) -> AF_INTF
+#endif
+#ifdef AF_COIP
+        (#const AF_COIP) -> AF_COIP
+#endif
+#ifdef AF_CNT
+        (#const AF_CNT) -> AF_CNT
+#endif
+#ifdef Pseudo_AF_RTIP
+        (#const Pseudo_AF_RTIP) -> Pseudo_AF_RTIP
+#endif
+#ifdef Pseudo_AF_PIP
+        (#const Pseudo_AF_PIP) -> Pseudo_AF_PIP
+#endif
+#ifdef AF_SIP
+        (#const AF_SIP) -> AF_SIP
+#endif
+#ifdef AF_ISDN
+        (#const AF_ISDN) -> AF_ISDN
+#endif
+#ifdef Pseudo_AF_KEY
+        (#const Pseudo_AF_KEY) -> Pseudo_AF_KEY
+#endif
+#ifdef AF_NATM
+        (#const AF_NATM) -> AF_NATM
+#endif
+#ifdef AF_ARP
+        (#const AF_ARP) -> AF_ARP
+#endif
+#ifdef Pseudo_AF_HDRCMPLT
+        (#const Pseudo_AF_HDRCMPLT) -> Pseudo_AF_HDRCMPLT
+#endif
+#ifdef AF_ENCAP
+        (#const AF_ENCAP) -> AF_ENCAP
+#endif
+#ifdef AF_LINK
+        (#const AF_LINK) -> AF_LINK
+#endif
+#ifdef AF_RAW
+        (#const AF_RAW) -> AF_RAW
+#endif
+#ifdef AF_RIF
+        (#const AF_RIF) -> AF_RIF
+#endif
+#ifdef AF_NETROM
+        (#const AF_NETROM) -> AF_NETROM
+#endif
+#ifdef AF_BRIDGE
+        (#const AF_BRIDGE) -> AF_BRIDGE
+#endif
+#ifdef AF_ATMPVC
+        (#const AF_ATMPVC) -> AF_ATMPVC
+#endif
+#ifdef AF_ROSE
+        (#const AF_ROSE) -> AF_ROSE
+#endif
+#ifdef AF_NETBEUI
+        (#const AF_NETBEUI) -> AF_NETBEUI
+#endif
+#ifdef AF_SECURITY
+        (#const AF_SECURITY) -> AF_SECURITY
+#endif
+#ifdef AF_PACKET
+        (#const AF_PACKET) -> AF_PACKET
+#endif
+#ifdef AF_ASH
+        (#const AF_ASH) -> AF_ASH
+#endif
+#ifdef AF_ECONET
+        (#const AF_ECONET) -> AF_ECONET
+#endif
+#ifdef AF_ATMSVC
+        (#const AF_ATMSVC) -> AF_ATMSVC
+#endif
+#ifdef AF_IRDA
+        (#const AF_IRDA) -> AF_IRDA
+#endif
+#ifdef AF_PPPOX
+        (#const AF_PPPOX) -> AF_PPPOX
+#endif
+#ifdef AF_WANPIPE
+        (#const AF_WANPIPE) -> AF_WANPIPE
+#endif
+#ifdef AF_BLUETOOTH
+        (#const AF_BLUETOOTH) -> AF_BLUETOOTH
+#endif
+#ifdef AF_CAN
+        (#const AF_CAN) -> AF_CAN
+#endif
+        unknown -> error $
+          "Network.Socket.Types.unpackFamily: unknown address family: " ++
+          show unknown
+
+------------------------------------------------------------------------
+-- Port Numbers
+
+-- | Use the @Num@ instance (i.e. use a literal) to create a
+-- @PortNumber@ value with the correct network-byte-ordering. You
+-- should not use the PortNum constructor. It will be removed in the
+-- next release.
+--
+-- >>> 1 :: PortNumber
+-- 1
+-- >>> read "1" :: PortNumber
+-- 1
+newtype PortNumber = PortNum Word16 deriving (Eq, Ord, Typeable)
+-- newtyped to prevent accidental use of sane-looking
+-- port numbers that haven't actually been converted to
+-- network-byte-order first.
+
+{-# DEPRECATED PortNum "Do not use the PortNum constructor. Use the Num instance. PortNum will be removed in the next release." #-}
+
+instance Show PortNumber where
+  showsPrec p pn = showsPrec p (portNumberToInt pn)
+
+instance Read PortNumber where
+  readsPrec n = map (\(x,y) -> (intToPortNumber x, y)) . readsPrec n
+
+intToPortNumber :: Int -> PortNumber
+intToPortNumber v = PortNum (fromIntegral v)
+
+portNumberToInt :: PortNumber -> Int
+portNumberToInt (PortNum po) = fromIntegral po
+
+instance Enum PortNumber where
+    toEnum   = intToPortNumber
+    fromEnum = portNumberToInt
+
+instance Num PortNumber where
+   fromInteger i = intToPortNumber (fromInteger i)
+    -- for completeness.
+   (+) x y   = intToPortNumber (portNumberToInt x + portNumberToInt y)
+   (-) x y   = intToPortNumber (portNumberToInt x - portNumberToInt y)
+   negate x  = intToPortNumber (-portNumberToInt x)
+   (*) x y   = intToPortNumber (portNumberToInt x * portNumberToInt y)
+   abs n     = intToPortNumber (abs (portNumberToInt n))
+   signum n  = intToPortNumber (signum (portNumberToInt n))
+
+instance Real PortNumber where
+    toRational x = toInteger x % 1
+
+instance Integral PortNumber where
+    quotRem a b = let (c,d) = quotRem (portNumberToInt a) (portNumberToInt b) in
+                  (intToPortNumber c, intToPortNumber d)
+    toInteger a = toInteger (portNumberToInt a)
+
+instance Storable PortNumber where
+   sizeOf    _ = sizeOf    (undefined :: Word16)
+   alignment _ = alignment (undefined :: Word16)
+   poke p (PortNum po) = poke (castPtr p) po
+   peek p = PortNum `liftM` peek (castPtr p)
+
+------------------------------------------------------------------------
+-- Socket addresses
+
+-- The scheme used for addressing sockets is somewhat quirky. The
+-- calls in the BSD socket API that need to know the socket address
+-- all operate in terms of struct sockaddr, a `virtual' type of
+-- socket address.
+
+-- The Internet family of sockets are addressed as struct sockaddr_in,
+-- so when calling functions that operate on struct sockaddr, we have
+-- to type cast the Internet socket address into a struct sockaddr.
+-- Instances of the structure for different families might *not* be
+-- the same size. Same casting is required of other families of
+-- sockets such as Xerox NS. Similarly for Unix domain sockets.
+
+-- To represent these socket addresses in Haskell-land, we do what BSD
+-- didn't do, and use a union/algebraic type for the different
+-- families. Currently only Unix domain sockets and the Internet
+-- families are supported.
+
+#if defined(IPV6_SOCKET_SUPPORT)
+type FlowInfo = Word32
+type ScopeID = Word32
+#endif
+
+-- | The existence of a constructor does not necessarily imply that
+-- that socket address type is supported on your system: see
+-- 'isSupportedSockAddr'.
+data SockAddr       -- C Names
+  = SockAddrInet
+    PortNumber  -- sin_port  (network byte order)
+    HostAddress -- sin_addr  (ditto)
+  | SockAddrInet6
+        PortNumber      -- sin6_port (network byte order)
+        FlowInfo        -- sin6_flowinfo (ditto)
+        HostAddress6    -- sin6_addr (ditto)
+        ScopeID         -- sin6_scope_id (ditto)
+  | SockAddrUnix
+        String          -- sun_path
+  | SockAddrCan
+        Int32           -- can_ifindex (can be get by Network.BSD.ifNameToIndex "can0")
+        -- TODO: Extend this to include transport protocol information
+  deriving (Eq, Ord, Typeable)
+
+-- | Is the socket address type supported on this system?
+isSupportedSockAddr :: SockAddr -> Bool
+isSupportedSockAddr addr = case addr of
+  SockAddrInet {} -> True
+#if defined(IPV6_SOCKET_SUPPORT)
+  SockAddrInet6 {} -> True
+#endif
+#if defined(DOMAIN_SOCKET_SUPPORT)
+  SockAddrUnix{} -> True
+#endif
+#if defined(CAN_SOCKET_SUPPORT)
+  SockAddrCan{} -> True
+#endif
+#if !(defined(IPV6_SOCKET_SUPPORT) \
+      && defined(DOMAIN_SOCKET_SUPPORT) && defined(CAN_SOCKET_SUPPORT))
+  _ -> False
+#endif
+
+-- | Use a 'SockAddr' with a function requiring a pointer to a
+-- 'SockAddr' and the length of that 'SockAddr'.
+newSockAddr :: Channel -> IO SockAddr
+newSockAddr ch = do
+  sock <- getSockAddr ch
+  let inet = inetAddrInt (sockInetAddress sock)
+      port = sockPort sock
+  return $ SockAddrInet (fromIntegral port) inet
+
+-- | Use a 'SockAddr' with a function requiring a pointer to a
+-- 'SockAddr' and the length of that 'SockAddr'.
+withSockAddr :: SockAddr -> (SocketAddress -> IO a) -> IO a
+withSockAddr addr f = case addr of
+  SockAddrInet port host ->
+    f $ superCast $ mkInetSocketAddress
+      (getByAddress . toJByteArray $ padWord8s 4 host)
+      (fromIntegral port)
+  SockAddrInet6 port _ (w1, w2, w3, w4) _ ->
+    f $ superCast $ mkInetSocketAddress
+      (getByAddress . toJByteArray $ concatMap (padWord8s 4) [w1, w2, w3, w4])
+      (fromIntegral port)
+  _ -> error "Network.Socket.Types.withSockAddr: Invalid socket address type."
+  where toWord8s :: (Bits a, Integral a) => a -> [Word8]
+        toWord8s 0 = []
+        toWord8s n = fromIntegral (n .&. 255) : toWord8s (n `shiftR` 8)
+
+        padWord8s :: (Bits a, Integral a) => Int -> a -> [Word8]
+        padWord8s n a = replicate (abs (n - length word8s)) 0 ++ word8s
+          where word8s = reverse (toWord8s a)
+
+------------------------------------------------------------------------
+
+-- | The raw network byte order number is read using host byte order.
+-- Therefore on little-endian architectures the byte order is swapped. For
+-- example @127.0.0.1@ is represented as @0x0100007f@ on little-endian hosts
+-- and as @0x7f000001@ on big-endian hosts.
+--
+-- For direct manipulation prefer 'hostAddressToTuple' and
+-- 'tupleToHostAddress'.
+type HostAddress = Word32
+
+-- | Converts 'HostAddress' to representation-independent IPv4 quadruple.
+-- For example for @127.0.0.1@ the function will return @(0x7f, 0, 0, 1)@
+-- regardless of host endianness.
+hostAddressToTuple :: HostAddress -> (Word8, Word8, Word8, Word8)
+hostAddressToTuple ha' =
+    let ha = ha'
+        byte i = fromIntegral (ha `shiftR` i) :: Word8
+    in (byte 24, byte 16, byte 8, byte 0)
+
+-- | Converts IPv4 quadruple to 'HostAddress'.
+tupleToHostAddress :: (Word8, Word8, Word8, Word8) -> HostAddress
+tupleToHostAddress (b3, b2, b1, b0) =
+    let x `sl` i = fromIntegral x `shiftL` i :: Word32
+    in (b3 `sl` 24) .|. (b2 `sl` 16) .|. (b1 `sl` 8) .|. (b0 `sl` 0)
+
+#if defined(IPV6_SOCKET_SUPPORT)
+-- | Independent of endianness. For example @::1@ is stored as @(0, 0, 0, 1)@.
+--
+-- For direct manipulation prefer 'hostAddress6ToTuple' and
+-- 'tupleToHostAddress6'.
+type HostAddress6 = (Word32, Word32, Word32, Word32)
+
+hostAddress6ToTuple :: HostAddress6 -> (Word16, Word16, Word16, Word16,
+                                        Word16, Word16, Word16, Word16)
+hostAddress6ToTuple (w3, w2, w1, w0) =
+    let high, low :: Word32 -> Word16
+        high w = fromIntegral (w `shiftR` 16)
+        low w = fromIntegral w
+    in (high w3, low w3, high w2, low w2, high w1, low w1, high w0, low w0)
+
+tupleToHostAddress6 :: (Word16, Word16, Word16, Word16,
+                        Word16, Word16, Word16, Word16) -> HostAddress6
+tupleToHostAddress6 (w7, w6, w5, w4, w3, w2, w1, w0) =
+    let add :: Word16 -> Word16 -> Word32
+        high `add` low = (fromIntegral high `shiftL` 16) .|. (fromIntegral low)
+    in (w7 `add` w6, w5 `add` w4, w3 `add` w2, w1 `add` w0)
+#endif
+
+-- ------------------------------------------------------------------------
+-- -- Helper functions
+
+
+foreign import java unsafe "@static eta.base.Utils.c_memset" memset
+  :: Ptr a -> CInt -> CSize -> IO (Ptr a)
+
+-- | Zero a structure.
+zeroMemory :: Ptr a -> CSize -> IO ()
+zeroMemory dest nbytes = memset dest 0 (fromIntegral nbytes) >> return ()
+
+data {-# CLASS "java.net.SocketAddress" #-} SocketAddress =
+  SA (Object# SocketAddress)
+  deriving Class
+
+type instance Inherits SocketAddress = '[Object]
+
+data {-# CLASS "java.net.InetSocketAddress" #-} InetSocketAddress =
+  ISA (Object# InetSocketAddress)
+  deriving Class
+
+type instance Inherits InetSocketAddress = '[SocketAddress]
+
+data {-# CLASS "java.net.InetAddress" #-} InetAddress =
+  IA (Object# InetAddress)
+  deriving Class
+
+type instance Inherits InetAddress = '[Object]
+
+data {-# CLASS "java.net.InetAddress[]" #-} InetAddressArray =
+  IArr (Object# InetAddressArray)
+  deriving Class
+
+instance JArray InetAddress InetAddressArray
+
+data {-# CLASS "java.net.Inet4Address" #-} Inet4Address =
+  I4A (Object# Inet4Address)
+  deriving Class
+
+type instance Inherits Inet4Address = '[InetAddress]
+
+data {-# CLASS "java.net.Inet6Address" #-} Inet6Address =
+  I6A (Object# Inet6Address)
+  deriving Class
+
+type instance Inherits Inet6Address = '[InetAddress]
+
+foreign import java unsafe "@static java.net.InetAddress.getByAddress" getByAddress :: JByteArray -> InetAddress
+
+foreign import java unsafe "@new" mkInetSocketAddress
+  :: InetAddress -> Int -> InetSocketAddress
+
+foreign import java unsafe "@static eta.network.Utils.getSockAddr" getSockAddr
+  :: Channel -> IO InetSocketAddress
+
+foreign import java unsafe "getAddress" sockInetAddress
+  :: InetSocketAddress -> InetAddress
+
+foreign import CALLCONV unsafe "getPort" sockPort :: InetSocketAddress -> Int
+
+toJByteArray :: [Word8] -> JByteArray
+toJByteArray word8s = toJava bytes
+  where bytes = map fromIntegral word8s :: [Byte]
+
+foreign import CALLCONV unsafe "@static eta.network.Utils.inetAddrInt"
+  inetAddrInt :: InetAddress -> Word32
+
diff --git a/Network/Socket/Types.hsc b/Network/Socket/Types.hsc
deleted file mode 100644
index bed07d1..0000000
--- a/Network/Socket/Types.hsc
+++ /dev/null
@@ -1,1111 +0,0 @@
-{-# LANGUAGE DeriveDataTypeable #-}
-{-# LANGUAGE FlexibleInstances #-}
-{-# LANGUAGE ForeignFunctionInterface #-}
-
-#include "HsNet.h"
-
-module Network.Socket.Types
-    (
-    -- * Socket
-      Socket(..)
-    , sockFd
-    , sockFamily
-    , sockType
-    , sockProtocol
-    , sockStatus
-    , SocketStatus(..)
-
-    -- * Socket types
-    , SocketType(..)
-    , isSupportedSocketType
-    , packSocketType
-    , packSocketType'
-    , packSocketTypeOrThrow
-    , unpackSocketType
-    , unpackSocketType'
-
-    -- * Family
-    , Family(..)
-    , isSupportedFamily
-    , packFamily
-    , unpackFamily
-
-    -- * Socket addresses
-    , SockAddr(..)
-    , isSupportedSockAddr
-    , HostAddress
-    , hostAddressToTuple
-    , tupleToHostAddress
-#if defined(IPV6_SOCKET_SUPPORT)
-    , HostAddress6
-    , hostAddress6ToTuple
-    , tupleToHostAddress6
-    , FlowInfo
-    , ScopeID
-#endif
-    , peekSockAddr
-    , pokeSockAddr
-    , sizeOfSockAddr
-    , sizeOfSockAddrByFamily
-    , withSockAddr
-    , withNewSockAddr
-
-    -- * Unsorted
-    , ProtocolNumber
-    , PortNumber(..)
-
-    -- * Low-level helpers
-    , zeroMemory
-    ) where
-
-import Control.Concurrent.MVar
-import Control.Monad
-import Data.Bits
-import Data.Maybe
-import Data.Ratio
-import Data.Typeable
-import Data.Word
-import Data.Int
-import Foreign.C
-import Foreign.Marshal.Alloc
-import Foreign.Marshal.Array
-import Foreign.Ptr
-import Foreign.Storable
-
--- | Represents a socket.  The fields are, respectively:
---
---   * File descriptor
---   * Socket family
---   * Socket type
---   * Protocol number
---   * Status flag
---
---   If you are calling the 'MkSocket' constructor directly you should ensure
---   you have called 'Network.withSocketsDo' and that the file descriptor is
---   in non-blocking mode. See 'Network.Socket.setNonBlockIfNeeded'.
-data Socket
-  = MkSocket
-            CInt                 -- File Descriptor
-            Family
-            SocketType
-            ProtocolNumber       -- Protocol Number
-            (MVar SocketStatus)  -- Status Flag
-  deriving Typeable
-
-sockFd :: Socket -> CInt
-sockFd       (MkSocket n _ _ _ _) = n
-
-sockFamily :: Socket -> Family
-sockFamily   (MkSocket _ f _ _ _) = f
-
-sockType :: Socket -> SocketType
-sockType     (MkSocket _ _ t _ _) = t
-
-sockProtocol :: Socket -> ProtocolNumber
-sockProtocol (MkSocket _ _ _ p _) = p
-
-sockStatus :: Socket -> MVar SocketStatus
-sockStatus   (MkSocket _ _ _ _ s) = s
-
-instance Eq Socket where
-  (MkSocket _ _ _ _ m1) == (MkSocket _ _ _ _ m2) = m1 == m2
-
-instance Show Socket where
-  showsPrec _n (MkSocket fd _ _ _ _) =
-        showString "<socket: " . shows fd . showString ">"
-
-type ProtocolNumber = CInt
-
--- | The status of the socket as /determined by this library/, not
--- necessarily reflecting the state of the connection itself.
---
--- For example, the 'Closed' status is applied when the 'close'
--- function is called.
-data SocketStatus
-  -- Returned Status    Function called
-  = NotConnected        -- ^ Newly created, unconnected socket
-  | Bound               -- ^ Bound, via 'bind'
-  | Listening           -- ^ Listening, via 'listen'
-  | Connected           -- ^ Connected or accepted, via 'connect' or 'accept'
-  | ConvertedToHandle   -- ^ Is now a 'Handle' (via 'socketToHandle'), don't touch
-  | Closed              -- ^ Closed was closed by 'close'
-    deriving (Eq, Show, Typeable)
-
------------------------------------------------------------------------------
--- Socket types
-
--- There are a few possible ways to do this.  The first is convert the
--- structs used in the C library into an equivalent Haskell type. An
--- other possible implementation is to keep all the internals in the C
--- code and use an Int## and a status flag. The second method is used
--- here since a lot of the C structures are not required to be
--- manipulated.
-
--- Originally the status was non-mutable so we had to return a new
--- socket each time we changed the status.  This version now uses
--- mutable variables to avoid the need to do this.  The result is a
--- cleaner interface and better security since the application
--- programmer now can't circumvent the status information to perform
--- invalid operations on sockets.
-
--- | Socket Types.
---
--- The existence of a constructor does not necessarily imply that that
--- socket type is supported on your system: see 'isSupportedSocketType'.
-data SocketType
-        = NoSocketType -- ^ 0, used in getAddrInfo hints, for example
-        | Stream -- ^ SOCK_STREAM
-        | Datagram -- ^ SOCK_DGRAM
-        | Raw -- ^ SOCK_RAW
-        | RDM -- ^ SOCK_RDM
-        | SeqPacket -- ^ SOCK_SEQPACKET
-        deriving (Eq, Ord, Read, Show, Typeable)
-
--- | Does the SOCK_ constant corresponding to the given SocketType exist on
--- this system?
-isSupportedSocketType :: SocketType -> Bool
-isSupportedSocketType = isJust . packSocketType'
-
--- | Find the SOCK_ constant corresponding to the SocketType value.
-packSocketType' :: SocketType -> Maybe CInt
-packSocketType' stype = case Just stype of
-    -- the Just above is to disable GHC's overlapping pattern
-    -- detection: see comments for packSocketOption
-    Just NoSocketType -> Just 0
-#ifdef SOCK_STREAM
-    Just Stream -> Just #const SOCK_STREAM
-#endif
-#ifdef SOCK_DGRAM
-    Just Datagram -> Just #const SOCK_DGRAM
-#endif
-#ifdef SOCK_RAW
-    Just Raw -> Just #const SOCK_RAW
-#endif
-#ifdef SOCK_RDM
-    Just RDM -> Just #const SOCK_RDM
-#endif
-#ifdef SOCK_SEQPACKET
-    Just SeqPacket -> Just #const SOCK_SEQPACKET
-#endif
-    _ -> Nothing
-
-packSocketType :: SocketType -> CInt
-packSocketType stype = fromMaybe (error errMsg) (packSocketType' stype)
-  where
-    errMsg = concat ["Network.Socket.packSocketType: ",
-                     "socket type ", show stype, " unsupported on this system"]
-
--- | Try packSocketType' on the SocketType, if it fails throw an error with
--- message starting "Network.Socket." ++ the String parameter
-packSocketTypeOrThrow :: String -> SocketType -> IO CInt
-packSocketTypeOrThrow caller stype = maybe err return (packSocketType' stype)
- where
-  err = ioError . userError . concat $ ["Network.Socket.", caller, ": ",
-    "socket type ", show stype, " unsupported on this system"]
-
-
-unpackSocketType:: CInt -> Maybe SocketType
-unpackSocketType t = case t of
-        0 -> Just NoSocketType
-#ifdef SOCK_STREAM
-        (#const SOCK_STREAM) -> Just Stream
-#endif
-#ifdef SOCK_DGRAM
-        (#const SOCK_DGRAM) -> Just Datagram
-#endif
-#ifdef SOCK_RAW
-        (#const SOCK_RAW) -> Just Raw
-#endif
-#ifdef SOCK_RDM
-        (#const SOCK_RDM) -> Just RDM
-#endif
-#ifdef SOCK_SEQPACKET
-        (#const SOCK_SEQPACKET) -> Just SeqPacket
-#endif
-        _ -> Nothing
-
--- | Try unpackSocketType on the CInt, if it fails throw an error with
--- message starting "Network.Socket." ++ the String parameter
-unpackSocketType' :: String -> CInt -> IO SocketType
-unpackSocketType' caller ty = maybe err return (unpackSocketType ty)
- where
-  err = ioError . userError . concat $ ["Network.Socket.", caller, ": ",
-    "socket type ", show ty, " unsupported on this system"]
-
-------------------------------------------------------------------------
--- Protocol Families.
-
--- | Address families.
---
--- A constructor being present here does not mean it is supported by the
--- operating system: see 'isSupportedFamily'.
-data Family
-    = AF_UNSPEC           -- unspecified
-    | AF_UNIX             -- local to host (pipes, portals
-    | AF_INET             -- internetwork: UDP, TCP, etc
-    | AF_INET6            -- Internet Protocol version 6
-    | AF_IMPLINK          -- arpanet imp addresses
-    | AF_PUP              -- pup protocols: e.g. BSP
-    | AF_CHAOS            -- mit CHAOS protocols
-    | AF_NS               -- XEROX NS protocols
-    | AF_NBS              -- nbs protocols
-    | AF_ECMA             -- european computer manufacturers
-    | AF_DATAKIT          -- datakit protocols
-    | AF_CCITT            -- CCITT protocols, X.25 etc
-    | AF_SNA              -- IBM SNA
-    | AF_DECnet           -- DECnet
-    | AF_DLI              -- Direct data link interface
-    | AF_LAT              -- LAT
-    | AF_HYLINK           -- NSC Hyperchannel
-    | AF_APPLETALK        -- Apple Talk
-    | AF_ROUTE            -- Internal Routing Protocol
-    | AF_NETBIOS          -- NetBios-style addresses
-    | AF_NIT              -- Network Interface Tap
-    | AF_802              -- IEEE 802.2, also ISO 8802
-    | AF_ISO              -- ISO protocols
-    | AF_OSI              -- umbrella of all families used by OSI
-    | AF_NETMAN           -- DNA Network Management
-    | AF_X25              -- CCITT X.25
-    | AF_AX25
-    | AF_OSINET           -- AFI
-    | AF_GOSSIP           -- US Government OSI
-    | AF_IPX              -- Novell Internet Protocol
-    | Pseudo_AF_XTP       -- eXpress Transfer Protocol (no AF)
-    | AF_CTF              -- Common Trace Facility
-    | AF_WAN              -- Wide Area Network protocols
-    | AF_SDL              -- SGI Data Link for DLPI
-    | AF_NETWARE
-    | AF_NDD
-    | AF_INTF             -- Debugging use only
-    | AF_COIP             -- connection-oriented IP, aka ST II
-    | AF_CNT              -- Computer Network Technology
-    | Pseudo_AF_RTIP      -- Help Identify RTIP packets
-    | Pseudo_AF_PIP       -- Help Identify PIP packets
-    | AF_SIP              -- Simple Internet Protocol
-    | AF_ISDN             -- Integrated Services Digital Network
-    | Pseudo_AF_KEY       -- Internal key-management function
-    | AF_NATM             -- native ATM access
-    | AF_ARP              -- (rev.) addr. res. prot. (RFC 826)
-    | Pseudo_AF_HDRCMPLT  -- Used by BPF to not rewrite hdrs in iface output
-    | AF_ENCAP
-    | AF_LINK             -- Link layer interface
-    | AF_RAW              -- Link layer interface
-    | AF_RIF              -- raw interface
-    | AF_NETROM           -- Amateur radio NetROM
-    | AF_BRIDGE           -- multiprotocol bridge
-    | AF_ATMPVC           -- ATM PVCs
-    | AF_ROSE             -- Amateur Radio X.25 PLP
-    | AF_NETBEUI          -- 802.2LLC
-    | AF_SECURITY         -- Security callback pseudo AF
-    | AF_PACKET           -- Packet family
-    | AF_ASH              -- Ash
-    | AF_ECONET           -- Acorn Econet
-    | AF_ATMSVC           -- ATM SVCs
-    | AF_IRDA             -- IRDA sockets
-    | AF_PPPOX            -- PPPoX sockets
-    | AF_WANPIPE          -- Wanpipe API sockets
-    | AF_BLUETOOTH        -- bluetooth sockets
-    | AF_CAN              -- Controller Area Network
-      deriving (Eq, Ord, Read, Show)
-
-packFamily :: Family -> CInt
-packFamily f = case packFamily' f of
-    Just fam -> fam
-    Nothing -> error $
-               "Network.Socket.packFamily: unsupported address family: " ++
-               show f
-
--- | Does the AF_ constant corresponding to the given family exist on this
--- system?
-isSupportedFamily :: Family -> Bool
-isSupportedFamily = isJust . packFamily'
-
-packFamily' :: Family -> Maybe CInt
-packFamily' f = case Just f of
-    -- the Just above is to disable GHC's overlapping pattern
-    -- detection: see comments for packSocketOption
-    Just AF_UNSPEC -> Just #const AF_UNSPEC
-#ifdef AF_UNIX
-    Just AF_UNIX -> Just #const AF_UNIX
-#endif
-#ifdef AF_INET
-    Just AF_INET -> Just #const AF_INET
-#endif
-#ifdef AF_INET6
-    Just AF_INET6 -> Just #const AF_INET6
-#endif
-#ifdef AF_IMPLINK
-    Just AF_IMPLINK -> Just #const AF_IMPLINK
-#endif
-#ifdef AF_PUP
-    Just AF_PUP -> Just #const AF_PUP
-#endif
-#ifdef AF_CHAOS
-    Just AF_CHAOS -> Just #const AF_CHAOS
-#endif
-#ifdef AF_NS
-    Just AF_NS -> Just #const AF_NS
-#endif
-#ifdef AF_NBS
-    Just AF_NBS -> Just #const AF_NBS
-#endif
-#ifdef AF_ECMA
-    Just AF_ECMA -> Just #const AF_ECMA
-#endif
-#ifdef AF_DATAKIT
-    Just AF_DATAKIT -> Just #const AF_DATAKIT
-#endif
-#ifdef AF_CCITT
-    Just AF_CCITT -> Just #const AF_CCITT
-#endif
-#ifdef AF_SNA
-    Just AF_SNA -> Just #const AF_SNA
-#endif
-#ifdef AF_DECnet
-    Just AF_DECnet -> Just #const AF_DECnet
-#endif
-#ifdef AF_DLI
-    Just AF_DLI -> Just #const AF_DLI
-#endif
-#ifdef AF_LAT
-    Just AF_LAT -> Just #const AF_LAT
-#endif
-#ifdef AF_HYLINK
-    Just AF_HYLINK -> Just #const AF_HYLINK
-#endif
-#ifdef AF_APPLETALK
-    Just AF_APPLETALK -> Just #const AF_APPLETALK
-#endif
-#ifdef AF_ROUTE
-    Just AF_ROUTE -> Just #const AF_ROUTE
-#endif
-#ifdef AF_NETBIOS
-    Just AF_NETBIOS -> Just #const AF_NETBIOS
-#endif
-#ifdef AF_NIT
-    Just AF_NIT -> Just #const AF_NIT
-#endif
-#ifdef AF_802
-    Just AF_802 -> Just #const AF_802
-#endif
-#ifdef AF_ISO
-    Just AF_ISO -> Just #const AF_ISO
-#endif
-#ifdef AF_OSI
-    Just AF_OSI -> Just #const AF_OSI
-#endif
-#ifdef AF_NETMAN
-    Just AF_NETMAN -> Just #const AF_NETMAN
-#endif
-#ifdef AF_X25
-    Just AF_X25 -> Just #const AF_X25
-#endif
-#ifdef AF_AX25
-    Just AF_AX25 -> Just #const AF_AX25
-#endif
-#ifdef AF_OSINET
-    Just AF_OSINET -> Just #const AF_OSINET
-#endif
-#ifdef AF_GOSSIP
-    Just AF_GOSSIP -> Just #const AF_GOSSIP
-#endif
-#ifdef AF_IPX
-    Just AF_IPX -> Just #const AF_IPX
-#endif
-#ifdef Pseudo_AF_XTP
-    Just Pseudo_AF_XTP -> Just #const Pseudo_AF_XTP
-#endif
-#ifdef AF_CTF
-    Just AF_CTF -> Just #const AF_CTF
-#endif
-#ifdef AF_WAN
-    Just AF_WAN -> Just #const AF_WAN
-#endif
-#ifdef AF_SDL
-    Just AF_SDL -> Just #const AF_SDL
-#endif
-#ifdef AF_NETWARE
-    Just AF_NETWARE -> Just #const AF_NETWARE
-#endif
-#ifdef AF_NDD
-    Just AF_NDD -> Just #const AF_NDD
-#endif
-#ifdef AF_INTF
-    Just AF_INTF -> Just #const AF_INTF
-#endif
-#ifdef AF_COIP
-    Just AF_COIP -> Just #const AF_COIP
-#endif
-#ifdef AF_CNT
-    Just AF_CNT -> Just #const AF_CNT
-#endif
-#ifdef Pseudo_AF_RTIP
-    Just Pseudo_AF_RTIP -> Just #const Pseudo_AF_RTIP
-#endif
-#ifdef Pseudo_AF_PIP
-    Just Pseudo_AF_PIP -> Just #const Pseudo_AF_PIP
-#endif
-#ifdef AF_SIP
-    Just AF_SIP -> Just #const AF_SIP
-#endif
-#ifdef AF_ISDN
-    Just AF_ISDN -> Just #const AF_ISDN
-#endif
-#ifdef Pseudo_AF_KEY
-    Just Pseudo_AF_KEY -> Just #const Pseudo_AF_KEY
-#endif
-#ifdef AF_NATM
-    Just AF_NATM -> Just #const AF_NATM
-#endif
-#ifdef AF_ARP
-    Just AF_ARP -> Just #const AF_ARP
-#endif
-#ifdef Pseudo_AF_HDRCMPLT
-    Just Pseudo_AF_HDRCMPLT -> Just #const Pseudo_AF_HDRCMPLT
-#endif
-#ifdef AF_ENCAP
-    Just AF_ENCAP -> Just #const AF_ENCAP
-#endif
-#ifdef AF_LINK
-    Just AF_LINK -> Just #const AF_LINK
-#endif
-#ifdef AF_RAW
-    Just AF_RAW -> Just #const AF_RAW
-#endif
-#ifdef AF_RIF
-    Just AF_RIF -> Just #const AF_RIF
-#endif
-#ifdef AF_NETROM
-    Just AF_NETROM -> Just #const AF_NETROM
-#endif
-#ifdef AF_BRIDGE
-    Just AF_BRIDGE -> Just #const AF_BRIDGE
-#endif
-#ifdef AF_ATMPVC
-    Just AF_ATMPVC -> Just #const AF_ATMPVC
-#endif
-#ifdef AF_ROSE
-    Just AF_ROSE -> Just #const AF_ROSE
-#endif
-#ifdef AF_NETBEUI
-    Just AF_NETBEUI -> Just #const AF_NETBEUI
-#endif
-#ifdef AF_SECURITY
-    Just AF_SECURITY -> Just #const AF_SECURITY
-#endif
-#ifdef AF_PACKET
-    Just AF_PACKET -> Just #const AF_PACKET
-#endif
-#ifdef AF_ASH
-    Just AF_ASH -> Just #const AF_ASH
-#endif
-#ifdef AF_ECONET
-    Just AF_ECONET -> Just #const AF_ECONET
-#endif
-#ifdef AF_ATMSVC
-    Just AF_ATMSVC -> Just #const AF_ATMSVC
-#endif
-#ifdef AF_IRDA
-    Just AF_IRDA -> Just #const AF_IRDA
-#endif
-#ifdef AF_PPPOX
-    Just AF_PPPOX -> Just #const AF_PPPOX
-#endif
-#ifdef AF_WANPIPE
-    Just AF_WANPIPE -> Just #const AF_WANPIPE
-#endif
-#ifdef AF_BLUETOOTH
-    Just AF_BLUETOOTH -> Just #const AF_BLUETOOTH
-#endif
-#ifdef AF_CAN
-    Just AF_CAN -> Just #const AF_CAN
-#endif
-    _ -> Nothing
-
---------- ----------
-
-unpackFamily :: CInt -> Family
-unpackFamily f = case f of
-        (#const AF_UNSPEC) -> AF_UNSPEC
-#ifdef AF_UNIX
-        (#const AF_UNIX) -> AF_UNIX
-#endif
-#ifdef AF_INET
-        (#const AF_INET) -> AF_INET
-#endif
-#ifdef AF_INET6
-        (#const AF_INET6) -> AF_INET6
-#endif
-#ifdef AF_IMPLINK
-        (#const AF_IMPLINK) -> AF_IMPLINK
-#endif
-#ifdef AF_PUP
-        (#const AF_PUP) -> AF_PUP
-#endif
-#ifdef AF_CHAOS
-        (#const AF_CHAOS) -> AF_CHAOS
-#endif
-#ifdef AF_NS
-        (#const AF_NS) -> AF_NS
-#endif
-#ifdef AF_NBS
-        (#const AF_NBS) -> AF_NBS
-#endif
-#ifdef AF_ECMA
-        (#const AF_ECMA) -> AF_ECMA
-#endif
-#ifdef AF_DATAKIT
-        (#const AF_DATAKIT) -> AF_DATAKIT
-#endif
-#ifdef AF_CCITT
-        (#const AF_CCITT) -> AF_CCITT
-#endif
-#ifdef AF_SNA
-        (#const AF_SNA) -> AF_SNA
-#endif
-#ifdef AF_DECnet
-        (#const AF_DECnet) -> AF_DECnet
-#endif
-#ifdef AF_DLI
-        (#const AF_DLI) -> AF_DLI
-#endif
-#ifdef AF_LAT
-        (#const AF_LAT) -> AF_LAT
-#endif
-#ifdef AF_HYLINK
-        (#const AF_HYLINK) -> AF_HYLINK
-#endif
-#ifdef AF_APPLETALK
-        (#const AF_APPLETALK) -> AF_APPLETALK
-#endif
-#ifdef AF_ROUTE
-        (#const AF_ROUTE) -> AF_ROUTE
-#endif
-#ifdef AF_NETBIOS
-        (#const AF_NETBIOS) -> AF_NETBIOS
-#endif
-#ifdef AF_NIT
-        (#const AF_NIT) -> AF_NIT
-#endif
-#ifdef AF_802
-        (#const AF_802) -> AF_802
-#endif
-#ifdef AF_ISO
-        (#const AF_ISO) -> AF_ISO
-#endif
-#ifdef AF_OSI
-# if (!defined(AF_ISO)) || (defined(AF_ISO) && (AF_ISO != AF_OSI))
-        (#const AF_OSI) -> AF_OSI
-# endif
-#endif
-#ifdef AF_NETMAN
-        (#const AF_NETMAN) -> AF_NETMAN
-#endif
-#ifdef AF_X25
-        (#const AF_X25) -> AF_X25
-#endif
-#ifdef AF_AX25
-        (#const AF_AX25) -> AF_AX25
-#endif
-#ifdef AF_OSINET
-        (#const AF_OSINET) -> AF_OSINET
-#endif
-#ifdef AF_GOSSIP
-        (#const AF_GOSSIP) -> AF_GOSSIP
-#endif
-#if defined(AF_IPX) && (!defined(AF_NS) || AF_NS != AF_IPX)
-        (#const AF_IPX) -> AF_IPX
-#endif
-#ifdef Pseudo_AF_XTP
-        (#const Pseudo_AF_XTP) -> Pseudo_AF_XTP
-#endif
-#ifdef AF_CTF
-        (#const AF_CTF) -> AF_CTF
-#endif
-#ifdef AF_WAN
-        (#const AF_WAN) -> AF_WAN
-#endif
-#ifdef AF_SDL
-        (#const AF_SDL) -> AF_SDL
-#endif
-#ifdef AF_NETWARE
-        (#const AF_NETWARE) -> AF_NETWARE
-#endif
-#ifdef AF_NDD
-        (#const AF_NDD) -> AF_NDD
-#endif
-#ifdef AF_INTF
-        (#const AF_INTF) -> AF_INTF
-#endif
-#ifdef AF_COIP
-        (#const AF_COIP) -> AF_COIP
-#endif
-#ifdef AF_CNT
-        (#const AF_CNT) -> AF_CNT
-#endif
-#ifdef Pseudo_AF_RTIP
-        (#const Pseudo_AF_RTIP) -> Pseudo_AF_RTIP
-#endif
-#ifdef Pseudo_AF_PIP
-        (#const Pseudo_AF_PIP) -> Pseudo_AF_PIP
-#endif
-#ifdef AF_SIP
-        (#const AF_SIP) -> AF_SIP
-#endif
-#ifdef AF_ISDN
-        (#const AF_ISDN) -> AF_ISDN
-#endif
-#ifdef Pseudo_AF_KEY
-        (#const Pseudo_AF_KEY) -> Pseudo_AF_KEY
-#endif
-#ifdef AF_NATM
-        (#const AF_NATM) -> AF_NATM
-#endif
-#ifdef AF_ARP
-        (#const AF_ARP) -> AF_ARP
-#endif
-#ifdef Pseudo_AF_HDRCMPLT
-        (#const Pseudo_AF_HDRCMPLT) -> Pseudo_AF_HDRCMPLT
-#endif
-#ifdef AF_ENCAP
-        (#const AF_ENCAP) -> AF_ENCAP
-#endif
-#ifdef AF_LINK
-        (#const AF_LINK) -> AF_LINK
-#endif
-#ifdef AF_RAW
-        (#const AF_RAW) -> AF_RAW
-#endif
-#ifdef AF_RIF
-        (#const AF_RIF) -> AF_RIF
-#endif
-#ifdef AF_NETROM
-        (#const AF_NETROM) -> AF_NETROM
-#endif
-#ifdef AF_BRIDGE
-        (#const AF_BRIDGE) -> AF_BRIDGE
-#endif
-#ifdef AF_ATMPVC
-        (#const AF_ATMPVC) -> AF_ATMPVC
-#endif
-#ifdef AF_ROSE
-        (#const AF_ROSE) -> AF_ROSE
-#endif
-#ifdef AF_NETBEUI
-        (#const AF_NETBEUI) -> AF_NETBEUI
-#endif
-#ifdef AF_SECURITY
-        (#const AF_SECURITY) -> AF_SECURITY
-#endif
-#ifdef AF_PACKET
-        (#const AF_PACKET) -> AF_PACKET
-#endif
-#ifdef AF_ASH
-        (#const AF_ASH) -> AF_ASH
-#endif
-#ifdef AF_ECONET
-        (#const AF_ECONET) -> AF_ECONET
-#endif
-#ifdef AF_ATMSVC
-        (#const AF_ATMSVC) -> AF_ATMSVC
-#endif
-#ifdef AF_IRDA
-        (#const AF_IRDA) -> AF_IRDA
-#endif
-#ifdef AF_PPPOX
-        (#const AF_PPPOX) -> AF_PPPOX
-#endif
-#ifdef AF_WANPIPE
-        (#const AF_WANPIPE) -> AF_WANPIPE
-#endif
-#ifdef AF_BLUETOOTH
-        (#const AF_BLUETOOTH) -> AF_BLUETOOTH
-#endif
-#ifdef AF_CAN
-        (#const AF_CAN) -> AF_CAN
-#endif
-        unknown -> error $
-          "Network.Socket.Types.unpackFamily: unknown address family: " ++
-          show unknown
-
-------------------------------------------------------------------------
--- Port Numbers
-
--- | Use the @Num@ instance (i.e. use a literal) to create a
--- @PortNumber@ value with the correct network-byte-ordering. You
--- should not use the PortNum constructor. It will be removed in the
--- next release.
---
--- >>> 1 :: PortNumber
--- 1
--- >>> read "1" :: PortNumber
--- 1
-newtype PortNumber = PortNum Word16 deriving (Eq, Ord, Typeable)
--- newtyped to prevent accidental use of sane-looking
--- port numbers that haven't actually been converted to
--- network-byte-order first.
-
-{-# DEPRECATED PortNum "Do not use the PortNum constructor. Use the Num instance. PortNum will be removed in the next release." #-}
-
-instance Show PortNumber where
-  showsPrec p pn = showsPrec p (portNumberToInt pn)
-
-instance Read PortNumber where
-  readsPrec n = map (\(x,y) -> (intToPortNumber x, y)) . readsPrec n
-
-intToPortNumber :: Int -> PortNumber
-intToPortNumber v = PortNum (htons (fromIntegral v))
-
-portNumberToInt :: PortNumber -> Int
-portNumberToInt (PortNum po) = fromIntegral (ntohs po)
-
-foreign import CALLCONV unsafe "ntohs" ntohs :: Word16 -> Word16
-foreign import CALLCONV unsafe "htons" htons :: Word16 -> Word16
-foreign import CALLCONV unsafe "ntohl" ntohl :: Word32 -> Word32
-foreign import CALLCONV unsafe "htonl" htonl :: Word32 -> Word32
-
-instance Enum PortNumber where
-    toEnum   = intToPortNumber
-    fromEnum = portNumberToInt
-
-instance Num PortNumber where
-   fromInteger i = intToPortNumber (fromInteger i)
-    -- for completeness.
-   (+) x y   = intToPortNumber (portNumberToInt x + portNumberToInt y)
-   (-) x y   = intToPortNumber (portNumberToInt x - portNumberToInt y)
-   negate x  = intToPortNumber (-portNumberToInt x)
-   (*) x y   = intToPortNumber (portNumberToInt x * portNumberToInt y)
-   abs n     = intToPortNumber (abs (portNumberToInt n))
-   signum n  = intToPortNumber (signum (portNumberToInt n))
-
-instance Real PortNumber where
-    toRational x = toInteger x % 1
-
-instance Integral PortNumber where
-    quotRem a b = let (c,d) = quotRem (portNumberToInt a) (portNumberToInt b) in
-                  (intToPortNumber c, intToPortNumber d)
-    toInteger a = toInteger (portNumberToInt a)
-
-instance Storable PortNumber where
-   sizeOf    _ = sizeOf    (undefined :: Word16)
-   alignment _ = alignment (undefined :: Word16)
-   poke p (PortNum po) = poke (castPtr p) po
-   peek p = PortNum `liftM` peek (castPtr p)
-
-------------------------------------------------------------------------
--- Socket addresses
-
--- The scheme used for addressing sockets is somewhat quirky. The
--- calls in the BSD socket API that need to know the socket address
--- all operate in terms of struct sockaddr, a `virtual' type of
--- socket address.
-
--- The Internet family of sockets are addressed as struct sockaddr_in,
--- so when calling functions that operate on struct sockaddr, we have
--- to type cast the Internet socket address into a struct sockaddr.
--- Instances of the structure for different families might *not* be
--- the same size. Same casting is required of other families of
--- sockets such as Xerox NS. Similarly for Unix domain sockets.
-
--- To represent these socket addresses in Haskell-land, we do what BSD
--- didn't do, and use a union/algebraic type for the different
--- families. Currently only Unix domain sockets and the Internet
--- families are supported.
-
-#if defined(IPV6_SOCKET_SUPPORT)
-type FlowInfo = Word32
-type ScopeID = Word32
-#endif
-
--- | The existence of a constructor does not necessarily imply that
--- that socket address type is supported on your system: see
--- 'isSupportedSockAddr'.
-data SockAddr       -- C Names
-  = SockAddrInet
-    PortNumber  -- sin_port  (network byte order)
-    HostAddress -- sin_addr  (ditto)
-  | SockAddrInet6
-        PortNumber      -- sin6_port (network byte order)
-        FlowInfo        -- sin6_flowinfo (ditto)
-        HostAddress6    -- sin6_addr (ditto)
-        ScopeID         -- sin6_scope_id (ditto)
-  | SockAddrUnix
-        String          -- sun_path
-  | SockAddrCan
-        Int32           -- can_ifindex (can be get by Network.BSD.ifNameToIndex "can0")
-        -- TODO: Extend this to include transport protocol information
-  deriving (Eq, Ord, Typeable)
-
--- | Is the socket address type supported on this system?
-isSupportedSockAddr :: SockAddr -> Bool
-isSupportedSockAddr addr = case addr of
-  SockAddrInet {} -> True
-#if defined(IPV6_SOCKET_SUPPORT)
-  SockAddrInet6 {} -> True
-#endif
-#if defined(DOMAIN_SOCKET_SUPPORT)
-  SockAddrUnix{} -> True
-#endif
-#if defined(CAN_SOCKET_SUPPORT)
-  SockAddrCan{} -> True
-#endif
-#if !(defined(IPV6_SOCKET_SUPPORT) \
-      && defined(DOMAIN_SOCKET_SUPPORT) && defined(CAN_SOCKET_SUPPORT))
-  _ -> False
-#endif
-
-#if defined(WITH_WINSOCK)
-type CSaFamily = (#type unsigned short)
-#elif defined(darwin_HOST_OS)
-type CSaFamily = (#type u_char)
-#else
-type CSaFamily = (#type sa_family_t)
-#endif
-
--- | Computes the storage requirements (in bytes) of the given
--- 'SockAddr'.  This function differs from 'Foreign.Storable.sizeOf'
--- in that the value of the argument /is/ used.
-sizeOfSockAddr :: SockAddr -> Int
-#if defined(DOMAIN_SOCKET_SUPPORT)
-sizeOfSockAddr (SockAddrUnix path) =
-    case path of
-        '\0':_ -> (#const sizeof(sa_family_t)) + length path
-        _      -> #const sizeof(struct sockaddr_un)
-#endif
-sizeOfSockAddr (SockAddrInet _ _) = #const sizeof(struct sockaddr_in)
-#if defined(IPV6_SOCKET_SUPPORT)
-sizeOfSockAddr (SockAddrInet6 _ _ _ _) = #const sizeof(struct sockaddr_in6)
-#endif
-#if defined(CAN_SOCKET_SUPPORT)
-sizeOfSockAddr (SockAddrCan _) = #const sizeof(struct sockaddr_can)
-#endif
-
--- | Computes the storage requirements (in bytes) required for a
--- 'SockAddr' with the given 'Family'.
-sizeOfSockAddrByFamily :: Family -> Int
-#if defined(DOMAIN_SOCKET_SUPPORT)
-sizeOfSockAddrByFamily AF_UNIX  = #const sizeof(struct sockaddr_un)
-#endif
-#if defined(IPV6_SOCKET_SUPPORT)
-sizeOfSockAddrByFamily AF_INET6 = #const sizeof(struct sockaddr_in6)
-#endif
-sizeOfSockAddrByFamily AF_INET  = #const sizeof(struct sockaddr_in)
-#if defined(CAN_SOCKET_SUPPORT)
-sizeOfSockAddrByFamily AF_CAN   = #const sizeof(struct sockaddr_can)
-#endif
-sizeOfSockAddrByFamily family = error $
-    "Network.Socket.Types.sizeOfSockAddrByFamily: address family '" ++
-    show family ++ "' not supported."
-
--- | Use a 'SockAddr' with a function requiring a pointer to a
--- 'SockAddr' and the length of that 'SockAddr'.
-withSockAddr :: SockAddr -> (Ptr SockAddr -> Int -> IO a) -> IO a
-withSockAddr addr f = do
-    let sz = sizeOfSockAddr addr
-    allocaBytes sz $ \p -> pokeSockAddr p addr >> f (castPtr p) sz
-
--- | Create a new 'SockAddr' for use with a function requiring a
--- pointer to a 'SockAddr' and the length of that 'SockAddr'.
-withNewSockAddr :: Family -> (Ptr SockAddr -> Int -> IO a) -> IO a
-withNewSockAddr family f = do
-    let sz = sizeOfSockAddrByFamily family
-    allocaBytes sz $ \ptr -> f ptr sz
-
--- We can't write an instance of 'Storable' for 'SockAddr' because
--- @sockaddr@ is a sum type of variable size but
--- 'Foreign.Storable.sizeOf' is required to be constant.
-
--- Note that on Darwin, the sockaddr structure must be zeroed before
--- use.
-
--- | Write the given 'SockAddr' to the given memory location.
-pokeSockAddr :: Ptr a -> SockAddr -> IO ()
-#if defined(DOMAIN_SOCKET_SUPPORT)
-pokeSockAddr p (SockAddrUnix path) = do
-#if defined(darwin_HOST_OS)
-    zeroMemory p (#const sizeof(struct sockaddr_un))
-#else
-    case path of
-      ('\0':_) -> zeroMemory p (#const sizeof(struct sockaddr_un))
-      _        -> return ()
-#endif
-#if defined(HAVE_STRUCT_SOCKADDR_SA_LEN)
-    (#poke struct sockaddr_un, sun_len) p ((#const sizeof(struct sockaddr_un)) :: Word8)
-#endif
-    (#poke struct sockaddr_un, sun_family) p ((#const AF_UNIX) :: CSaFamily)
-    let pathC = map castCharToCChar path
-        poker = case path of ('\0':_) -> pokeArray; _ -> pokeArray0 0
-    poker ((#ptr struct sockaddr_un, sun_path) p) pathC
-#endif
-pokeSockAddr p (SockAddrInet (PortNum port) addr) = do
-#if defined(darwin_HOST_OS)
-    zeroMemory p (#const sizeof(struct sockaddr_in))
-#endif
-#if defined(HAVE_STRUCT_SOCKADDR_SA_LEN)
-    (#poke struct sockaddr_in, sin_len) p ((#const sizeof(struct sockaddr_in)) :: Word8)
-#endif
-    (#poke struct sockaddr_in, sin_family) p ((#const AF_INET) :: CSaFamily)
-    (#poke struct sockaddr_in, sin_port) p port
-    (#poke struct sockaddr_in, sin_addr) p addr
-#if defined(IPV6_SOCKET_SUPPORT)
-pokeSockAddr p (SockAddrInet6 (PortNum port) flow addr scope) = do
-#if defined(darwin_HOST_OS)
-    zeroMemory p (#const sizeof(struct sockaddr_in6))
-#endif
-#if defined(HAVE_STRUCT_SOCKADDR_SA_LEN)
-    (#poke struct sockaddr_in6, sin6_len) p ((#const sizeof(struct sockaddr_in6)) :: Word8)
-#endif
-    (#poke struct sockaddr_in6, sin6_family) p ((#const AF_INET6) :: CSaFamily)
-    (#poke struct sockaddr_in6, sin6_port) p port
-    (#poke struct sockaddr_in6, sin6_flowinfo) p flow
-    (#poke struct sockaddr_in6, sin6_addr) p (In6Addr addr)
-    (#poke struct sockaddr_in6, sin6_scope_id) p scope
-#endif
-#if defined(CAN_SOCKET_SUPPORT)
-pokeSockAddr p (SockAddrCan ifIndex) = do
-#if defined(darwin_HOST_OS)
-    zeroMemory p (#const sizeof(struct sockaddr_can))
-#endif
-    (#poke struct sockaddr_can, can_ifindex) p ifIndex
-#endif
-
--- | Read a 'SockAddr' from the given memory location.
-peekSockAddr :: Ptr SockAddr -> IO SockAddr
-peekSockAddr p = do
-  family <- (#peek struct sockaddr, sa_family) p
-  case family :: CSaFamily of
-#if defined(DOMAIN_SOCKET_SUPPORT)
-    (#const AF_UNIX) -> do
-        str <- peekCString ((#ptr struct sockaddr_un, sun_path) p)
-        return (SockAddrUnix str)
-#endif
-    (#const AF_INET) -> do
-        addr <- (#peek struct sockaddr_in, sin_addr) p
-        port <- (#peek struct sockaddr_in, sin_port) p
-        return (SockAddrInet (PortNum port) addr)
-#if defined(IPV6_SOCKET_SUPPORT)
-    (#const AF_INET6) -> do
-        port <- (#peek struct sockaddr_in6, sin6_port) p
-        flow <- (#peek struct sockaddr_in6, sin6_flowinfo) p
-        In6Addr addr <- (#peek struct sockaddr_in6, sin6_addr) p
-        scope <- (#peek struct sockaddr_in6, sin6_scope_id) p
-        return (SockAddrInet6 (PortNum port) flow addr scope)
-#endif
-#if defined(CAN_SOCKET_SUPPORT)
-    (#const AF_CAN) -> do
-        ifidx <- (#peek struct sockaddr_can, can_ifindex) p
-        return (SockAddrCan ifidx)
-#endif
-    _ -> ioError $ userError $
-      "Network.Socket.Types.peekSockAddr: address family '" ++
-      show family ++ "' not supported."
-
-------------------------------------------------------------------------
-
--- | The raw network byte order number is read using host byte order.
--- Therefore on little-endian architectures the byte order is swapped. For
--- example @127.0.0.1@ is represented as @0x0100007f@ on little-endian hosts
--- and as @0x7f000001@ on big-endian hosts.
---
--- For direct manipulation prefer 'hostAddressToTuple' and
--- 'tupleToHostAddress'.
-type HostAddress = Word32
-
--- | Converts 'HostAddress' to representation-independent IPv4 quadruple.
--- For example for @127.0.0.1@ the function will return @(0x7f, 0, 0, 1)@
--- regardless of host endianness.
-hostAddressToTuple :: HostAddress -> (Word8, Word8, Word8, Word8)
-hostAddressToTuple ha' =
-    let ha = htonl ha'
-        byte i = fromIntegral (ha `shiftR` i) :: Word8
-    in (byte 24, byte 16, byte 8, byte 0)
-
--- | Converts IPv4 quadruple to 'HostAddress'.
-tupleToHostAddress :: (Word8, Word8, Word8, Word8) -> HostAddress
-tupleToHostAddress (b3, b2, b1, b0) =
-    let x `sl` i = fromIntegral x `shiftL` i :: Word32
-    in ntohl $ (b3 `sl` 24) .|. (b2 `sl` 16) .|. (b1 `sl` 8) .|. (b0 `sl` 0)
-
-#if defined(IPV6_SOCKET_SUPPORT)
--- | Independent of endianness. For example @::1@ is stored as @(0, 0, 0, 1)@.
---
--- For direct manipulation prefer 'hostAddress6ToTuple' and
--- 'tupleToHostAddress6'.
-type HostAddress6 = (Word32, Word32, Word32, Word32)
-
-hostAddress6ToTuple :: HostAddress6 -> (Word16, Word16, Word16, Word16,
-                                        Word16, Word16, Word16, Word16)
-hostAddress6ToTuple (w3, w2, w1, w0) =
-    let high, low :: Word32 -> Word16
-        high w = fromIntegral (w `shiftR` 16)
-        low w = fromIntegral w
-    in (high w3, low w3, high w2, low w2, high w1, low w1, high w0, low w0)
-
-tupleToHostAddress6 :: (Word16, Word16, Word16, Word16,
-                        Word16, Word16, Word16, Word16) -> HostAddress6
-tupleToHostAddress6 (w7, w6, w5, w4, w3, w2, w1, w0) =
-    let add :: Word16 -> Word16 -> Word32
-        high `add` low = (fromIntegral high `shiftL` 16) .|. (fromIntegral low)
-    in (w7 `add` w6, w5 `add` w4, w3 `add` w2, w1 `add` w0)
-
--- The peek32 and poke32 functions work around the fact that the RFCs
--- don't require 32-bit-wide address fields to be present.  We can
--- only portably rely on an 8-bit field, s6_addr.
-
-s6_addr_offset :: Int
-s6_addr_offset = (#offset struct in6_addr, s6_addr)
-
-peek32 :: Ptr a -> Int -> IO Word32
-peek32 p i0 = do
-    let i' = i0 * 4
-        peekByte n = peekByteOff p (s6_addr_offset + i' + n) :: IO Word8
-        a `sl` i = fromIntegral a `shiftL` i
-    a0 <- peekByte 0
-    a1 <- peekByte 1
-    a2 <- peekByte 2
-    a3 <- peekByte 3
-    return ((a0 `sl` 24) .|. (a1 `sl` 16) .|. (a2 `sl` 8) .|. (a3 `sl` 0))
-
-poke32 :: Ptr a -> Int -> Word32 -> IO ()
-poke32 p i0 a = do
-    let i' = i0 * 4
-        pokeByte n = pokeByteOff p (s6_addr_offset + i' + n)
-        x `sr` i = fromIntegral (x `shiftR` i) :: Word8
-    pokeByte 0 (a `sr` 24)
-    pokeByte 1 (a `sr` 16)
-    pokeByte 2 (a `sr`  8)
-    pokeByte 3 (a `sr`  0)
-
--- | Private newtype proxy for the Storable instance. To avoid orphan instances.
-newtype In6Addr = In6Addr HostAddress6
-
-#if __GLASGOW_HASKELL__ < 800
-#let alignment t = "%lu", (unsigned long)offsetof(struct {char x__; t (y__); }, y__)
-#endif
-
-instance Storable In6Addr where
-    sizeOf _    = #const sizeof(struct in6_addr)
-    alignment _ = #alignment struct in6_addr
-
-    peek p = do
-        a <- peek32 p 0
-        b <- peek32 p 1
-        c <- peek32 p 2
-        d <- peek32 p 3
-        return $ In6Addr (a, b, c, d)
-
-    poke p (In6Addr (a, b, c, d)) = do
-        poke32 p 0 a
-        poke32 p 1 b
-        poke32 p 2 c
-        poke32 p 3 d
-#endif
-
-------------------------------------------------------------------------
--- Helper functions
-
-foreign import ccall unsafe "string.h" memset :: Ptr a -> CInt -> CSize -> IO ()
-
--- | Zero a structure.
-zeroMemory :: Ptr a -> CSize -> IO ()
-zeroMemory dest nbytes = memset dest 0 (fromIntegral nbytes)
diff --git a/include/HsNet.h b/include/HsNet.h
index 858ce4e..c172e11 100644
--- a/include/HsNet.h
+++ b/include/HsNet.h
@@ -7,182 +7,187 @@
 #ifndef HSNET_H
 #define HSNET_H
 
-#include "HsNetworkConfig.h"
-
-#ifdef NEED_WINVER
-# define WINVER 0x0501
-#endif
-
-/* ultra-evil... */
-#undef PACKAGE_BUGREPORT
-#undef PACKAGE_NAME
-#undef PACKAGE_STRING
-#undef PACKAGE_TARNAME
-#undef PACKAGE_VERSION
-
-#ifndef INLINE
-# if defined(_MSC_VER)
-#  define INLINE extern __inline
-# elif defined(__GNUC_GNU_INLINE__)
-#  define INLINE extern inline
-# else
-#  define INLINE inline
-# endif
-#endif
-
-#ifdef HAVE_GETADDRINFO
-# define IPV6_SOCKET_SUPPORT 1
-#else
-# undef IPV6_SOCKET_SUPPORT
-#endif
-
-#if defined(HAVE_WINSOCK2_H)
-#include <winsock2.h>
-# ifdef HAVE_WS2TCPIP_H
-#  include <ws2tcpip.h>
-// fix for MingW not defining IPV6_V6ONLY
-#  define IPV6_V6ONLY 27
-# endif
-
-extern int   initWinSock ();
-extern const char* getWSErrorDescr(int err);
-extern void* newAcceptParams(int sock,
-			     int sz,
-			     void* sockaddr);
-extern int   acceptNewSock(void* d);
-extern int   acceptDoProc(void* param);
-
-#else
-
-#ifdef HAVE_LIMITS_H
-# include <limits.h>
-#endif
-#ifdef HAVE_STDLIB_H
-# include <stdlib.h>
-#endif
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-#ifdef HAVE_SYS_TYPES_H
-# include <sys/types.h>
-#endif
-#ifdef HAVE_FCNTL_H
-# include <fcntl.h>
-#endif
-#ifdef HAVE_SYS_UIO_H
-# include <sys/uio.h>
-#endif
-#ifdef HAVE_SYS_SOCKET_H
-# include <sys/socket.h>
-#endif
-#ifdef HAVE_LINUX_TCP_H
-# include <linux/tcp.h>
-#elif HAVE_NETINET_TCP_H
-# include <netinet/tcp.h>
-#endif
-#ifdef HAVE_NETINET_IN_H
-# include <netinet/in.h>
-#endif
-#ifdef HAVE_SYS_UN_H
-# include <sys/un.h>
-#endif
-#ifdef HAVE_ARPA_INET_H
-# include <arpa/inet.h>
-#endif
-#ifdef HAVE_NETDB_H
-#include <netdb.h>
-#endif
-#ifdef HAVE_LINUX_CAN_H
-# include <linux/can.h>
-# define CAN_SOCKET_SUPPORT 1
-#endif
-#ifdef HAVE_NET_IF
-# include <net/if.h>
-#endif
-
-#ifdef HAVE_BSD_SENDFILE
-#include <sys/uio.h>
-#endif
-#ifdef HAVE_LINUX_SENDFILE
-#if !defined(__USE_FILE_OFFSET64)
-#include <sys/sendfile.h>
-#endif
-#endif
-
-extern int
-sendFd(int sock, int outfd);
-
-extern int
-recvFd(int sock);
-
-#endif /* HAVE_WINSOCK2_H */
-
-INLINE char *
-hsnet_inet_ntoa(
-#if defined(HAVE_WINSOCK2_H)
-             u_long addr
-#elif defined(HAVE_IN_ADDR_T)
-             in_addr_t addr
-#elif defined(HAVE_INTTYPES_H)
-             u_int32_t addr
-#else
-             unsigned long addr
-#endif
-	    )
-{
-    struct in_addr a;
-    a.s_addr = addr;
-    return inet_ntoa(a);
-}
-
-#ifdef HAVE_GETADDRINFO
-INLINE int
-hsnet_getnameinfo(const struct sockaddr* a,socklen_t b, char* c,
-# if defined(HAVE_WINSOCK2_H)
-                  DWORD d, char* e, DWORD f, int g)
-# else
-                  socklen_t d, char* e, socklen_t f, int g)
-# endif
-{
-  return getnameinfo(a,b,c,d,e,f,g);
-}
-
-INLINE int
-hsnet_getaddrinfo(const char *hostname, const char *servname,
-		  const struct addrinfo *hints, struct addrinfo **res)
-{
-    return getaddrinfo(hostname, servname, hints, res);
-}
-
-INLINE void
-hsnet_freeaddrinfo(struct addrinfo *ai)
-{
-    freeaddrinfo(ai);
-}
-#endif
-
-#if defined(HAVE_WINSOCK2_H)
-# define WITH_WINSOCK  1
-#endif
-
-#if !defined(mingw32_HOST_OS) && !defined(_WIN32)
-# define DOMAIN_SOCKET_SUPPORT 1
-#endif
-
-#if !defined(CALLCONV)
-# if defined(WITH_WINSOCK)
-#  define CALLCONV stdcall
-# else
-#  define CALLCONV ccall
-# endif
-#endif
-
-#if !defined(IOV_MAX)
-# define IOV_MAX 1024
-#endif
-
-#if !defined(SOCK_NONBLOCK) // Missing define in Bionic libc (Android)
-# define SOCK_NONBLOCK O_NONBLOCK
-#endif
+#define IPV6_SOCKET_SUPPORT 1
+#define SOCK_STREAM         1
+#define SOCK_DGRAM          1
+#define DEF_AF_INET         1
+#define DEF_AF_INET6        1
+#define CALLCONV            java
+
+/* #ifdef NEED_WINVER */
+/* # define WINVER 0x0501 */
+/* #endif */
+
+/* /\* ultra-evil... *\/ */
+/* #undef PACKAGE_BUGREPORT */
+/* #undef PACKAGE_NAME */
+/* #undef PACKAGE_STRING */
+/* #undef PACKAGE_TARNAME */
+/* #undef PACKAGE_VERSION */
+
+/* #ifndef INLINE */
+/* # if defined(_MSC_VER) */
+/* #  define INLINE extern __inline */
+/* # elif defined(__GNUC_GNU_INLINE__) */
+/* #  define INLINE extern inline */
+/* # else */
+/* #  define INLINE inline */
+/* # endif */
+/* #endif */
+
+/* #ifdef HAVE_GETADDRINFO */
+/* # define IPV6_SOCKET_SUPPORT 1 */
+/* #else */
+/* # undef IPV6_SOCKET_SUPPORT */
+/* #endif */
+
+/* #if defined(HAVE_WINSOCK2_H) */
+/* #include <winsock2.h> */
+/* # ifdef HAVE_WS2TCPIP_H */
+/* #  include <ws2tcpip.h> */
+/* // fix for MingW not defining IPV6_V6ONLY */
+/* #  define IPV6_V6ONLY 27 */
+/* # endif */
+
+/* extern int   initWinSock (); */
+/* extern const char* getWSErrorDescr(int err); */
+/* extern void* newAcceptParams(int sock, */
+/* 			     int sz, */
+/* 			     void* sockaddr); */
+/* extern int   acceptNewSock(void* d); */
+/* extern int   acceptDoProc(void* param); */
+
+/* #else */
+
+/* #ifdef HAVE_LIMITS_H */
+/* # include <limits.h> */
+/* #endif */
+/* #ifdef HAVE_STDLIB_H */
+/* # include <stdlib.h> */
+/* #endif */
+/* #ifdef HAVE_UNISTD_H */
+/* #include <unistd.h> */
+/* #endif */
+/* #ifdef HAVE_SYS_TYPES_H */
+/* # include <sys/types.h> */
+/* #endif */
+/* #ifdef HAVE_FCNTL_H */
+/* # include <fcntl.h> */
+/* #endif */
+/* #ifdef HAVE_SYS_UIO_H */
+/* # include <sys/uio.h> */
+/* #endif */
+/* #ifdef HAVE_SYS_SOCKET_H */
+/* # include <sys/socket.h> */
+/* #endif */
+/* #ifdef HAVE_LINUX_TCP_H */
+/* # include <linux/tcp.h> */
+/* #elif HAVE_NETINET_TCP_H */
+/* # include <netinet/tcp.h> */
+/* #endif */
+/* #ifdef HAVE_NETINET_IN_H */
+/* # include <netinet/in.h> */
+/* #endif */
+/* #ifdef HAVE_SYS_UN_H */
+/* # include <sys/un.h> */
+/* #endif */
+/* #ifdef HAVE_ARPA_INET_H */
+/* # include <arpa/inet.h> */
+/* #endif */
+/* #ifdef HAVE_NETDB_H */
+/* #include <netdb.h> */
+/* #endif */
+/* #ifdef HAVE_LINUX_CAN_H */
+/* # include <linux/can.h> */
+/* # define CAN_SOCKET_SUPPORT 1 */
+/* #endif */
+/* #ifdef HAVE_NET_IF */
+/* # include <net/if.h> */
+/* #endif */
+
+/* #ifdef HAVE_BSD_SENDFILE */
+/* #include <sys/uio.h> */
+/* #endif */
+/* #ifdef HAVE_LINUX_SENDFILE */
+/* #if !defined(__USE_FILE_OFFSET64) */
+/* #include <sys/sendfile.h> */
+/* #endif */
+/* #endif */
+
+/* extern int */
+/* sendFd(int sock, int outfd); */
+
+/* extern int */
+/* recvFd(int sock); */
+
+/* #endif /\* HAVE_WINSOCK2_H *\/ */
+
+/* INLINE char * */
+/* hsnet_inet_ntoa( */
+/* #if defined(HAVE_WINSOCK2_H) */
+/*              u_long addr */
+/* #elif defined(HAVE_IN_ADDR_T) */
+/*              in_addr_t addr */
+/* #elif defined(HAVE_INTTYPES_H) */
+/*              u_int32_t addr */
+/* #else */
+/*              unsigned long addr */
+/* #endif */
+/* 	    ) */
+/* { */
+/*     struct in_addr a; */
+/*     a.s_addr = addr; */
+/*     return inet_ntoa(a); */
+/* } */
+
+/* #ifdef HAVE_GETADDRINFO */
+/* INLINE int */
+/* hsnet_getnameinfo(const struct sockaddr* a,socklen_t b, char* c, */
+/* # if defined(HAVE_WINSOCK2_H) */
+/*                   DWORD d, char* e, DWORD f, int g) */
+/* # else */
+/*                   socklen_t d, char* e, socklen_t f, int g) */
+/* # endif */
+/* { */
+/*   return getnameinfo(a,b,c,d,e,f,g); */
+/* } */
+
+/* INLINE int */
+/* hsnet_getaddrinfo(const char *hostname, const char *servname, */
+/* 		  const struct addrinfo *hints, struct addrinfo **res) */
+/* { */
+/*     return getaddrinfo(hostname, servname, hints, res); */
+/* } */
+
+/* INLINE void */
+/* hsnet_freeaddrinfo(struct addrinfo *ai) */
+/* { */
+/*     freeaddrinfo(ai); */
+/* } */
+/* #endif */
+
+/* #if defined(HAVE_WINSOCK2_H) */
+/* # define WITH_WINSOCK  1 */
+/* #endif */
+
+/* #if !defined(mingw32_HOST_OS) && !defined(_WIN32) */
+/* # define DOMAIN_SOCKET_SUPPORT 1 */
+/* #endif */
+
+/* #if !defined(CALLCONV) */
+/* # if defined(WITH_WINSOCK) */
+/* #  define CALLCONV stdcall */
+/* # else */
+/* #  define CALLCONV ccall */
+/* # endif */
+/* #endif */
+
+/* #if !defined(IOV_MAX) */
+/* # define IOV_MAX 1024 */
+/* #endif */
+
+/* #if !defined(SOCK_NONBLOCK) // Missing define in Bionic libc (Android) */
+/* # define SOCK_NONBLOCK O_NONBLOCK */
+/* #endif */
 
 #endif /* HSNET_H */
diff --git a/include/HsNetworkConfig.h b/include/HsNetworkConfig.h
deleted file mode 100644
index 6dcef8f..0000000
--- a/include/HsNetworkConfig.h
+++ /dev/null
@@ -1,178 +0,0 @@
-/* include/HsNetworkConfig.h.  Generated from HsNetworkConfig.h.in by configure.  */
-/* include/HsNetworkConfig.h.in.  Generated from configure.ac by autoheader.  */
-
-/* Define to 1 if you have the `accept4' function. */
-#define HAVE_ACCEPT4 1
-
-/* Define to 1 if you have the <arpa/inet.h> header file. */
-#define HAVE_ARPA_INET_H 1
-
-/* Define to 1 if you have a BSDish sendfile(2) implementation. */
-/* #undef HAVE_BSD_SENDFILE */
-
-/* Define to 1 if you have the declaration of `AI_ADDRCONFIG', and to 0 if you
-   don't. */
-#define HAVE_DECL_AI_ADDRCONFIG 1
-
-/* Define to 1 if you have the declaration of `AI_ALL', and to 0 if you don't.
-   */
-#define HAVE_DECL_AI_ALL 1
-
-/* Define to 1 if you have the declaration of `AI_NUMERICSERV', and to 0 if
-   you don't. */
-#define HAVE_DECL_AI_NUMERICSERV 1
-
-/* Define to 1 if you have the declaration of `AI_V4MAPPED', and to 0 if you
-   don't. */
-#define HAVE_DECL_AI_V4MAPPED 1
-
-/* Define to 1 if you have the declaration of `IPPROTO_IP', and to 0 if you
-   don't. */
-#define HAVE_DECL_IPPROTO_IP 1
-
-/* Define to 1 if you have the declaration of `IPPROTO_IPV6', and to 0 if you
-   don't. */
-#define HAVE_DECL_IPPROTO_IPV6 1
-
-/* Define to 1 if you have the declaration of `IPPROTO_TCP', and to 0 if you
-   don't. */
-#define HAVE_DECL_IPPROTO_TCP 1
-
-/* Define to 1 if you have the declaration of `IPV6_V6ONLY', and to 0 if you
-   don't. */
-#define HAVE_DECL_IPV6_V6ONLY 1
-
-/* Define to 1 if you have the <fcntl.h> header file. */
-#define HAVE_FCNTL_H 1
-
-/* Define to 1 if you have the `gai_strerror' function. */
-#define HAVE_GAI_STRERROR 1
-
-/* Define to 1 if you have the `getaddrinfo' function. */
-#define HAVE_GETADDRINFO 1
-
-/* Define to 1 if you have the `gethostent' function. */
-#define HAVE_GETHOSTENT 1
-
-/* Define to 1 if you have getpeereid. */
-/* #undef HAVE_GETPEEREID */
-
-/* Define to 1 if you have the `if_nametoindex' function. */
-#define HAVE_IF_NAMETOINDEX 1
-
-/* Define to 1 if you have the <inttypes.h> header file. */
-#define HAVE_INTTYPES_H 1
-
-/* Define to 1 if in_addr_t is available. */
-#define HAVE_IN_ADDR_T 1
-
-/* Define to 1 if you have the `ws2_32' library (-lws2_32). */
-/* #undef HAVE_LIBWS2_32 */
-
-/* Define to 1 if you have the <limits.h> header file. */
-#define HAVE_LIMITS_H 1
-
-/* Define to 1 if you have the <linux/can.h> header file. */
-#define HAVE_LINUX_CAN_H 1
-
-/* Define to 1 if you have a Linux sendfile(2) implementation. */
-#define HAVE_LINUX_SENDFILE 1
-
-/* Define to 1 if you have the <linux/tcp.h> header file. */
-#define HAVE_LINUX_TCP_H 1
-
-/* Define to 1 if you have the <memory.h> header file. */
-#define HAVE_MEMORY_H 1
-
-/* Define to 1 if you have the <netdb.h> header file. */
-#define HAVE_NETDB_H 1
-
-/* Define to 1 if you have the <netinet/in.h> header file. */
-#define HAVE_NETINET_IN_H 1
-
-/* Define to 1 if you have the <netinet/tcp.h> header file. */
-#define HAVE_NETINET_TCP_H 1
-
-/* Define to 1 if you have the <net/if.h> header file. */
-#define HAVE_NET_IF_H 1
-
-/* Define to 1 if you have the `readlink' function. */
-#define HAVE_READLINK 1
-
-/* Define to 1 if you have the <stdint.h> header file. */
-#define HAVE_STDINT_H 1
-
-/* Define to 1 if you have the <stdlib.h> header file. */
-#define HAVE_STDLIB_H 1
-
-/* Define to 1 if you have the <strings.h> header file. */
-#define HAVE_STRINGS_H 1
-
-/* Define to 1 if you have the <string.h> header file. */
-#define HAVE_STRING_H 1
-
-/* Define to 1 if `msg_accrights' is a member of `struct msghdr'. */
-/* #undef HAVE_STRUCT_MSGHDR_MSG_ACCRIGHTS */
-
-/* Define to 1 if `msg_control' is a member of `struct msghdr'. */
-#define HAVE_STRUCT_MSGHDR_MSG_CONTROL 1
-
-/* Define to 1 if `sa_len' is a member of `struct sockaddr'. */
-/* #undef HAVE_STRUCT_SOCKADDR_SA_LEN */
-
-/* Define to 1 if you have both SO_PEERCRED and struct ucred. */
-#define HAVE_STRUCT_UCRED 1
-
-/* Define to 1 if you have the `symlink' function. */
-#define HAVE_SYMLINK 1
-
-/* Define to 1 if you have the <sys/socket.h> header file. */
-#define HAVE_SYS_SOCKET_H 1
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#define HAVE_SYS_STAT_H 1
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#define HAVE_SYS_TYPES_H 1
-
-/* Define to 1 if you have the <sys/uio.h> header file. */
-#define HAVE_SYS_UIO_H 1
-
-/* Define to 1 if you have the <sys/un.h> header file. */
-#define HAVE_SYS_UN_H 1
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#define HAVE_UNISTD_H 1
-
-/* Define to 1 if you have the <winsock2.h> header file. */
-/* #undef HAVE_WINSOCK2_H */
-
-/* Define to 1 if you have the <ws2tcpip.h> header file. */
-/* #undef HAVE_WS2TCPIP_H */
-
-/* Define to 1 if the `getaddrinfo' function needs WINVER set. */
-/* #undef NEED_WINVER_XP */
-
-/* Define to the address where bug reports for this package should be sent. */
-#define PACKAGE_BUGREPORT "libraries@haskell.org"
-
-/* Define to the full name of this package. */
-#define PACKAGE_NAME "Haskell network package"
-
-/* Define to the full name and version of this package. */
-#define PACKAGE_STRING "Haskell network package 2.6.3.1"
-
-/* Define to the one symbol short name of this package. */
-#define PACKAGE_TARNAME "network"
-
-/* Define to the home page for this package. */
-#define PACKAGE_URL ""
-
-/* Define to the version of this package. */
-#define PACKAGE_VERSION "2.6.3.1"
-
-/* Define to 1 if you have the ANSI C header files. */
-#define STDC_HEADERS 1
-
-/* Define to empty if `const' does not conform to ANSI C. */
-/* #undef const */
diff --git a/java/Utils.java b/java/Utils.java
new file mode 100644
index 0000000..72e2e06
--- /dev/null
+++ b/java/Utils.java
@@ -0,0 +1,181 @@
+package eta.network;
+
+import java.io.IOException;
+
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Inet6Address;
+import java.net.SocketAddress;
+import java.net.SocketOption;
+import java.net.StandardSocketOptions;
+import java.net.UnknownHostException;
+import java.net.ProtocolFamily;
+import java.net.StandardProtocolFamily;
+
+import java.nio.ByteBuffer;
+import java.nio.channels.Channel;
+import java.nio.channels.DatagramChannel;
+import java.nio.channels.NetworkChannel;
+import java.nio.channels.ServerSocketChannel;
+import java.nio.channels.SelectableChannel;
+import java.nio.channels.SocketChannel;
+
+import eta.runtime.io.MemoryManager;
+
+public class Utils {
+    public static boolean isIPv6(InetAddress address) {
+        return (address instanceof Inet6Address);
+    }
+    public static byte[] fromWord32(int word32) {
+        return new byte[]{
+            (byte)(word32 >>> 24),
+            (byte)(word32 >>> 16),
+            (byte)(word32 >>> 8),
+            (byte)word32
+        };
+    }
+    public static String inet_ntoa(int bytes) throws UnknownHostException {
+        return InetAddress.getByAddress(fromWord32(bytes)).toString().substring(1);
+    }
+
+    public static String inet6_ntoa(int[] addr) {
+        String res="";
+        if (addr !=null) {
+            for (int i=0; i < addr.length; i++) {
+                res+=Integer.toHexString(addr[i]) +
+                    (i < addr.length-1?":":"");
+            }
+        }
+        return res;
+    }
+
+    public static int inetAddrInt(InetAddress address) {
+        int bOut = 0;
+        for (byte b: address.getAddress()) {
+            bOut = (((int) b) & 0xFF) | (bOut << 8);
+        }
+        return bOut;
+    }
+
+    public static String getNameInfo(byte[] address) throws UnknownHostException{
+        return InetAddress.getByAddress(address).getHostName();
+    }
+
+    public static int inet_addr(String address) {
+        try {
+            return inetAddrInt(InetAddress.getByName(address));
+        } catch (UnknownHostException e) {
+            return -1;
+        }
+    }
+
+    public static boolean isBlocking(Channel c) {
+        if (c instanceof SelectableChannel) {
+            SelectableChannel sc = (SelectableChannel) c;
+            return sc.isBlocking();
+        } else {
+            return true;
+        }
+    }
+
+    public static Channel socket(int family, int socketType, int protocol) throws IOException {
+        switch (socketType) {
+          case 1:
+              return SocketChannel.open();
+          case 2:
+              if (family != 0) {
+                  ProtocolFamily pf = (family == 1)?
+                      StandardProtocolFamily.INET : StandardProtocolFamily.INET6;
+                  return DatagramChannel.open(pf);
+              } else {
+                  return DatagramChannel.open();
+              }
+          case 3:
+              return ServerSocketChannel.open();
+        }
+        return null;
+    }
+
+    public static int bind(Channel c, SocketAddress address) throws IOException {
+        if ((c instanceof NetworkChannel) && !(c instanceof ServerSocketChannel)) {
+            ((NetworkChannel) c).bind(address);
+        }
+        return 0;
+    }
+
+    public static boolean connect(Channel c, SocketAddress address) throws IOException {
+        if (c instanceof SocketChannel) {
+            return ((SocketChannel) c).connect(address);
+        }
+        return false;
+    }
+
+    public static int listen(Channel c, SocketAddress saddr, int backlog) throws IOException {
+        if (c instanceof ServerSocketChannel) {
+            ((ServerSocketChannel) c).bind(saddr, backlog);
+        }
+        return 0;
+    }
+
+    public static Channel accept(Channel c) throws IOException {
+        if (c instanceof ServerSocketChannel) {
+            return ((ServerSocketChannel) c).accept();
+        } else {
+            return null;
+        }
+    }
+
+    public static int shutdown(Channel c, int shutdownCode) throws IOException {
+        if (c instanceof SocketChannel) {
+            SocketChannel sc = (SocketChannel) c;
+            switch (shutdownCode) {
+                case 0:
+                    sc.shutdownInput();
+                    break;
+                case 1:
+                    sc.shutdownOutput();
+                    break;
+                case 2:
+                    sc.shutdownInput();
+                    sc.shutdownOutput();
+                    break;
+            }
+        }
+        return 0;
+    }
+
+    public static int sendto(Channel c, long ptr, int size, SocketAddress addr) throws IOException {
+        ByteBuffer src = MemoryManager.getBoundedBuffer(ptr);
+        src.limit(src.position() + size);
+        return ((DatagramChannel) c).send(src, addr);
+    }
+
+    public static int getsockopt(Channel c, SocketOption<Integer> option) throws IOException {
+        return ((NetworkChannel) c).getOption(option);
+    }
+
+    @SuppressWarnings("unchecked")
+    public static void setsockopt(Channel c, SocketOption option, int value) throws IOException {
+        if (option == StandardSocketOptions.SO_REUSEADDR
+            || option == StandardSocketOptions.SO_KEEPALIVE
+            || option == StandardSocketOptions.IP_MULTICAST_LOOP
+            || option == StandardSocketOptions.SO_BROADCAST
+            || option == StandardSocketOptions.TCP_NODELAY) {
+            ((NetworkChannel) c).setOption(option, Boolean.valueOf(value == 1));
+        } else {
+            ((NetworkChannel) c).setOption(option, Integer.valueOf(value));
+        }
+    }
+
+    public static String getHostByAddr(int hostAddr) throws UnknownHostException {
+        return InetAddress.getByAddress(fromWord32(hostAddr)).getHostName();
+    }
+
+    public static InetAddress[] getHostsByAddr(int hostAddr) throws UnknownHostException {
+        return InetAddress.getAllByName(InetAddress.getByAddress(fromWord32(hostAddr)).getHostName());
+    }
+
+    public static InetSocketAddress getSockAddr(Channel c) throws IOException {
+        return (InetSocketAddress) ((SocketChannel) c).getRemoteAddress();
+    }
+}
diff --git a/network.cabal b/network.cabal
index ede8fd2..0350a44 100644
--- a/network.cabal
+++ b/network.cabal
@@ -26,7 +26,7 @@ description:
   That is, get the module from either network < 2.6 or from
   network-uri >= 2.6.
 category:       Network
-build-type:     Configure
+build-type:     Simple
 cabal-version:  >=1.8
 extra-tmp-files:
   config.log config.status autom4te.cache network.buildinfo
@@ -53,32 +53,24 @@ library
     Network.Socket.Internal
   other-modules:
     Network.Socket.ByteString.Internal
+    Network.Socket.ByteString.Lazy.Windows
     Network.Socket.Types
 
-  if !os(windows)
-    other-modules:
-      Network.Socket.ByteString.IOVec
-      Network.Socket.ByteString.Lazy.Posix
-      Network.Socket.ByteString.MsgHdr
-  if os(windows)
-    other-modules:
-      Network.Socket.ByteString.Lazy.Windows
-
   build-depends:
     base >= 3 && < 5,
     bytestring < 0.11
 
-  if !os(windows)
-    build-depends:
-      unix >= 2
-
   extensions:
-    CPP, DeriveDataTypeable, ForeignFunctionInterface, TypeSynonymInstances
+    CPP, DeriveDataTypeable, ForeignFunctionInterface, TypeSynonymInstances,
+    MagicHash, TypeOperators, DataKinds, TypeFamilies, MultiParamTypeClasses
+
   include-dirs: include
   includes: HsNet.h
-  install-includes: HsNet.h HsNetworkConfig.h
-  c-sources: cbits/HsNet.c
+  if impl(eta >= 0.0.9.2)
+    java-sources: java/Utils.java
   ghc-options: -Wall -fwarn-tabs
+  if impl(eta < 0.7.1.3)
+     ghc-options: -optP--text
 
 test-suite simple
   hs-source-dirs: tests
-- 
2.7.4 (Apple Git-66)

