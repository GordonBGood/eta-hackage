From 4efbc65e827eec619a66c57e4829683ca96ce295 Mon Sep 17 00:00:00 2001
From: Rahul Muttineni <rahulmutt@gmail.com>
Date: Sat, 9 Dec 2017 13:26:34 +0530
Subject: [PATCH] Patched

---
 Foundation/Foreign/MemoryMap/Posix.hs   | 250 +++++++++++++++++++++++++++++++
 Foundation/Foreign/MemoryMap/Posix.hsc  | 251 --------------------------------
 Foundation/Network/HostName.hs          | 169 +++++++++++++++++++++
 Foundation/Network/HostName.hsc         | 169 ---------------------
 Foundation/Random/ChaChaDRG.hs          |  17 ++-
 Foundation/System/Bindings/Hs.hs        |   4 +-
 Foundation/System/Bindings/Linux.hs     | 108 ++++++++++++++
 Foundation/System/Bindings/Linux.hsc    | 108 --------------
 Foundation/System/Bindings/Macos.hs     |  33 +++++
 Foundation/System/Bindings/Macos.hsc    |  40 -----
 Foundation/System/Bindings/Network.hs   |  39 +++++
 Foundation/System/Bindings/Network.hsc  |  46 ------
 Foundation/System/Bindings/Posix.hsc    |  96 ++++++------
 Foundation/System/Bindings/PosixDef.hs  |  25 ++++
 Foundation/System/Bindings/PosixDef.hsc |  25 ----
 Foundation/System/Bindings/Time.hs      | 122 ++++++++++++++++
 Foundation/System/Bindings/Time.hsc     | 126 ----------------
 Foundation/System/Entropy/Unix.hs       |   4 +-
 Foundation/System/Entropy/Windows.hs    |  12 +-
 Foundation/Timing.hs                    |  13 +-
 foundation.cabal                        |   1 +
 21 files changed, 821 insertions(+), 837 deletions(-)
 create mode 100644 Foundation/Foreign/MemoryMap/Posix.hs
 delete mode 100644 Foundation/Foreign/MemoryMap/Posix.hsc
 create mode 100644 Foundation/Network/HostName.hs
 delete mode 100644 Foundation/Network/HostName.hsc
 create mode 100644 Foundation/System/Bindings/Linux.hs
 delete mode 100644 Foundation/System/Bindings/Linux.hsc
 create mode 100644 Foundation/System/Bindings/Macos.hs
 delete mode 100644 Foundation/System/Bindings/Macos.hsc
 create mode 100644 Foundation/System/Bindings/Network.hs
 delete mode 100644 Foundation/System/Bindings/Network.hsc
 create mode 100644 Foundation/System/Bindings/PosixDef.hs
 delete mode 100644 Foundation/System/Bindings/PosixDef.hsc
 create mode 100644 Foundation/System/Bindings/Time.hs
 delete mode 100644 Foundation/System/Bindings/Time.hsc

diff --git a/Foundation/Foreign/MemoryMap/Posix.hs b/Foundation/Foreign/MemoryMap/Posix.hs
new file mode 100644
index 0000000..1114571
--- /dev/null
+++ b/Foundation/Foreign/MemoryMap/Posix.hs
@@ -0,0 +1,250 @@
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Foundation.Foreign.MemoryMap.Posix
+-- Copyright   :  (c) Vincent Hanquez 2014
+-- License     :  BSD-style
+--
+-- Maintainer  :  Vincent Hanquez
+-- Stability   :  provisional
+-- Portability :  non-portable (requires POSIX)
+--
+-- Functions defined by the POSIX standards for manipulating memory maps
+--
+-- When a function that calls an underlying POSIX function fails, the errno
+-- code is converted to an 'IOError' using 'Foreign.C.Error.errnoToIOError'.
+-- For a list of which errno codes may be generated, consult the POSIX
+-- documentation for the underlying function.
+--
+-----------------------------------------------------------------------------
+
+{-# LANGUAGE ForeignFunctionInterface #-}
+{-# LANGUAGE CPP #-}
+module Foundation.Foreign.MemoryMap.Posix
+    ( memoryMap
+    , memoryUnmap
+    , memoryAdvise
+    , memoryLock
+    , memoryUnlock
+    , memoryProtect
+    , memorySync
+    -- * Flags types
+    , MemoryMapFlag(..)
+    , MemoryProtection(..)
+    , MemoryAdvice(..)
+    , MemorySyncFlag(..)
+    -- * system page size
+    , sysconfPageSize
+    -- * High level
+    , fileMapRead
+    ) where
+
+import Basement.Compat.Base
+import Basement.Types.OffsetSize
+import System.Posix.Types
+import Foreign.Ptr
+import Foreign.C.Types
+import Foreign.C.Error
+import Data.Bits
+
+import Foundation.Collection.Foldable
+import Foundation.VFS
+import qualified Prelude (fromIntegral)
+import Foundation.Foreign.MemoryMap.Types
+import Control.Exception
+
+import           GHC.IO.FD
+import           GHC.IO.IOMode
+import qualified GHC.IO.Device as IO
+
+c_mmap :: Ptr a -> CSize -> CInt -> CInt -> CInt -> COff -> IO (Ptr a)
+c_mmap = error "c_mmap: Not implemented yet."
+
+c_munmap :: Ptr a -> CSize -> IO CInt
+c_munmap = error "c_munmap: Not implemented yet."
+
+#if defined(POSIX_MADV_NORMAL)
+c_madvise :: Ptr a -> CSize -> CInt -> IO CInt
+c_madvise = error "c_madvise: Not implemented yet."
+#else
+c_madvise :: Ptr a -> CSize -> CInt -> IO CInt
+c_madvise = error "c_madvise: Not implemented yet."
+#endif
+
+c_msync :: Ptr a -> CSize -> CInt -> IO CInt
+c_msync = error "c_msync: Not implemented yet."
+
+c_mprotect :: Ptr a -> CSize -> CInt -> IO CInt
+c_mprotect = error "c_mprotect: Not implemented yet."
+
+#ifndef __HAIKU__
+c_mlock :: Ptr a -> CSize -> IO CInt
+c_mlock = error "c_mlock: Not implemented yet."
+#else
+c_mlock :: Ptr a -> CSize -> IO CInt
+c_mlock _ _ = return (-1)
+#endif
+
+#ifndef __HAIKU__
+c_munlock :: Ptr a -> CSize -> IO CInt
+c_munlock = error "c_munlock: Not implemented yet."
+#else
+c_munlock :: Ptr a -> CSize -> IO CInt
+c_munlock _ _ = return (-1)
+#endif
+
+c_sysconf :: CInt -> CLong
+c_sysconf = error "c_sysconf: Not implemented yet."
+
+-- | Mapping flag
+data MemoryMapFlag =
+      MemoryMapShared  -- ^ memory changes are shared between process
+    | MemoryMapPrivate -- ^ memory changes are private to process
+    deriving (Show,Eq)
+
+-- | Memory protection
+data MemoryProtection =
+      MemoryProtectionNone
+    | MemoryProtectionRead
+    | MemoryProtectionWrite
+    | MemoryProtectionExecute
+    deriving (Show,Eq)
+
+-- | Advice to put on memory.
+--
+-- only define the posix one.
+data MemoryAdvice =
+      MemoryAdviceNormal     -- ^ no specific advice, the default.
+    | MemoryAdviceRandom     -- ^ Expect page references in random order. No readahead should occur.
+    | MemoryAdviceSequential -- ^ Expect page references in sequential order. Page should be readahead aggressively.
+    | MemoryAdviceWillNeed   -- ^ Expect access in the near future. Probably a good idea to readahead early
+    | MemoryAdviceDontNeed   -- ^ Do not expect access in the near future.
+    deriving (Show,Eq)
+
+-- | Memory synchronization flags
+data MemorySyncFlag =
+      MemorySyncAsync      -- ^ perform asynchronous write.
+    | MemorySyncSync       -- ^ perform synchronous write.
+    | MemorySyncInvalidate -- ^ invalidate cache data.
+    deriving (Show,Eq)
+
+cvalueOfMemoryProts :: [MemoryProtection] -> CInt
+cvalueOfMemoryProts = foldl' (.|.) 0 . fmap toProt
+  where toProt :: MemoryProtection -> CInt
+        toProt MemoryProtectionNone    = error "toProt: Not implemented yet."
+        toProt MemoryProtectionRead    = error "toProt: Not implemented yet."
+        toProt MemoryProtectionWrite   = error "toProt: Not implemented yet."
+        toProt MemoryProtectionExecute = error "toProt: Not implemented yet."
+
+cvalueOfMemorySync :: [MemorySyncFlag] -> CInt
+cvalueOfMemorySync = foldl' (.|.) 0 . fmap toSync
+  where toSync MemorySyncAsync      = error "toSync: Not implemented yet."
+        toSync MemorySyncSync       = error "toSync: Not implemented yet."
+        toSync MemorySyncInvalidate = error "toSync: Not implemented yet."
+
+-- | Map pages of memory.
+--
+-- If fd is present, this memory will represent the file associated.
+-- Otherwise, the memory will be an anonymous mapping.
+--
+-- use 'mmap'
+memoryMap :: Maybe (Ptr a)      -- ^ The address to map to if MapFixed is used.
+          -> CSize              -- ^ The length of the mapping
+          -> [MemoryProtection] -- ^ the memory protection associated with the mapping
+          -> MemoryMapFlag      -- ^
+          -> Maybe Fd
+          -> COff
+          -> IO (Ptr a)
+memoryMap initPtr sz prots flag mfd off =
+  undefined
+    -- throwErrnoIf (== m1ptr) "mmap" (c_mmap (maybe nullPtr id initPtr) sz cprot cflags fd off)
+  -- where m1ptr  = nullPtr `plusPtr` (-1)
+  --       fd     = maybe (-1) (\(Fd v) -> v) mfd
+  --       cprot  = cvalueOfMemoryProts prots
+  --       cflags = maybe cMapAnon (const 0) mfd
+  --            .|. maybe 0 (const cMapFixed) initPtr
+  --            .|. toMapFlag flag
+
+-- #ifdef __APPLE__
+--         cMapAnon  = error "cMapAnon: Not implemented yet."
+-- #else
+--         cMapAnon  = error "cMapAnon: Not implemented yet."
+-- #endif
+--         cMapFixed = error "cMapFixed: Not implemented yet."
+
+--         toMapFlag MemoryMapShared  = error "toMapFlag: Not implemented yet."
+--         toMapFlag MemoryMapPrivate = error "toMapFlag: Not implemented yet."
+
+-- | Unmap pages of memory
+--
+-- use 'munmap'
+memoryUnmap :: Ptr a -> CSize -> IO ()
+memoryUnmap ptr sz = throwErrnoIfMinus1_ "munmap" (c_munmap ptr sz)
+
+-- | give advice to the operating system about use of memory
+--
+-- call 'madvise'
+memoryAdvise :: Ptr a -> CSize -> MemoryAdvice -> IO ()
+memoryAdvise ptr sz adv = throwErrnoIfMinus1_ "madvise" (c_madvise ptr sz cadv)
+  where cadv = toAdvice adv
+#if defined(POSIX_MADV_NORMAL)
+        toAdvice MemoryAdviceNormal = error "toAdvice: Not implemented yet."
+        toAdvice MemoryAdviceRandom = error "toAdvice: Not implemented yet."
+        toAdvice MemoryAdviceSequential = error "toAdvice: Not implemented yet."
+        toAdvice MemoryAdviceWillNeed = error "toAdvice: Not implemented yet."
+        toAdvice MemoryAdviceDontNeed = error "toAdvice: Not implemented yet."
+#else
+        toAdvice MemoryAdviceNormal = error "toAdvice: Not implemented yet."
+        toAdvice MemoryAdviceRandom = error "toAdvice: Not implemented yet."
+        toAdvice MemoryAdviceSequential = error "toAdvice: Not implemented yet."
+        toAdvice MemoryAdviceWillNeed = error "toAdvice: Not implemented yet."
+        toAdvice MemoryAdviceDontNeed = error "toAdvice: Not implemented yet."
+#endif
+
+-- | lock a range of process address space
+--
+-- call 'mlock'
+memoryLock :: Ptr a -> CSize -> IO ()
+memoryLock ptr sz = throwErrnoIfMinus1_ "mlock" (c_mlock ptr sz)
+
+-- | unlock a range of process address space
+--
+-- call 'munlock'
+memoryUnlock :: Ptr a -> CSize -> IO ()
+memoryUnlock ptr sz = throwErrnoIfMinus1_ "munlock" (c_munlock ptr sz)
+
+-- | set protection of memory mapping
+--
+-- call 'mprotect'
+memoryProtect :: Ptr a -> CSize -> [MemoryProtection] -> IO ()
+memoryProtect ptr sz prots = throwErrnoIfMinus1_ "mprotect" (c_mprotect ptr sz cprot)
+  where cprot = cvalueOfMemoryProts prots
+
+-- | memorySync synchronize memory with physical storage.
+--
+-- On an anonymous mapping this function does not have any effect.
+-- call 'msync'
+memorySync :: Ptr a -> CSize -> [MemorySyncFlag] -> IO ()
+memorySync ptr sz flags = throwErrnoIfMinus1_ "msync" (c_msync ptr sz cflags)
+  where cflags = cvalueOfMemorySync flags
+
+-- | Return the operating system page size.
+--
+-- call 'sysconf'
+sysconfPageSize :: Int
+sysconfPageSize = error "sysconfPageSize: Not implemented yet."
+
+--------------------------------------------------------------------------------
+
+fileSizeToCSize :: FileSize -> CSize
+fileSizeToCSize (FileSize sz) = Prelude.fromIntegral sz
+
+fileSizeFromInteger :: Integer -> FileSize
+fileSizeFromInteger = FileSize . Prelude.fromIntegral
+
+fileMapRead :: FileMapReadF
+fileMapRead fp = bracket (openFile (filePathToLString fp) ReadMode True) (IO.close . fst) $ \(fd,_) -> do
+    sz   <- fileSizeFromInteger `fmap` IO.getSize fd
+    let csz = fileSizeToCSize sz
+    p <- undefined
+    -- p    <- memoryMap Nothing csz [MemoryProtectionRead] MemoryMapPrivate (Just $ Fd $ fdFD fd) 0
+    return $ FileMapping p sz (memoryUnmap p csz)
diff --git a/Foundation/Foreign/MemoryMap/Posix.hsc b/Foundation/Foreign/MemoryMap/Posix.hsc
deleted file mode 100644
index 3377d00..0000000
--- a/Foundation/Foreign/MemoryMap/Posix.hsc
+++ /dev/null
@@ -1,251 +0,0 @@
------------------------------------------------------------------------------
--- |
--- Module      :  Foundation.Foreign.MemoryMap.Posix
--- Copyright   :  (c) Vincent Hanquez 2014
--- License     :  BSD-style
---
--- Maintainer  :  Vincent Hanquez
--- Stability   :  provisional
--- Portability :  non-portable (requires POSIX)
---
--- Functions defined by the POSIX standards for manipulating memory maps
---
--- When a function that calls an underlying POSIX function fails, the errno
--- code is converted to an 'IOError' using 'Foreign.C.Error.errnoToIOError'.
--- For a list of which errno codes may be generated, consult the POSIX
--- documentation for the underlying function.
---
------------------------------------------------------------------------------
-
-#include <sys/mman.h>
-#include <unistd.h>
-
-{-# LANGUAGE ForeignFunctionInterface #-}
-{-# LANGUAGE CPP #-}
-module Foundation.Foreign.MemoryMap.Posix
-    ( memoryMap
-    , memoryUnmap
-    , memoryAdvise
-    , memoryLock
-    , memoryUnlock
-    , memoryProtect
-    , memorySync
-    -- * Flags types
-    , MemoryMapFlag(..)
-    , MemoryProtection(..)
-    , MemoryAdvice(..)
-    , MemorySyncFlag(..)
-    -- * system page size
-    , sysconfPageSize
-    -- * High level
-    , fileMapRead
-    ) where
-
-import Basement.Compat.Base
-import Basement.Types.OffsetSize
-import System.Posix.Types
-import Foreign.Ptr
-import Foreign.C.Types
-import Foreign.C.Error
-import Data.Bits
-
-import Foundation.Collection.Foldable
-import Foundation.VFS
-import qualified Prelude (fromIntegral)
-import Foundation.Foreign.MemoryMap.Types
-import Control.Exception
-
-import           GHC.IO.FD
-import           GHC.IO.IOMode
-import qualified GHC.IO.Device as IO
-
-foreign import ccall unsafe "mmap"
-    c_mmap :: Ptr a -> CSize -> CInt -> CInt -> CInt -> COff -> IO (Ptr a)
-
-foreign import ccall unsafe "munmap"
-    c_munmap :: Ptr a -> CSize -> IO CInt
-
-#if defined(POSIX_MADV_NORMAL)
-foreign import ccall unsafe "posix_madvise"
-    c_madvise :: Ptr a -> CSize -> CInt -> IO CInt
-#else
-foreign import ccall unsafe "madvise"
-    c_madvise :: Ptr a -> CSize -> CInt -> IO CInt
-#endif
-
-foreign import ccall unsafe "msync"
-    c_msync :: Ptr a -> CSize -> CInt -> IO CInt
-
-foreign import ccall unsafe "mprotect"
-    c_mprotect :: Ptr a -> CSize -> CInt -> IO CInt
-
-#ifndef __HAIKU__
-foreign import ccall unsafe "mlock"
-    c_mlock :: Ptr a -> CSize -> IO CInt
-#else
-c_mlock :: Ptr a -> CSize -> IO CInt
-c_mlock _ _ = return (-1)
-#endif
-
-#ifndef __HAIKU__
-foreign import ccall unsafe "munlock"
-    c_munlock :: Ptr a -> CSize -> IO CInt
-#else
-c_munlock :: Ptr a -> CSize -> IO CInt
-c_munlock _ _ = return (-1)
-#endif
-
-foreign import ccall unsafe "sysconf"
-    c_sysconf :: CInt -> CLong
-
--- | Mapping flag
-data MemoryMapFlag =
-      MemoryMapShared  -- ^ memory changes are shared between process
-    | MemoryMapPrivate -- ^ memory changes are private to process
-    deriving (Show,Eq)
-
--- | Memory protection
-data MemoryProtection =
-      MemoryProtectionNone
-    | MemoryProtectionRead
-    | MemoryProtectionWrite
-    | MemoryProtectionExecute
-    deriving (Show,Eq)
-
--- | Advice to put on memory.
---
--- only define the posix one.
-data MemoryAdvice =
-      MemoryAdviceNormal     -- ^ no specific advice, the default.
-    | MemoryAdviceRandom     -- ^ Expect page references in random order. No readahead should occur.
-    | MemoryAdviceSequential -- ^ Expect page references in sequential order. Page should be readahead aggressively.
-    | MemoryAdviceWillNeed   -- ^ Expect access in the near future. Probably a good idea to readahead early
-    | MemoryAdviceDontNeed   -- ^ Do not expect access in the near future.
-    deriving (Show,Eq)
-
--- | Memory synchronization flags
-data MemorySyncFlag =
-      MemorySyncAsync      -- ^ perform asynchronous write.
-    | MemorySyncSync       -- ^ perform synchronous write.
-    | MemorySyncInvalidate -- ^ invalidate cache data.
-    deriving (Show,Eq)
-
-cvalueOfMemoryProts :: [MemoryProtection] -> CInt
-cvalueOfMemoryProts = foldl' (.|.) 0 . fmap toProt
-  where toProt :: MemoryProtection -> CInt
-        toProt MemoryProtectionNone    = (#const PROT_NONE)
-        toProt MemoryProtectionRead    = (#const PROT_READ)
-        toProt MemoryProtectionWrite   = (#const PROT_WRITE)
-        toProt MemoryProtectionExecute = (#const PROT_EXEC)
-
-cvalueOfMemorySync :: [MemorySyncFlag] -> CInt
-cvalueOfMemorySync = foldl' (.|.) 0 . fmap toSync
-  where toSync MemorySyncAsync      = (#const MS_ASYNC)
-        toSync MemorySyncSync       = (#const MS_SYNC)
-        toSync MemorySyncInvalidate = (#const MS_INVALIDATE)
-
--- | Map pages of memory.
---
--- If fd is present, this memory will represent the file associated.
--- Otherwise, the memory will be an anonymous mapping.
---
--- use 'mmap'
-memoryMap :: Maybe (Ptr a)      -- ^ The address to map to if MapFixed is used.
-          -> CSize              -- ^ The length of the mapping
-          -> [MemoryProtection] -- ^ the memory protection associated with the mapping
-          -> MemoryMapFlag      -- ^
-          -> Maybe Fd
-          -> COff
-          -> IO (Ptr a)
-memoryMap initPtr sz prots flag mfd off =
-    throwErrnoIf (== m1ptr) "mmap" (c_mmap (maybe nullPtr id initPtr) sz cprot cflags fd off)
-  where m1ptr  = nullPtr `plusPtr` (-1)
-        fd     = maybe (-1) (\(Fd v) -> v) mfd
-        cprot  = cvalueOfMemoryProts prots
-        cflags = maybe cMapAnon (const 0) mfd
-             .|. maybe 0 (const cMapFixed) initPtr
-             .|. toMapFlag flag
-
-#ifdef __APPLE__
-        cMapAnon  = (#const MAP_ANON)
-#else
-        cMapAnon  = (#const MAP_ANONYMOUS)
-#endif
-        cMapFixed = (#const MAP_FIXED)
-
-        toMapFlag MemoryMapShared  = (#const MAP_SHARED)
-        toMapFlag MemoryMapPrivate = (#const MAP_PRIVATE)
-
--- | Unmap pages of memory
---
--- use 'munmap'
-memoryUnmap :: Ptr a -> CSize -> IO ()
-memoryUnmap ptr sz = throwErrnoIfMinus1_ "munmap" (c_munmap ptr sz)
-
--- | give advice to the operating system about use of memory
---
--- call 'madvise'
-memoryAdvise :: Ptr a -> CSize -> MemoryAdvice -> IO ()
-memoryAdvise ptr sz adv = throwErrnoIfMinus1_ "madvise" (c_madvise ptr sz cadv)
-  where cadv = toAdvice adv
-#if defined(POSIX_MADV_NORMAL)
-        toAdvice MemoryAdviceNormal = (#const POSIX_MADV_NORMAL)
-        toAdvice MemoryAdviceRandom = (#const POSIX_MADV_RANDOM)
-        toAdvice MemoryAdviceSequential = (#const POSIX_MADV_SEQUENTIAL)
-        toAdvice MemoryAdviceWillNeed = (#const POSIX_MADV_WILLNEED)
-        toAdvice MemoryAdviceDontNeed = (#const POSIX_MADV_DONTNEED)
-#else
-        toAdvice MemoryAdviceNormal = (#const MADV_NORMAL)
-        toAdvice MemoryAdviceRandom = (#const MADV_RANDOM)
-        toAdvice MemoryAdviceSequential = (#const MADV_SEQUENTIAL)
-        toAdvice MemoryAdviceWillNeed = (#const MADV_WILLNEED)
-        toAdvice MemoryAdviceDontNeed = (#const MADV_DONTNEED)
-#endif
-
--- | lock a range of process address space
---
--- call 'mlock'
-memoryLock :: Ptr a -> CSize -> IO ()
-memoryLock ptr sz = throwErrnoIfMinus1_ "mlock" (c_mlock ptr sz)
-
--- | unlock a range of process address space
---
--- call 'munlock'
-memoryUnlock :: Ptr a -> CSize -> IO ()
-memoryUnlock ptr sz = throwErrnoIfMinus1_ "munlock" (c_munlock ptr sz)
-
--- | set protection of memory mapping
---
--- call 'mprotect'
-memoryProtect :: Ptr a -> CSize -> [MemoryProtection] -> IO ()
-memoryProtect ptr sz prots = throwErrnoIfMinus1_ "mprotect" (c_mprotect ptr sz cprot)
-  where cprot = cvalueOfMemoryProts prots
-
--- | memorySync synchronize memory with physical storage.
---
--- On an anonymous mapping this function does not have any effect.
--- call 'msync'
-memorySync :: Ptr a -> CSize -> [MemorySyncFlag] -> IO ()
-memorySync ptr sz flags = throwErrnoIfMinus1_ "msync" (c_msync ptr sz cflags)
-  where cflags = cvalueOfMemorySync flags
-
--- | Return the operating system page size.
---
--- call 'sysconf'
-sysconfPageSize :: Int
-sysconfPageSize = Prelude.fromIntegral $ c_sysconf (#const _SC_PAGESIZE)
-
---------------------------------------------------------------------------------
-
-fileSizeToCSize :: FileSize -> CSize
-fileSizeToCSize (FileSize sz) = Prelude.fromIntegral sz
-
-fileSizeFromInteger :: Integer -> FileSize
-fileSizeFromInteger = FileSize . Prelude.fromIntegral
-
-fileMapRead :: FileMapReadF
-fileMapRead fp = bracket (openFile (filePathToLString fp) ReadMode True) (IO.close . fst) $ \(fd,_) -> do
-    sz   <- fileSizeFromInteger `fmap` IO.getSize fd
-    let csz = fileSizeToCSize sz
-    p    <- memoryMap Nothing csz [MemoryProtectionRead] MemoryMapPrivate (Just $ Fd $ fdFD fd) 0
-    return $ FileMapping p sz (memoryUnmap p csz)
diff --git a/Foundation/Network/HostName.hs b/Foundation/Network/HostName.hs
new file mode 100644
index 0000000..772e00f
--- /dev/null
+++ b/Foundation/Network/HostName.hs
@@ -0,0 +1,169 @@
+-- |
+-- Module      : Foundation.Network.HostName
+-- License     : BSD-style
+-- Maintainer  : Nicolas Di Prima <nicolas@primetype.co.uk>
+-- Stability   : experimental
+-- Portability : portable
+--
+-- HostName and HostName info
+--
+-- > getHostNameInfo "github.com" :: IO (HostNameInfo IPv4)
+--
+-- > getHostNameInfo "google.com" :: IO (HostNameInfo IPv6)
+--
+{-# LANGUAGE GeneralizedNewtypeDeriving #-}
+{-# LANGUAGE FlexibleContexts #-}
+{-# LANGUAGE OverloadedStrings #-}
+{-# LANGUAGE ForeignFunctionInterface #-}
+module Foundation.Network.HostName
+    ( HostName(..)
+    , HostNameInfo(..)
+    , getHostNameInfo
+    , getHostNameInfo_
+    ) where
+
+import Foundation.Class.Storable
+import Basement.Compat.Base
+import Data.Proxy
+import Foundation.Hashing (Hashable)
+import Foundation.String
+import Foundation.Array
+import Foundation.Collection.Mappable
+import Foundation.Network.IPv4 (IPv4)
+import Foundation.Network.IPv6 (IPv6)
+
+import Foundation.System.Bindings.Network
+
+import Foreign.C.String
+import Foreign.C.Types
+import Foreign.Ptr (nullPtr)
+import Control.Concurrent.MVar
+import System.IO.Unsafe (unsafePerformIO)
+
+import Control.Monad ((=<<))
+
+#ifdef mingw32_HOST_OS
+# include <winsock2.h>
+#else
+# include <netdb.h>
+# include <netinet/in.h>
+# include <sys/socket.h>
+#endif
+
+-- | HostName
+--
+newtype HostName = HostName { toString :: String }
+  deriving (Eq, Ord, Typeable, Hashable)
+instance Show HostName where
+    show = show . toString
+instance IsString HostName where
+    fromString = HostName . fromString
+
+-- | HostName Info
+data HostNameInfo address_type = HostNameInfo
+    { officialName :: !HostName
+        -- ^ official names
+    , aliases      :: !(Array HostName)
+        -- ^ known aliases
+    , addresses    :: !(Array address_type)
+        -- ^ known addresses
+    } deriving (Show, Eq, Ord, Typeable)
+
+-- | HostName errors
+data HostNameError
+    = HostNotFound !HostName
+        -- ^ the given HostMame was not found
+    | NoAssociatedData !HostName
+        -- ^ there is not associated info/data to the given HostName
+        --
+        -- i.e. : no IPv4 info? This might mean you should try IPv6 ?
+    | FatalError
+        -- ^ getHostNameInfo uses *C* a binding to get the `HostNameInfo`
+        --
+        -- a fatal error is linked to the underlying *C* function and is not
+        -- recoverable.
+    | UnknownError !CInt
+        -- ^ Unknown Error, `CInt` is the associated error code.
+        --
+        -- see man gethostbyname for more information
+  deriving (Show,Eq,Typeable)
+
+instance Exception HostNameError
+
+-- TODO: move this when we have socket family and domain name...
+class SocketFamily a where
+    familyCode :: proxy a -> CInt
+instance SocketFamily IPv4 where
+    familyCode _ = (#const AF_INET)
+instance SocketFamily IPv6 where
+    familyCode _ = (#const AF_INET6)
+
+-- | get `HostName` info:
+--
+-- retrieve the official name, the aliases and the addresses associated to this
+-- hostname.
+--
+-- For cross-platform compatibility purpose, this function is using a *C* non
+-- re-entrant function `gethostbyname2`. This function is using a `MVar ()` to
+-- avoid a race condition and should be safe to use.
+--
+getHostNameInfo :: (Eq address_type, Storable address_type, SocketFamily address_type)
+                => HostName
+                -> IO (HostNameInfo address_type)
+getHostNameInfo = getHostNameInfo_ Proxy
+
+globalMutex :: MVar ()
+globalMutex = unsafePerformIO (newMVar ())
+{-# NOINLINE globalMutex #-}
+
+-- | like `getHostNameInfo` but takes a `Proxy` to help with the type checker.
+getHostNameInfo_ :: (SocketFamily address_type, Eq address_type, Storable address_type)
+                 => Proxy address_type
+                 -> HostName
+                 -> IO (HostNameInfo address_type)
+getHostNameInfo_ p h@(HostName hn) =
+    withMVar globalMutex $ \_ ->
+    withCString (toList hn) $ \cname -> do
+        ptr <- loop $ c_gethostbyname2 cname (familyCode p)
+
+        on <- peekHostName . castPtr =<< peek (castPtr $ offname_ptr ptr)
+
+        as <- getAliases . castPtr =<< peek (castPtr $ aliases_ptr ptr)
+
+        addrs <- getAddresses p . castPtr =<< peek (castPtr $ addr_list ptr)
+        return $ HostNameInfo on as addrs
+  where
+    loop f = do
+        ptr <- f
+        if ptr /= nullPtr
+            then return ptr
+            else do
+                err <- getHErrno
+                case err of
+                    _ | err == herr_NoData        -> throwIO $ NoAssociatedData h
+                      | err == herr_HostNotFound  -> throwIO $ HostNotFound h
+                      | err == herr_TryAgain      -> loop f
+                      | err == herr_NoRecovery    -> throwIO FatalError
+                      | otherwise                 -> throwIO $ UnknownError err
+    offname_ptr = (#ptr struct hostent, h_name)
+    aliases_ptr = (#ptr struct hostent, h_aliases)
+    addr_list   = (#ptr struct hostent, h_addr_list)
+
+peekHostName :: Ptr Word8 -> IO HostName
+peekHostName ptr = HostName . fst . fromBytesLenient <$> peekArrayEndedBy 0x00 ptr
+
+getAliases :: Ptr (Ptr Word8) -> IO (Array HostName)
+getAliases ptr = do
+    arr <- peekArrayEndedBy nullPtr ptr
+    forM arr peekHostName
+
+getAddresses :: Storable address_type
+             => Proxy address_type
+             -> Ptr (Ptr address_type)
+             -> IO (Array address_type)
+getAddresses _ ptr = do
+    arr <- peekArrayEndedBy nullPtr ptr
+    forM arr peek
+
+c_gethostbyname2 :: CString -> CInt -> IO (Ptr Word8)
+c_gethostbyname2 = error "c_gethostbyname2: Not implemented yet."
diff --git a/Foundation/Network/HostName.hsc b/Foundation/Network/HostName.hsc
deleted file mode 100644
index 0395021..0000000
--- a/Foundation/Network/HostName.hsc
+++ /dev/null
@@ -1,169 +0,0 @@
--- |
--- Module      : Foundation.Network.HostName
--- License     : BSD-style
--- Maintainer  : Nicolas Di Prima <nicolas@primetype.co.uk>
--- Stability   : experimental
--- Portability : portable
---
--- HostName and HostName info
---
--- > getHostNameInfo "github.com" :: IO (HostNameInfo IPv4)
---
--- > getHostNameInfo "google.com" :: IO (HostNameInfo IPv6)
---
-{-# LANGUAGE GeneralizedNewtypeDeriving #-}
-{-# LANGUAGE FlexibleContexts #-}
-{-# LANGUAGE OverloadedStrings #-}
-{-# LANGUAGE ForeignFunctionInterface #-}
-module Foundation.Network.HostName
-    ( HostName(..)
-    , HostNameInfo(..)
-    , getHostNameInfo
-    , getHostNameInfo_
-    ) where
-
-import Foundation.Class.Storable
-import Basement.Compat.Base
-import Data.Proxy
-import Foundation.Hashing (Hashable)
-import Foundation.String
-import Foundation.Array
-import Foundation.Collection.Mappable
-import Foundation.Network.IPv4 (IPv4)
-import Foundation.Network.IPv6 (IPv6)
-
-import Foundation.System.Bindings.Network
-
-import Foreign.C.String
-import Foreign.C.Types
-import Foreign.Ptr (nullPtr)
-import Control.Concurrent.MVar
-import System.IO.Unsafe (unsafePerformIO)
-
-import Control.Monad ((=<<))
-
-#ifdef mingw32_HOST_OS
-# include <winsock2.h>
-#else
-# include <netdb.h>
-# include <netinet/in.h>
-# include <sys/socket.h>
-#endif
-
--- | HostName
---
-newtype HostName = HostName { toString :: String }
-  deriving (Eq, Ord, Typeable, Hashable)
-instance Show HostName where
-    show = show . toString
-instance IsString HostName where
-    fromString = HostName . fromString
-
--- | HostName Info
-data HostNameInfo address_type = HostNameInfo
-    { officialName :: !HostName
-        -- ^ official names
-    , aliases      :: !(Array HostName)
-        -- ^ known aliases
-    , addresses    :: !(Array address_type)
-        -- ^ known addresses
-    } deriving (Show, Eq, Ord, Typeable)
-
--- | HostName errors
-data HostNameError
-    = HostNotFound !HostName
-        -- ^ the given HostMame was not found
-    | NoAssociatedData !HostName
-        -- ^ there is not associated info/data to the given HostName
-        --
-        -- i.e. : no IPv4 info? This might mean you should try IPv6 ?
-    | FatalError
-        -- ^ getHostNameInfo uses *C* a binding to get the `HostNameInfo`
-        --
-        -- a fatal error is linked to the underlying *C* function and is not
-        -- recoverable.
-    | UnknownError !CInt
-        -- ^ Unknown Error, `CInt` is the associated error code.
-        --
-        -- see man gethostbyname for more information
-  deriving (Show,Eq,Typeable)
-
-instance Exception HostNameError
-
--- TODO: move this when we have socket family and domain name...
-class SocketFamily a where
-    familyCode :: proxy a -> CInt
-instance SocketFamily IPv4 where
-    familyCode _ = (#const AF_INET)
-instance SocketFamily IPv6 where
-    familyCode _ = (#const AF_INET6)
-
--- | get `HostName` info:
---
--- retrieve the official name, the aliases and the addresses associated to this
--- hostname.
---
--- For cross-platform compatibility purpose, this function is using a *C* non
--- re-entrant function `gethostbyname2`. This function is using a `MVar ()` to
--- avoid a race condition and should be safe to use.
---
-getHostNameInfo :: (Eq address_type, Storable address_type, SocketFamily address_type)
-                => HostName
-                -> IO (HostNameInfo address_type)
-getHostNameInfo = getHostNameInfo_ Proxy
-
-globalMutex :: MVar ()
-globalMutex = unsafePerformIO (newMVar ())
-{-# NOINLINE globalMutex #-}
-
--- | like `getHostNameInfo` but takes a `Proxy` to help with the type checker.
-getHostNameInfo_ :: (SocketFamily address_type, Eq address_type, Storable address_type)
-                 => Proxy address_type
-                 -> HostName
-                 -> IO (HostNameInfo address_type)
-getHostNameInfo_ p h@(HostName hn) =
-    withMVar globalMutex $ \_ ->
-    withCString (toList hn) $ \cname -> do
-        ptr <- loop $ c_gethostbyname2 cname (familyCode p)
-
-        on <- peekHostName . castPtr =<< peek (castPtr $ offname_ptr ptr)
-
-        as <- getAliases . castPtr =<< peek (castPtr $ aliases_ptr ptr)
-
-        addrs <- getAddresses p . castPtr =<< peek (castPtr $ addr_list ptr)
-        return $ HostNameInfo on as addrs
-  where
-    loop f = do
-        ptr <- f
-        if ptr /= nullPtr
-            then return ptr
-            else do
-                err <- getHErrno
-                case err of
-                    _ | err == herr_NoData        -> throwIO $ NoAssociatedData h
-                      | err == herr_HostNotFound  -> throwIO $ HostNotFound h
-                      | err == herr_TryAgain      -> loop f
-                      | err == herr_NoRecovery    -> throwIO FatalError
-                      | otherwise                 -> throwIO $ UnknownError err
-    offname_ptr = (#ptr struct hostent, h_name)
-    aliases_ptr = (#ptr struct hostent, h_aliases)
-    addr_list   = (#ptr struct hostent, h_addr_list)
-
-peekHostName :: Ptr Word8 -> IO HostName
-peekHostName ptr = HostName . fst . fromBytesLenient <$> peekArrayEndedBy 0x00 ptr
-
-getAliases :: Ptr (Ptr Word8) -> IO (Array HostName)
-getAliases ptr = do
-    arr <- peekArrayEndedBy nullPtr ptr
-    forM arr peekHostName
-
-getAddresses :: Storable address_type
-             => Proxy address_type
-             -> Ptr (Ptr address_type)
-             -> IO (Array address_type)
-getAddresses _ ptr = do
-    arr <- peekArrayEndedBy nullPtr ptr
-    forM arr peek
-
-foreign import ccall safe "gethostbyname2"
-    c_gethostbyname2 :: CString -> CInt -> IO (Ptr Word8)
diff --git a/Foundation/Random/ChaChaDRG.hs b/Foundation/Random/ChaChaDRG.hs
index 386e7f2..2c5b691 100644
--- a/Foundation/Random/ChaChaDRG.hs
+++ b/Foundation/Random/ChaChaDRG.hs
@@ -12,6 +12,7 @@ import           Foundation.Random.DRG
 import qualified Basement.UArray as A
 import qualified Basement.UArray.Mutable as A
 import           GHC.ST
+import qualified GHC.Err as Err
 import qualified Foreign.Marshal.Alloc (alloca)
 
 -- | RNG based on ChaCha core.
@@ -74,27 +75,27 @@ generateF64 (State key) = runST $ unsafePrimFromIO $
         (,) <$> peek dst <*> (State <$> A.unsafeFreeze newKey)
 
 -- return 0 on success, !0 for failure
-foreign import ccall unsafe "foundation_rngV1_generate"
-   c_rngv1_generate :: Ptr Word8 -- new key
+c_rngv1_generate :: Ptr Word8 -- new key
                     -> Ptr Word8 -- destination
                     -> Ptr Word8 -- current key
                     -> CountOf Word8 -- number of bytes to generate
                     -> IO Word32
+c_rngv1_generate = Err.error "c_rngv1_generate: Not implemented yet."
 
-foreign import ccall unsafe "foundation_rngV1_generate_word64"
-   c_rngv1_generate_word64 :: Ptr Word8  -- new key
+c_rngv1_generate_word64 :: Ptr Word8  -- new key
                            -> Ptr Word64 -- destination
                            -> Ptr Word8  -- current key
                            -> IO Word32
+c_rngv1_generate_word64 = Err.error "c_rngv1_generate_word64: Not implemented yet."
 
-foreign import ccall unsafe "foundation_rngV1_generate_f32"
-   c_rngv1_generate_f32 :: Ptr Word8  -- new key
+c_rngv1_generate_f32 :: Ptr Word8  -- new key
                         -> Ptr Float -- destination
                         -> Ptr Word8  -- current key
                         -> IO Word32
+c_rngv1_generate_f32 = Err.error "c_rngv1_generate_f32: Not implemented yet."
 
-foreign import ccall unsafe "foundation_rngV1_generate_f64"
-   c_rngv1_generate_f64 :: Ptr Word8  -- new key
+c_rngv1_generate_f64 :: Ptr Word8  -- new key
                         -> Ptr Double -- destination
                         -> Ptr Word8  -- current key
                         -> IO Word32
+c_rngv1_generate_f64 = Err.error "c_rngv1_generate_f64: Not implemented yet."
diff --git a/Foundation/System/Bindings/Hs.hs b/Foundation/System/Bindings/Hs.hs
index a29bd6b..ea74669 100644
--- a/Foundation/System/Bindings/Hs.hs
+++ b/Foundation/System/Bindings/Hs.hs
@@ -5,6 +5,8 @@ module Foundation.System.Bindings.Hs
     where
 
 import GHC.IO
+import GHC.Err
 import Foreign.C.Types
 
-foreign import ccall unsafe "HsBase.h __hscore_get_errno" sysHsCoreGetErrno :: IO CInt
+sysHsCoreGetErrno :: IO CInt
+sysHsCoreGetErrno = error "sysHsCoreGetErrno: Not implemented yet."
diff --git a/Foundation/System/Bindings/Linux.hs b/Foundation/System/Bindings/Linux.hs
new file mode 100644
index 0000000..36e573f
--- /dev/null
+++ b/Foundation/System/Bindings/Linux.hs
@@ -0,0 +1,108 @@
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Foundation.System.Bindings.Linux
+-- Copyright   :  (c) Vincent Hanquez 2014-2017
+-- License     :  BSD-style
+--
+-- Maintainer  :  Vincent Hanquez
+-- Stability   :  provisional
+-- Portability :  non-portable (requires Linux)
+--
+-- Functions defined only for linux
+--
+-----------------------------------------------------------------------------
+{-# OPTIONS_HADDOCK hide #-}
+module Foundation.System.Bindings.Linux
+   where
+
+import Basement.Compat.Base
+import Foreign.C.Types
+import Foundation.System.Bindings.PosixDef
+
+#define __USE_GNU
+
+#include <sys/types.h>
+#include <sys/inotify.h>
+#include <fcntl.h>
+
+type CInotifyFlags = CInt
+type CInotifyMask = CInt
+type CWatchDescriptor = CInt
+
+sysLinux_O_TMPFILE
+    :: COpenFlags
+#ifdef __O_TMPFILE
+sysLinux_O_TMPFILE   = (#const __O_TMPFILE)
+#else
+sysLinux_O_TMPFILE   = 0
+#endif
+
+#ifdef IN_NONBLOCK
+sysLinux_IN_NONBLOCK :: CInotifyFlags
+sysLinux_IN_NONBLOCK = (#const IN_NONBLOCK)
+#endif
+
+#ifdef IN_CLOEXEC
+sysLinux_IN_CLOEXEC :: CInotifyFlags
+sysLinux_IN_CLOEXEC  = (#const IN_CLOEXEC)
+#endif
+
+sysLinux_IN_ACCESS
+    , sysLinux_IN_ATTRIB
+    , sysLinux_IN_CLOSE_WRITE
+    , sysLinux_IN_CLOSE_NOWRITE
+    , sysLinux_IN_CREATE
+    , sysLinux_IN_DELETE
+    , sysLinux_IN_DELETE_SELF
+    , sysLinux_IN_MODIFY
+    , sysLinux_IN_MOVE_SELF
+    , sysLinux_IN_MOVED_FROM
+    , sysLinux_IN_MOVED_TO :: CInotifyMask
+sysLinux_IN_ACCESS = (#const IN_ACCESS)
+sysLinux_IN_ATTRIB = (#const IN_ATTRIB)
+sysLinux_IN_CLOSE_WRITE = (#const IN_CLOSE_WRITE)
+sysLinux_IN_CLOSE_NOWRITE = (#const IN_CLOSE_NOWRITE)
+sysLinux_IN_CREATE = (#const IN_CREATE)
+sysLinux_IN_DELETE = (#const IN_DELETE)
+sysLinux_IN_DELETE_SELF = (#const IN_DELETE_SELF)
+sysLinux_IN_MODIFY = (#const IN_MODIFY)
+sysLinux_IN_MOVE_SELF = (#const IN_MOVE_SELF)
+sysLinux_IN_MOVED_FROM = (#const IN_MOVED_FROM)
+sysLinux_IN_MOVED_TO = (#const IN_MOVED_TO)
+
+-- extra mask at add_watch time
+sysLinux_IN_OPEN
+    , sysLinux_IN_DONT_FOLLOW
+    , sysLinux_IN_MASK_ADD
+    , sysLinux_IN_ONESHOT
+    , sysLinux_IN_ONLYDIR :: CInotifyMask
+sysLinux_IN_OPEN = (#const IN_OPEN)
+sysLinux_IN_DONT_FOLLOW = (#const IN_DONT_FOLLOW)
+sysLinux_IN_MASK_ADD = (#const IN_MASK_ADD)
+sysLinux_IN_ONESHOT = (#const IN_ONESHOT)
+sysLinux_IN_ONLYDIR = (#const IN_ONLYDIR)
+
+#ifdef IN_EXCL_UNLINK
+sysLinux_IN_EXCL_UNLINK :: CInotifyMask
+sysLinux_IN_EXCL_UNLINK = (#const IN_EXCL_UNLINK)
+#endif
+
+-- only found in mask
+sysLinux_IN_IGNORED
+    , sysLinux_IN_ISDIR
+    , sysLinux_IN_Q_OVERFLOW
+    , sysLinux_IN_UNMOUNT :: CInotifyMask
+sysLinux_IN_IGNORED = (#const IN_IGNORED)
+sysLinux_IN_ISDIR = (#const IN_ISDIR)
+sysLinux_IN_Q_OVERFLOW = (#const IN_Q_OVERFLOW)
+sysLinux_IN_UNMOUNT = (#const IN_UNMOUNT)
+
+cinotifyEventSize :: CSize
+cinotifyEventSize = 16
+
+sysLinuxInotifyInit :: CInotifyFlags -> IO CFd
+sysLinuxInotifyInit = error "sysLinuxInotifyInit: Not implemented yet."
+sysLinuxInotifyAddWatch :: CFd -> Ptr CChar -> CInotifyMask -> IO CWatchDescriptor
+sysLinuxInotifyAddWatch = error "sysLinuxInotifyAddWatch: Not implemented yet."
+sysLinuxInotifyRmWatch :: CFd -> CWatchDescriptor -> IO Int
+sysLinuxInotifyRmWatch = error "sysLinuxInotifyRmWatch: Not implemented yet."
diff --git a/Foundation/System/Bindings/Linux.hsc b/Foundation/System/Bindings/Linux.hsc
deleted file mode 100644
index b1e51cf..0000000
--- a/Foundation/System/Bindings/Linux.hsc
+++ /dev/null
@@ -1,108 +0,0 @@
------------------------------------------------------------------------------
--- |
--- Module      :  Foundation.System.Bindings.Linux
--- Copyright   :  (c) Vincent Hanquez 2014-2017
--- License     :  BSD-style
---
--- Maintainer  :  Vincent Hanquez
--- Stability   :  provisional
--- Portability :  non-portable (requires Linux)
---
--- Functions defined only for linux
---
------------------------------------------------------------------------------
-{-# OPTIONS_HADDOCK hide #-}
-module Foundation.System.Bindings.Linux
-   where
-
-import Basement.Compat.Base
-import Foreign.C.Types
-import Foundation.System.Bindings.PosixDef
-
-#define __USE_GNU
-
-#include <sys/types.h>
-#include <sys/inotify.h>
-#include <fcntl.h>
-
-type CInotifyFlags = CInt
-type CInotifyMask = CInt
-type CWatchDescriptor = CInt
-
-sysLinux_O_TMPFILE
-    :: COpenFlags
-#ifdef __O_TMPFILE
-sysLinux_O_TMPFILE   = (#const __O_TMPFILE)
-#else
-sysLinux_O_TMPFILE   = 0
-#endif
-
-#ifdef IN_NONBLOCK
-sysLinux_IN_NONBLOCK :: CInotifyFlags
-sysLinux_IN_NONBLOCK = (#const IN_NONBLOCK)
-#endif
-
-#ifdef IN_CLOEXEC
-sysLinux_IN_CLOEXEC :: CInotifyFlags
-sysLinux_IN_CLOEXEC  = (#const IN_CLOEXEC)
-#endif
-
-sysLinux_IN_ACCESS
-    , sysLinux_IN_ATTRIB
-    , sysLinux_IN_CLOSE_WRITE
-    , sysLinux_IN_CLOSE_NOWRITE
-    , sysLinux_IN_CREATE
-    , sysLinux_IN_DELETE
-    , sysLinux_IN_DELETE_SELF
-    , sysLinux_IN_MODIFY
-    , sysLinux_IN_MOVE_SELF
-    , sysLinux_IN_MOVED_FROM
-    , sysLinux_IN_MOVED_TO :: CInotifyMask
-sysLinux_IN_ACCESS = (#const IN_ACCESS)
-sysLinux_IN_ATTRIB = (#const IN_ATTRIB)
-sysLinux_IN_CLOSE_WRITE = (#const IN_CLOSE_WRITE)
-sysLinux_IN_CLOSE_NOWRITE = (#const IN_CLOSE_NOWRITE)
-sysLinux_IN_CREATE = (#const IN_CREATE)
-sysLinux_IN_DELETE = (#const IN_DELETE)
-sysLinux_IN_DELETE_SELF = (#const IN_DELETE_SELF)
-sysLinux_IN_MODIFY = (#const IN_MODIFY)
-sysLinux_IN_MOVE_SELF = (#const IN_MOVE_SELF)
-sysLinux_IN_MOVED_FROM = (#const IN_MOVED_FROM)
-sysLinux_IN_MOVED_TO = (#const IN_MOVED_TO)
-
--- extra mask at add_watch time
-sysLinux_IN_OPEN
-    , sysLinux_IN_DONT_FOLLOW
-    , sysLinux_IN_MASK_ADD
-    , sysLinux_IN_ONESHOT
-    , sysLinux_IN_ONLYDIR :: CInotifyMask
-sysLinux_IN_OPEN = (#const IN_OPEN)
-sysLinux_IN_DONT_FOLLOW = (#const IN_DONT_FOLLOW)
-sysLinux_IN_MASK_ADD = (#const IN_MASK_ADD)
-sysLinux_IN_ONESHOT = (#const IN_ONESHOT)
-sysLinux_IN_ONLYDIR = (#const IN_ONLYDIR)
-
-#ifdef IN_EXCL_UNLINK
-sysLinux_IN_EXCL_UNLINK :: CInotifyMask
-sysLinux_IN_EXCL_UNLINK = (#const IN_EXCL_UNLINK)
-#endif
-
--- only found in mask
-sysLinux_IN_IGNORED
-    , sysLinux_IN_ISDIR
-    , sysLinux_IN_Q_OVERFLOW
-    , sysLinux_IN_UNMOUNT :: CInotifyMask
-sysLinux_IN_IGNORED = (#const IN_IGNORED)
-sysLinux_IN_ISDIR = (#const IN_ISDIR)
-sysLinux_IN_Q_OVERFLOW = (#const IN_Q_OVERFLOW)
-sysLinux_IN_UNMOUNT = (#const IN_UNMOUNT)
-
-cinotifyEventSize :: CSize
-cinotifyEventSize = 16
-
-foreign import ccall unsafe "inotify_init1"
-    sysLinuxInotifyInit :: CInotifyFlags -> IO CFd
-foreign import ccall unsafe "inotify_add_watch"
-    sysLinuxInotifyAddWatch :: CFd -> Ptr CChar -> CInotifyMask -> IO CWatchDescriptor
-foreign import ccall unsafe "inotify_rm_watch"
-    sysLinuxInotifyRmWatch :: CFd -> CWatchDescriptor -> IO Int
diff --git a/Foundation/System/Bindings/Macos.hs b/Foundation/System/Bindings/Macos.hs
new file mode 100644
index 0000000..abb60d6
--- /dev/null
+++ b/Foundation/System/Bindings/Macos.hs
@@ -0,0 +1,33 @@
+{-# OPTIONS_HADDOCK hide #-}
+module Foundation.System.Bindings.Macos
+    where
+
+import Basement.Compat.Base
+import Foreign.C.Types
+import Foundation.System.Bindings.PosixDef
+import Basement.Types.OffsetSize
+
+sysMacos_O_SHLOCK
+    , sysMacos_O_EXLOCK
+    , sysMacos_O_SYMLINK
+    , sysMacos_O_EVTONLY :: COpenFlags
+sysMacos_O_SHLOCK   = error "sysMacos_O_SHLOCK: Not implemented yet."
+sysMacos_O_EXLOCK   = error "sysMacos_O_EXLOCK: Not implemented yet."
+sysMacos_O_SYMLINK  = error "sysMacos_O_SYMLINK: Not implemented yet."
+sysMacos_O_EVTONLY  = error "sysMacos_O_EVTONLY: Not implemented yet."
+
+data MachTimebaseInfo
+
+size_MachTimebaseInfo :: CSize
+size_MachTimebaseInfo = error "size_MachTimebaseInfo: Not implemented yet."
+
+ofs_MachTimebaseInfo_numer :: Offset Word8
+ofs_MachTimebaseInfo_numer = error "ofs_MachTimebaseInfo_numer: Not implemented yet."
+
+ofs_MachTimebaseInfo_denom :: Offset Word8
+ofs_MachTimebaseInfo_denom = error "ofs_MachTimebaseInfo_denom: Not implemented yet."
+
+sysMacos_absolute_time :: IO Word64
+sysMacos_absolute_time = error "sysMacos_absolute_time: Not implemented yet."
+sysMacos_timebase_info :: Ptr MachTimebaseInfo -> IO ()
+sysMacos_timebase_info = error "sysMacos_timebase_info: Not implemented yet."
diff --git a/Foundation/System/Bindings/Macos.hsc b/Foundation/System/Bindings/Macos.hsc
deleted file mode 100644
index 670bf41..0000000
--- a/Foundation/System/Bindings/Macos.hsc
+++ /dev/null
@@ -1,40 +0,0 @@
-{-# OPTIONS_HADDOCK hide #-}
-module Foundation.System.Bindings.Macos
-    where
-
-import Basement.Compat.Base
-import Foreign.C.Types
-import Foundation.System.Bindings.PosixDef
-import Basement.Types.OffsetSize
-
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <mach/mach.h>
-#include <mach/mach_time.h>
-
-sysMacos_O_SHLOCK
-    , sysMacos_O_EXLOCK
-    , sysMacos_O_SYMLINK
-    , sysMacos_O_EVTONLY :: COpenFlags
-sysMacos_O_SHLOCK   = (#const O_SHLOCK)
-sysMacos_O_EXLOCK   = (#const O_EXLOCK)
-sysMacos_O_SYMLINK  = (#const O_SYMLINK)
-sysMacos_O_EVTONLY  = (#const O_EVTONLY)
-
-data MachTimebaseInfo
-
-size_MachTimebaseInfo :: CSize
-size_MachTimebaseInfo = #const sizeof(mach_timebase_info_data_t)
-
-ofs_MachTimebaseInfo_numer :: Offset Word8
-ofs_MachTimebaseInfo_numer = Offset (#offset mach_timebase_info_data_t, numer)
-
-ofs_MachTimebaseInfo_denom :: Offset Word8
-ofs_MachTimebaseInfo_denom = Offset (#offset mach_timebase_info_data_t, denom)
-
-foreign import ccall unsafe "mach_absolute_time"
-    sysMacos_absolute_time :: IO Word64
-foreign import ccall unsafe "mach_timebase_info"
-    sysMacos_timebase_info :: Ptr MachTimebaseInfo -> IO ()
diff --git a/Foundation/System/Bindings/Network.hs b/Foundation/System/Bindings/Network.hs
new file mode 100644
index 0000000..4c024af
--- /dev/null
+++ b/Foundation/System/Bindings/Network.hs
@@ -0,0 +1,39 @@
+-- |
+-- Module      :  Foundation.System.Bindings.HostName
+-- License     :  BSD-style
+-- Maintainer  :  Nicolas Di Prima <nicolas@primetype.co.uk>
+-- Stability   :  provisional
+-- Portability :  portable
+--
+{-# OPTIONS_HADDOCK hide #-}
+module Foundation.System.Bindings.Network
+    ( -- * error
+      getHErrno
+    , herr_HostNotFound
+    , herr_NoData
+    , herr_NoRecovery
+    , herr_TryAgain
+    ) where
+
+import Basement.Compat.Base
+import Foreign.C.Types
+
+herr_HostNotFound
+  , herr_NoData
+  , herr_NoRecovery
+  , herr_TryAgain
+    :: CInt
+#ifdef mingw32_HOST_OS
+herr_HostNotFound = error "herr_HostNotFound: Not implemented yet."
+herr_NoData       = error "herr_NoData: Not implemented yet."
+herr_NoRecovery   = error "herr_NoRecovery: Not implemented yet."
+herr_TryAgain     = error "herr_TryAgain: Not implemented yet."
+#else
+herr_HostNotFound = error "herr_HostNotFound: Not implemented yet."
+herr_NoData       = error "herr_NoData: Not implemented yet."
+herr_NoRecovery   = error "herr_NoRecovery: Not implemented yet."
+herr_TryAgain     = error "herr_TryAgain: Not implemented yet."
+#endif
+
+getHErrno :: IO CInt
+getHErrno = error "getHErrno: Not implemented yet."
diff --git a/Foundation/System/Bindings/Network.hsc b/Foundation/System/Bindings/Network.hsc
deleted file mode 100644
index 082a6ae..0000000
--- a/Foundation/System/Bindings/Network.hsc
+++ /dev/null
@@ -1,46 +0,0 @@
--- |
--- Module      :  Foundation.System.Bindings.HostName
--- License     :  BSD-style
--- Maintainer  :  Nicolas Di Prima <nicolas@primetype.co.uk>
--- Stability   :  provisional
--- Portability :  portable
---
-{-# OPTIONS_HADDOCK hide #-}
-module Foundation.System.Bindings.Network
-    ( -- * error
-      getHErrno
-    , herr_HostNotFound
-    , herr_NoData
-    , herr_NoRecovery
-    , herr_TryAgain
-    ) where
-
-import Basement.Compat.Base
-import Foreign.C.Types
-
-#ifdef mingw32_HOST_OS
-# include <winsock2.h>
-#else
-# include "netinet/in.h"
-# include "netdb.h"
-#endif
-
-herr_HostNotFound
-  , herr_NoData
-  , herr_NoRecovery
-  , herr_TryAgain
-    :: CInt
-#ifdef mingw32_HOST_OS
-herr_HostNotFound = (#const WSAHOST_NOT_FOUND)
-herr_NoData       = (#const WSANO_DATA)
-herr_NoRecovery   = (#const WSANO_RECOVERY)
-herr_TryAgain     = (#const WSATRY_AGAIN)
-#else
-herr_HostNotFound = (#const HOST_NOT_FOUND)
-herr_NoData       = (#const NO_DATA)
-herr_NoRecovery   = (#const NO_RECOVERY)
-herr_TryAgain     = (#const TRY_AGAIN)
-#endif
-
-foreign import ccall unsafe "foundation_network_get_h_errno"
-    getHErrno :: IO CInt
diff --git a/Foundation/System/Bindings/Posix.hsc b/Foundation/System/Bindings/Posix.hsc
index b2afe62..d5acea4 100644
--- a/Foundation/System/Bindings/Posix.hsc
+++ b/Foundation/System/Bindings/Posix.hsc
@@ -298,37 +298,37 @@ sysPosix_MS_ASYNC      = (#const MS_ASYNC)
 sysPosix_MS_SYNC       = (#const MS_SYNC)
 sysPosix_MS_INVALIDATE = (#const MS_INVALIDATE)
 
-foreign import ccall unsafe "mmap"
-    sysPosixMmap :: Ptr a -> CSize -> CMemProtFlags -> CMemMappingFlags -> CFd -> COff -> IO (Ptr a)
+sysPosixMmap :: Ptr a -> CSize -> CMemProtFlags -> CMemMappingFlags -> CFd -> COff -> IO (Ptr a)
+sysPosixMmap = error "sysPosixMmap: Not implemented yet."
 
-foreign import ccall unsafe "munmap"
-    sysPosixMunmap :: Ptr a -> CSize -> IO CInt
+sysPosixMunmap :: Ptr a -> CSize -> IO CInt
+sysPosixMunmap = error "sysPosixMunmap: Not implemented yet."
 
 #if defined(POSIX_MADV_NORMAL)
-foreign import ccall unsafe "posix_madvise"
-    sysPosixMadvise :: Ptr a -> CSize -> CMemAdvice -> IO CInt
+sysPosixMadvise :: Ptr a -> CSize -> CMemAdvice -> IO CInt
+sysPosixMadvise = error "sysPosixMadvise: Not implemented yet."
 #else
-foreign import ccall unsafe "madvise"
-    sysPosixMadvise :: Ptr a -> CSize -> CMemAdvice -> IO CInt
+sysPosixMadvise :: Ptr a -> CSize -> CMemAdvice -> IO CInt
+sysPosixMadvise = error "sysPosixMadvise: Not implemented yet."
 #endif
 
-foreign import ccall unsafe "msync"
-    sysPosixMsync :: Ptr a -> CSize -> CMemSyncFlags -> IO CInt
+sysPosixMsync :: Ptr a -> CSize -> CMemSyncFlags -> IO CInt
+sysPosixMsync = error "sysPosixMsync: Not implemented yet."
 
-foreign import ccall unsafe "mprotect"
-    sysPosixMprotect :: Ptr a -> CSize -> CMemProtFlags -> IO CInt
+sysPosixMprotect :: Ptr a -> CSize -> CMemProtFlags -> IO CInt
+sysPosixMprotect = error "sysPosixMprotect: Not implemented yet."
 
 #ifndef __HAIKU__
-foreign import ccall unsafe "mlock"
-    sysPosixMlock :: Ptr a -> CSize -> IO CInt
+sysPosixMlock :: Ptr a -> CSize -> IO CInt
+sysPosixMlock = error "sysPosixMlock: Not implemented yet."
 #else
 sysPosixMlock :: Ptr a -> CSize -> IO CInt
 sysPosixMlock _ _ = return (-1)
 #endif
 
 #ifndef __HAIKU__
-foreign import ccall unsafe "munlock"
-    sysPosixMunlock :: Ptr a -> CSize -> IO CInt
+sysPosixMunlock :: Ptr a -> CSize -> IO CInt
+sysPosixMunlock = error "sysPosixMunlock: Not implemented yet."
 #else
 sysPosixMunlock :: Ptr a -> CSize -> IO CInt
 sysPosixMunlock _ _ = return (-1)
@@ -337,45 +337,45 @@ sysPosixMunlock _ _ = return (-1)
 sysPosix_SC_PAGESIZE :: CSysconfName
 sysPosix_SC_PAGESIZE = (#const _SC_PAGESIZE)
 
-foreign import ccall unsafe "sysconf"
-    sysPosixSysconf :: CSysconfName -> CLong
+sysPosixSysconf :: CSysconfName -> CLong
+sysPosixSysconf = error "sysPosixSysconf: Not implemented yet."
 --------------------------------------------------------------------------------
 -- files
 --------------------------------------------------------------------------------
-foreign import ccall unsafe "open"
-    sysPosixOpen :: Ptr CChar -> COpenFlags -> CMode -> IO CFd
-foreign import ccall unsafe "openat"
-    sysPosixOpenAt :: CFd -> Ptr CChar -> COpenFlags -> CMode -> IO CFd
-foreign import ccall unsafe "close"
-    sysPosixClose :: CFd -> IO CInt
+sysPosixOpen :: Ptr CChar -> COpenFlags -> CMode -> IO CFd
+sysPosixOpen = error "sysPosixOpen: Not implemented yet."
+sysPosixOpenAt :: CFd -> Ptr CChar -> COpenFlags -> CMode -> IO CFd
+sysPosixOpenAt = error "sysPosixOpenAt: Not implemented yet."
+sysPosixClose :: CFd -> IO CInt
+sysPosixClose = error "sysPosixClose: Not implemented yet."
 
-foreign import capi "fcntl.h fcntl"
-    sysPosixFnctlNoArg :: CFd -> CInt -> IO CInt
-foreign import capi "fcntl.h fcntl"
-    sysPosixFnctlPtr :: CFd -> CInt -> Ptr a -> IO CInt
+sysPosixFnctlNoArg :: CFd -> CInt -> IO CInt
+sysPosixFnctlNoArg = error "sysPosixFnctlNoArg: Not implemented yet."
+sysPosixFnctlPtr :: CFd -> CInt -> Ptr a -> IO CInt
+sysPosixFnctlPtr = error "sysPosixFnctlPtr: Not implemented yet."
 
-foreign import ccall unsafe "ftruncate"
-    sysPosixFtruncate :: CFd -> COff -> IO CInt
+sysPosixFtruncate :: CFd -> COff -> IO CInt
+sysPosixFtruncate = error "sysPosixFtruncate: Not implemented yet."
 
 --------------------------------------------------------------------------------
 -- directories
 --------------------------------------------------------------------------------
 
-foreign import ccall unsafe "opendir"
-    sysPosixOpendir :: Ptr CChar -> IO (Ptr CDir)
-foreign import ccall unsafe "fdopendir"
-    sysPosixFdopendir :: CFd -> IO (Ptr CDir)
-foreign import ccall unsafe "readdir"
-    sysPosixReaddir :: Ptr CDir -> IO (Ptr CDirent)
-foreign import ccall unsafe "readdir_r"
-    sysPosixReaddirR :: Ptr CDir -> Ptr CDirent -> Ptr (Ptr CDirent) -> IO CInt
-foreign import ccall unsafe "telldir"
-    sysPosixTelldir :: Ptr CDir -> IO CLong
-foreign import ccall unsafe "seekdir"
-    sysPosixSeekdir :: Ptr CDir -> CLong -> IO ()
-foreign import ccall unsafe "rewinddir"
-    sysPosixRewinddir :: Ptr CDir -> IO ()
-foreign import ccall unsafe "closedir"
-    sysPosixClosedir :: Ptr CDir -> IO CInt
-foreign import ccall unsafe "dirfd"
-    sysPosixDirfd :: Ptr CDir -> IO CFd
+sysPosixOpendir :: Ptr CChar -> IO (Ptr CDir)
+sysPosixOpendir = error "sysPosixOpendir: Not implemented yet."
+sysPosixFdopendir :: CFd -> IO (Ptr CDir)
+sysPosixFdopendir = error "sysPosixFdopendir: Not implemented yet."
+sysPosixReaddir :: Ptr CDir -> IO (Ptr CDirent)
+sysPosixReaddir = error "sysPosixReaddir: Not implemented yet."
+sysPosixReaddirR :: Ptr CDir -> Ptr CDirent -> Ptr (Ptr CDirent) -> IO CInt
+sysPosixReaddirR = error "sysPosixReaddirR: Not implemented yet."
+sysPosixTelldir :: Ptr CDir -> IO CLong
+sysPosixTelldir = error "sysPosixTelldir: Not implemented yet."
+sysPosixSeekdir :: Ptr CDir -> CLong -> IO ()
+sysPosixSeekdir = error "sysPosixSeekdir: Not implemented yet."
+sysPosixRewinddir :: Ptr CDir -> IO ()
+sysPosixRewinddir = error "sysPosixRewinddir: Not implemented yet."
+sysPosixClosedir :: Ptr CDir -> IO CInt
+sysPosixClosedir = error "sysPosixClosedir: Not implemented yet."
+sysPosixDirfd :: Ptr CDir -> IO CFd
+sysPosixDirfd = error "sysPosixDirfd: Not implemented yet."
diff --git a/Foundation/System/Bindings/PosixDef.hs b/Foundation/System/Bindings/PosixDef.hs
new file mode 100644
index 0000000..53303ca
--- /dev/null
+++ b/Foundation/System/Bindings/PosixDef.hs
@@ -0,0 +1,25 @@
+{-# OPTIONS_HADDOCK hide #-}
+module Foundation.System.Bindings.PosixDef
+    ( CErrno
+    , CFd
+    , CMemProtFlags
+    , CMemMappingFlags
+    , CMemAdvice
+    , CMemSyncFlags
+    , CSysconfName
+    , COpenFlags
+    , COff(..)
+    , CMode(..)
+    ) where
+
+import Foreign.C.Types
+import System.Posix.Types (COff(..), CMode(..))
+
+type CErrno = CInt
+type CFd = CInt
+type CMemProtFlags = CInt
+type CMemMappingFlags = CInt
+type CMemAdvice = CInt
+type CMemSyncFlags = CInt
+type CSysconfName = CInt
+type COpenFlags = CInt
diff --git a/Foundation/System/Bindings/PosixDef.hsc b/Foundation/System/Bindings/PosixDef.hsc
deleted file mode 100644
index 53303ca..0000000
--- a/Foundation/System/Bindings/PosixDef.hsc
+++ /dev/null
@@ -1,25 +0,0 @@
-{-# OPTIONS_HADDOCK hide #-}
-module Foundation.System.Bindings.PosixDef
-    ( CErrno
-    , CFd
-    , CMemProtFlags
-    , CMemMappingFlags
-    , CMemAdvice
-    , CMemSyncFlags
-    , CSysconfName
-    , COpenFlags
-    , COff(..)
-    , CMode(..)
-    ) where
-
-import Foreign.C.Types
-import System.Posix.Types (COff(..), CMode(..))
-
-type CErrno = CInt
-type CFd = CInt
-type CMemProtFlags = CInt
-type CMemMappingFlags = CInt
-type CMemAdvice = CInt
-type CMemSyncFlags = CInt
-type CSysconfName = CInt
-type COpenFlags = CInt
diff --git a/Foundation/System/Bindings/Time.hs b/Foundation/System/Bindings/Time.hs
new file mode 100644
index 0000000..12eb681
--- /dev/null
+++ b/Foundation/System/Bindings/Time.hs
@@ -0,0 +1,122 @@
+-- |
+-- Module      :  Foundation.System.Bindings.Time
+-- Maintainer  :  Haskell foundation
+--
+
+module Foundation.System.Bindings.Time where
+
+import Basement.Compat.Base
+import Basement.Types.OffsetSize
+import Foreign.C.Types
+
+type CClockId = CInt
+data CTimeSpec
+data CTimeVal
+data CTimeZone
+
+size_CTimeSpec :: CSize
+size_CTimeSpec = error "size_CTimeSpec: Not implemented yet."
+
+ofs_CTimeSpec_Seconds :: Offset Word8
+ofs_CTimeSpec_Seconds = error "ofs_CTimeSpec_Seconds: Not implemented yet."
+
+ofs_CTimeSpec_NanoSeconds :: Offset Word8
+ofs_CTimeSpec_NanoSeconds = error "ofs_CTimeSpec_NanoSeconds: Not implemented yet."
+
+size_CTimeVal :: CSize
+size_CTimeVal = error "size_CTimeVal: Not implemented yet."
+
+size_CTimeZone :: CSize
+size_CTimeZone = error "size_CTimeZone: Not implemented yet."
+
+size_CTimeT :: CSize
+size_CTimeT = error "size_CTimeT: Not implemented yet."
+
+------------------------------------------------------------------------
+#ifdef FOUNDATION_SYSTEM_API_NO_CLOCK
+
+#define FOUNDATION_CLOCK_REALTIME 0
+#define FOUNDATION_CLOCK_MONOTONIC 1
+#define FOUNDATION_CLOCK_PROCESS_CPUTIME_ID 2
+#define FOUNDATION_CLOCK_THREAD_CPUTIME_ID 3
+
+#endif
+
+
+sysTime_CLOCK_REALTIME :: CClockId
+#ifdef FOUNDATION_SYSTEM_API_NO_CLOCK
+sysTime_CLOCK_REALTIME = error "sysTime_CLOCK_REALTIME: Not implemented yet."
+#else
+sysTime_CLOCK_REALTIME = error "sysTime_CLOCK_REALTIME: Not implemented yet."
+#endif
+
+sysTime_CLOCK_MONOTONIC :: CClockId
+#ifdef FOUNDATION_SYSTEM_API_NO_CLOCK
+sysTime_CLOCK_MONOTONIC = error "sysTime_CLOCK_MONOTONIC: Not implemented yet."
+#else
+sysTime_CLOCK_MONOTONIC = error "sysTime_CLOCK_MONOTONIC: Not implemented yet."
+#endif
+
+sysTime_CLOCK_PROCESS_CPUTIME_ID :: CClockId
+#ifdef FOUNDATION_SYSTEM_API_NO_CLOCK
+sysTime_CLOCK_PROCESS_CPUTIME_ID = error "sysTime_CLOCK_PROCESS_CPUTIME_ID: Not implemented yet."
+#else
+sysTime_CLOCK_PROCESS_CPUTIME_ID = error "sysTime_CLOCK_PROCESS_CPUTIME_ID: Not implemented yet."
+#endif
+
+sysTime_CLOCK_THREAD_CPUTIME_ID :: CClockId
+#ifdef FOUNDATION_SYSTEM_API_NO_CLOCK
+sysTime_CLOCK_THREAD_CPUTIME_ID = error "sysTime_CLOCK_THREAD_CPUTIME_ID: Not implemented yet."
+#else
+sysTime_CLOCK_THREAD_CPUTIME_ID = error "sysTime_CLOCK_THREAD_CPUTIME_ID: Not implemented yet."
+#endif
+
+#ifdef CLOCK_MONOTONIC_RAW
+sysTime_CLOCK_MONOTONIC_RAW :: CClockId
+sysTime_CLOCK_MONOTONIC_RAW = error "sysTime_CLOCK_MONOTONIC_RAW: Not implemented yet."
+#endif
+
+#ifdef CLOCK_REALTIME_COARSE
+sysTime_CLOCK_REALTIME_COARSE :: CClockId
+sysTime_CLOCK_REALTIME_COARSE = error "sysTime_CLOCK_REALTIME_COARSE: Not implemented yet."
+#endif
+
+#ifdef CLOCK_MONOTIC_COARSE
+sysTime_CLOCK_MONOTONIC_COARSE :: CClockId
+sysTime_CLOCK_MONOTONIC_COARSE = error "sysTime_CLOCK_MONOTONIC_COARSE: Not implemented yet."
+#endif
+
+#ifdef CLOCK_BOOTTIME
+sysTime_CLOCK_BOOTTIME :: CClockId
+sysTime_CLOCK_BOOTTIME = error "sysTime_CLOCK_BOOTTIME: Not implemented yet."
+#endif
+
+#ifdef CLOCK_REALTIME_ALARM
+sysTime_CLOCK_REALTIME_ALARM :: CClockId
+sysTime_CLOCK_REALTIME_ALARM = error "sysTime_CLOCK_REALTIME_ALARM: Not implemented yet."
+#endif
+
+#ifdef CLOCK_BOOTTIME_ALARM
+sysTime_CLOCK_BOOTTIME_ALARM :: CClockId
+sysTime_CLOCK_BOOTTIME_ALARM = error "sysTime_CLOCK_BOOTTIME_ALARM: Not implemented yet."
+#endif
+
+#ifdef CLOCK_TAI
+sysTime_CLOCK_TAI :: CClockId
+sysTime_CLOCK_TAI = error "sysTime_CLOCK_TAI: Not implemented yet."
+#endif
+
+#ifdef FOUNDATION_SYSTEM_API_NO_CLOCK
+sysTimeClockGetRes :: CClockId -> Ptr CTimeSpec -> IO CInt
+sysTimeClockGetRes = error "sysTimeClockGetRes: Not implemented yet."
+sysTimeClockGetTime :: CClockId -> Ptr CTimeSpec -> IO CInt
+sysTimeClockGetTime = error "sysTimeClockGetTime: Not implemented yet."
+#else
+sysTimeClockGetRes :: CClockId -> Ptr CTimeSpec -> IO CInt
+sysTimeClockGetRes = error "sysTimeClockGetRes: Not implemented yet."
+sysTimeClockGetTime :: CClockId -> Ptr CTimeSpec -> IO CInt
+sysTimeClockGetTime = error "sysTimeClockGetTime: Not implemented yet."
+#endif
+
+sysTimeGetTimeOfDay :: Ptr CTimeVal -> Ptr CTimeZone -> IO CInt
+sysTimeGetTimeOfDay = error "sysTimeGetTimeOfDay: Not implemented yet."
diff --git a/Foundation/System/Bindings/Time.hsc b/Foundation/System/Bindings/Time.hsc
deleted file mode 100644
index 0beb7f3..0000000
--- a/Foundation/System/Bindings/Time.hsc
+++ /dev/null
@@ -1,126 +0,0 @@
--- |
--- Module      :  Foundation.System.Bindings.Time
--- Maintainer  :  Haskell foundation
---
-
-module Foundation.System.Bindings.Time where
-
-import Basement.Compat.Base
-import Basement.Types.OffsetSize
-import Foreign.C.Types
-
-#include <time.h>
-#include <sys/time.h>
-#include "foundation_system.h"
-
-type CClockId = CInt
-data CTimeSpec
-data CTimeVal
-data CTimeZone
-
-size_CTimeSpec :: CSize
-size_CTimeSpec = #const sizeof(struct timespec)
-
-ofs_CTimeSpec_Seconds :: Offset Word8
-ofs_CTimeSpec_Seconds = Offset (#offset struct timespec, tv_sec)
-
-ofs_CTimeSpec_NanoSeconds :: Offset Word8
-ofs_CTimeSpec_NanoSeconds = Offset (#offset struct timespec, tv_nsec)
-
-size_CTimeVal :: CSize
-size_CTimeVal = #const sizeof(struct timeval)
-
-size_CTimeZone :: CSize
-size_CTimeZone = #const sizeof(struct timezone)
-
-size_CTimeT :: CSize
-size_CTimeT = #const sizeof(time_t)
-
-------------------------------------------------------------------------
-#ifdef FOUNDATION_SYSTEM_API_NO_CLOCK
-
-#define FOUNDATION_CLOCK_REALTIME 0
-#define FOUNDATION_CLOCK_MONOTONIC 1
-#define FOUNDATION_CLOCK_PROCESS_CPUTIME_ID 2
-#define FOUNDATION_CLOCK_THREAD_CPUTIME_ID 3
-
-#endif
-
-
-sysTime_CLOCK_REALTIME :: CClockId
-#ifdef FOUNDATION_SYSTEM_API_NO_CLOCK
-sysTime_CLOCK_REALTIME = (#const FOUNDATION_CLOCK_REALTIME)
-#else
-sysTime_CLOCK_REALTIME = (#const CLOCK_REALTIME)
-#endif
-
-sysTime_CLOCK_MONOTONIC :: CClockId
-#ifdef FOUNDATION_SYSTEM_API_NO_CLOCK
-sysTime_CLOCK_MONOTONIC = (#const FOUNDATION_CLOCK_MONOTONIC)
-#else
-sysTime_CLOCK_MONOTONIC = (#const CLOCK_MONOTONIC)
-#endif
-
-sysTime_CLOCK_PROCESS_CPUTIME_ID :: CClockId
-#ifdef FOUNDATION_SYSTEM_API_NO_CLOCK
-sysTime_CLOCK_PROCESS_CPUTIME_ID = (#const FOUNDATION_CLOCK_PROCESS_CPUTIME_ID)
-#else
-sysTime_CLOCK_PROCESS_CPUTIME_ID = (#const CLOCK_PROCESS_CPUTIME_ID)
-#endif
-
-sysTime_CLOCK_THREAD_CPUTIME_ID :: CClockId
-#ifdef FOUNDATION_SYSTEM_API_NO_CLOCK
-sysTime_CLOCK_THREAD_CPUTIME_ID = (#const FOUNDATION_CLOCK_THREAD_CPUTIME_ID)
-#else
-sysTime_CLOCK_THREAD_CPUTIME_ID = (#const CLOCK_THREAD_CPUTIME_ID)
-#endif
-
-#ifdef CLOCK_MONOTONIC_RAW
-sysTime_CLOCK_MONOTONIC_RAW :: CClockId
-sysTime_CLOCK_MONOTONIC_RAW = (#const CLOCK_MONOTONIC_RAW)
-#endif
-
-#ifdef CLOCK_REALTIME_COARSE
-sysTime_CLOCK_REALTIME_COARSE :: CClockId
-sysTime_CLOCK_REALTIME_COARSE = (#const CLOCK_REALTIME_COARSE)
-#endif
-
-#ifdef CLOCK_MONOTIC_COARSE
-sysTime_CLOCK_MONOTONIC_COARSE :: CClockId
-sysTime_CLOCK_MONOTONIC_COARSE = (#const CLOCK_MONOTONIC_COARSE)
-#endif
-
-#ifdef CLOCK_BOOTTIME
-sysTime_CLOCK_BOOTTIME :: CClockId
-sysTime_CLOCK_BOOTTIME = (#const CLOCK_BOOTTIME)
-#endif
-
-#ifdef CLOCK_REALTIME_ALARM
-sysTime_CLOCK_REALTIME_ALARM :: CClockId
-sysTime_CLOCK_REALTIME_ALARM = (#const CLOCK_REALTIME_ALARM)
-#endif
-
-#ifdef CLOCK_BOOTTIME_ALARM
-sysTime_CLOCK_BOOTTIME_ALARM :: CClockId
-sysTime_CLOCK_BOOTTIME_ALARM = (#const CLOCK_BOOTTIME_ALARM)
-#endif
-
-#ifdef CLOCK_TAI
-sysTime_CLOCK_TAI :: CClockId
-sysTime_CLOCK_TAI = (#const CLOCK_TAI)
-#endif
-
-#ifdef FOUNDATION_SYSTEM_API_NO_CLOCK
-foreign import ccall unsafe "foundation_time_clock_getres"
-    sysTimeClockGetRes :: CClockId -> Ptr CTimeSpec -> IO CInt
-foreign import ccall unsafe "foundation_time_clock_gettime"
-    sysTimeClockGetTime :: CClockId -> Ptr CTimeSpec -> IO CInt
-#else
-foreign import ccall unsafe "clock_getres"
-    sysTimeClockGetRes :: CClockId -> Ptr CTimeSpec -> IO CInt
-foreign import ccall unsafe "clock_gettime"
-    sysTimeClockGetTime :: CClockId -> Ptr CTimeSpec -> IO CInt
-#endif
-
-foreign import ccall unsafe "gettimeofday"
-    sysTimeGetTimeOfDay :: Ptr CTimeVal -> Ptr CTimeZone -> IO CInt
diff --git a/Foundation/System/Entropy/Unix.hs b/Foundation/System/Entropy/Unix.hs
index 8f602bb..0bfde8a 100644
--- a/Foundation/System/Entropy/Unix.hs
+++ b/Foundation/System/Entropy/Unix.hs
@@ -77,5 +77,5 @@ supportSyscall = unsafePerformIO ((==) 0 <$> c_sysrandom_linux nullPtr 0)
 {-# NOINLINE supportSyscall #-}
 
 -- return 0 on success, !0 for failure
-foreign import ccall unsafe "foundation_sysrandom_linux"
-   c_sysrandom_linux :: Ptr Word8 -> CSize -> IO Int
+c_sysrandom_linux :: Ptr Word8 -> CSize -> IO Int
+c_sysrandom_linux = error "c_sysrandom_linux: Not implemented yet."
diff --git a/Foundation/System/Entropy/Windows.hs b/Foundation/System/Entropy/Windows.hs
index 34e23a6..b32aee1 100644
--- a/Foundation/System/Entropy/Windows.hs
+++ b/Foundation/System/Entropy/Windows.hs
@@ -62,12 +62,12 @@ type CryptCtx = Word32
 #endif
 
 -- Declare the required CryptoAPI imports
-foreign import WINDOWS_CCONV unsafe "CryptAcquireContextA"
-   c_cryptAcquireCtx :: Ptr CryptCtx -> CString -> CString -> DWORD -> DWORD -> IO BOOL
-foreign import WINDOWS_CCONV unsafe "CryptGenRandom"
-   c_cryptGenRandom :: CryptCtx -> DWORD -> Ptr BYTE -> IO BOOL
-foreign import WINDOWS_CCONV unsafe "CryptReleaseContext"
-   c_cryptReleaseCtx :: CryptCtx -> DWORD -> IO BOOL
+c_cryptAcquireCtx :: Ptr CryptCtx -> CString -> CString -> DWORD -> DWORD -> IO BOOL
+c_cryptAcquireCtx = error "c_cryptAcquireCtx: Not implemented yet."
+c_cryptGenRandom :: CryptCtx -> DWORD -> Ptr BYTE -> IO BOOL
+c_cryptGenRandom = error "c_cryptGenRandom: Not implemented yet."
+c_cryptReleaseCtx :: CryptCtx -> DWORD -> IO BOOL
+c_cryptReleaseCtx = error "c_cryptReleaseCtx: Not implemented yet."
 
 
 -- Define the constants we need from WinCrypt.h
diff --git a/Foundation/Timing.hs b/Foundation/Timing.hs
index 9a343e4..e86c922 100644
--- a/Foundation/Timing.hs
+++ b/Foundation/Timing.hs
@@ -25,7 +25,8 @@ import           Foundation.Time.Bindings
 import           Control.Exception (evaluate)
 import           System.Mem (performGC)
 import           Data.Function (on)
-import qualified GHC.Stats as GHC
+import qualified GHC.Err as Err
+-- import qualified GHC.Stats as GHC
 
 
 data Timing = Timing
@@ -49,15 +50,13 @@ getGCStats = do
 diffGC :: Maybe GHC.RTSStats -> Maybe GHC.RTSStats -> Maybe Word64
 diffGC gc2 gc1 = ((-) `on` GHC.allocated_bytes) <$> gc2 <*> gc1
 #else
-type GCStats = GHC.GCStats
+type GCStats = ()
 
 getGCStats :: IO (Maybe GCStats)
-getGCStats = do
-    r <- GHC.getGCStatsEnabled
-    if r then pure Nothing else Just <$> GHC.getGCStats
+getGCStats = Err.error "getGCStats: Not implemented yet."
 
-diffGC :: Maybe GHC.GCStats -> Maybe GHC.GCStats -> Maybe Word64
-diffGC gc2 gc1 = integralCast <$> (((-) `on` GHC.bytesAllocated) <$> gc2 <*> gc1)
+diffGC :: Maybe GCStats -> Maybe GCStats -> Maybe Word64
+diffGC gc2 gc1 = Err.error "diffGC: Not implemented yet."
 #endif
 
 -- | Simple one-time measurement of time & other metrics spent in a function
diff --git a/foundation.cabal b/foundation.cabal
index 4507b87..a219633 100644
--- a/foundation.cabal
+++ b/foundation.cabal
@@ -191,6 +191,7 @@ library
                       TypeFamilies
                       BangPatterns
                       DeriveDataTypeable
+                      CPP
   build-depends:     base >= 4.7 && < 5
                    , basement == 0.0.4
                    , ghc-prim
-- 
2.7.4 (Apple Git-66)

